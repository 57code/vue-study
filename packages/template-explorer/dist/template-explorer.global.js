(function () {
  'use strict';

  /**
   * Make a map and return a function for checking if a key
   * is in that map.
   * IMPORTANT: all calls of this function must be prefixed with
   * \/\*#\_\_PURE\_\_\*\/
   * So that rollup can tree-shake them if necessary.
   */
  function makeMap(str, expectsLowerCase) {
      const map = Object.create(null);
      const list = str.split(',');
      for (let i = 0; i < list.length; i++) {
          map[list[i]] = true;
      }
      return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
  }

  // Patch flags are optimization hints generated by the compiler.
  // when a block with dynamicChildren is encountered during diff, the algorithm
  // enters "optimized mode". In this mode, we know that the vdom is produced by
  // a render function generated by the compiler, so the algorithm only needs to
  // handle updates explicitly marked by these patch flags.
  // dev only flag -> name mapping
  const PatchFlagNames = {
      [1 /* TEXT */]: `TEXT`,
      [2 /* CLASS */]: `CLASS`,
      [4 /* STYLE */]: `STYLE`,
      [8 /* PROPS */]: `PROPS`,
      [16 /* FULL_PROPS */]: `FULL_PROPS`,
      [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
      [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
      [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
      [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
      [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
      [512 /* NEED_PATCH */]: `NEED_PATCH`,
      [-1 /* HOISTED */]: `HOISTED`,
      [-2 /* BAIL */]: `BAIL`
  };

  const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
      'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
      'Object,Boolean,String,RegExp,Map,Set,JSON,Intl';
  const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);

  /**
   * On the client we only need to offer special cases for boolean attributes that
   * have different names from their corresponding dom properties:
   * - itemscope -> N/A
   * - allowfullscreen -> allowFullscreen
   * - formnovalidate -> formNoValidate
   * - ismap -> isMap
   * - nomodule -> noModule
   * - novalidate -> noValidate
   * - readonly -> readOnly
   */
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
  /**
   * The full list is needed during SSR to produce the correct initial markup.
   */
  const isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +
      `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
      `loop,open,required,reversed,scoped,seamless,` +
      `checked,muted,multiple,selected`);
  const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
  const attrValidationCache = {};
  function isSSRSafeAttrName(name) {
      if (attrValidationCache.hasOwnProperty(name)) {
          return attrValidationCache[name];
      }
      const isUnsafe = unsafeAttrCharRE.test(name);
      if (isUnsafe) {
          console.error(`unsafe attribute name: ${name}`);
      }
      return (attrValidationCache[name] = !isUnsafe);
  }
  const propsToAttrMap = {
      acceptCharset: 'accept-charset',
      className: 'class',
      htmlFor: 'for',
      httpEquiv: 'http-equiv'
  };
  /**
   * CSS properties that accept plain numbers
   */
  const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +
      `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
      `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
      `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
      `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
      `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
      // SVG
      `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
      `stroke-miterlimit,stroke-opacity,stroke-width`);
  /**
   * Known attributes, this is used for stringification of runtime static nodes
   * so that we don't stringify bindings that cannot be set from HTML.
   * Don't also forget to allow `data-*` and `aria-*`!
   * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
   */
  const isKnownAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +
      `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
      `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
      `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
      `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
      `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
      `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
      `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
      `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
      `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
      `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
      `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
      `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
      `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
      `value,width,wrap`);

  function normalizeStyle(value) {
      if (isArray(value)) {
          const res = {};
          for (let i = 0; i < value.length; i++) {
              const item = value[i];
              const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);
              if (normalized) {
                  for (const key in normalized) {
                      res[key] = normalized[key];
                  }
              }
          }
          return res;
      }
      else if (isObject(value)) {
          return value;
      }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:(.+)/;
  function parseStringStyle(cssText) {
      const ret = {};
      cssText.split(listDelimiterRE).forEach(item => {
          if (item) {
              const tmp = item.split(propertyDelimiterRE);
              tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
          }
      });
      return ret;
  }
  function stringifyStyle(styles) {
      let ret = '';
      if (!styles) {
          return ret;
      }
      for (const key in styles) {
          const value = styles[key];
          const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
          if (isString(value) ||
              (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {
              // only render valid values
              ret += `${normalizedKey}:${value};`;
          }
      }
      return ret;
  }
  function normalizeClass(value) {
      let res = '';
      if (isString(value)) {
          res = value;
      }
      else if (isArray(value)) {
          for (let i = 0; i < value.length; i++) {
              res += normalizeClass(value[i]) + ' ';
          }
      }
      else if (isObject(value)) {
          for (const name in value) {
              if (value[name]) {
                  res += name + ' ';
              }
          }
      }
      return res.trim();
  }

  // These tag configs are shared between compiler-dom and runtime-dom, so they
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
  const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
      'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +
      'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
      'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +
      'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
      'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
      'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
      'option,output,progress,select,textarea,details,dialog,menu,' +
      'summary,template,blockquote,iframe,tfoot';
  // https://developer.mozilla.org/en-US/docs/Web/SVG/Element
  const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
      'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
      'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
      'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
      'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
      'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
      'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
      'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
      'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
      'text,textPath,title,tspan,unknown,use,view';
  const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
  const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
  const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
  const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

  const escapeRE = /["'&<>]/;
  function escapeHtml(string) {
      const str = '' + string;
      const match = escapeRE.exec(str);
      if (!match) {
          return str;
      }
      let html = '';
      let escaped;
      let index;
      let lastIndex = 0;
      for (index = match.index; index < str.length; index++) {
          switch (str.charCodeAt(index)) {
              case 34: // "
                  escaped = '&quot;';
                  break;
              case 38: // &
                  escaped = '&amp;';
                  break;
              case 39: // '
                  escaped = '&#39;';
                  break;
              case 60: // <
                  escaped = '&lt;';
                  break;
              case 62: // >
                  escaped = '&gt;';
                  break;
              default:
                  continue;
          }
          if (lastIndex !== index) {
              html += str.substring(lastIndex, index);
          }
          lastIndex = index + 1;
          html += escaped;
      }
      return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
  }

  /**
   * For converting {{ interpolation }} values to displayed strings.
   * @private
   */
  const toDisplayString = (val) => {
      return val == null
          ? ''
          : isObject(val)
              ? JSON.stringify(val, replacer, 2)
              : String(val);
  };
  const replacer = (_key, val) => {
      if (isMap(val)) {
          return {
              [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
                  entries[`${key} =>`] = val;
                  return entries;
              }, {})
          };
      }
      else if (isSet(val)) {
          return {
              [`Set(${val.size})`]: [...val.values()]
          };
      }
      else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
          return String(val);
      }
      return val;
  };

  /**
   * List of @babel/parser plugins that are used for template expression
   * transforms and SFC script transforms. By default we enable proposals slated
   * for ES2020. This will need to be updated as the spec moves forward.
   * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins
   */
  const babelParserDefaultPlugins = [
      'bigInt',
      'optionalChaining',
      'nullishCoalescingOperator'
  ];
  const EMPTY_OBJ =  Object.freeze({})
      ;
  const EMPTY_ARR = [];
  const NOOP = () => { };
  /**
   * Always return false.
   */
  const NO = () => false;
  const onRE = /^on[^a-z]/;
  const isOn = (key) => onRE.test(key);
  const isModelListener = (key) => key.startsWith('onUpdate:');
  const extend = Object.assign;
  const remove = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
          arr.splice(i, 1);
      }
  };
  const hasOwnProperty = Object.prototype.hasOwnProperty;
  const hasOwn = (val, key) => hasOwnProperty.call(val, key);
  const isArray = Array.isArray;
  const isMap = (val) => toTypeString(val) === '[object Map]';
  const isSet = (val) => toTypeString(val) === '[object Set]';
  const isFunction = (val) => typeof val === 'function';
  const isString = (val) => typeof val === 'string';
  const isSymbol = (val) => typeof val === 'symbol';
  const isObject = (val) => val !== null && typeof val === 'object';
  const isPromise = (val) => {
      return isObject(val) && isFunction(val.then) && isFunction(val.catch);
  };
  const objectToString = Object.prototype.toString;
  const toTypeString = (value) => objectToString.call(value);
  const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
  };
  const isPlainObject = (val) => toTypeString(val) === '[object Object]';
  const isIntegerKey = (key) => isString(key) &&
      key !== 'NaN' &&
      key[0] !== '-' &&
      '' + parseInt(key, 10) === key;
  const isReservedProp = /*#__PURE__*/ makeMap('key,ref,' +
      'onVnodeBeforeMount,onVnodeMounted,' +
      'onVnodeBeforeUpdate,onVnodeUpdated,' +
      'onVnodeBeforeUnmount,onVnodeUnmounted');
  const cacheStringFunction = (fn) => {
      const cache = Object.create(null);
      return ((str) => {
          const hit = cache[str];
          return hit || (cache[str] = fn(str));
      });
  };
  const camelizeRE = /-(\w)/g;
  /**
   * @private
   */
  const camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
  });
  const hyphenateRE = /\B([A-Z])/g;
  /**
   * @private
   */
  const hyphenate = cacheStringFunction((str) => {
      return str.replace(hyphenateRE, '-$1').toLowerCase();
  });
  /**
   * @private
   */
  const capitalize = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
  });
  // compare whether a value has changed, accounting for NaN.
  const hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
  const invokeArrayFns = (fns, arg) => {
      for (let i = 0; i < fns.length; i++) {
          fns[i](arg);
      }
  };
  const def = (obj, key, value) => {
      Object.defineProperty(obj, key, {
          configurable: true,
          enumerable: false,
          value
      });
  };

  function defaultOnError(error) {
      throw error;
  }
  function createCompilerError(code, loc, messages, additionalMessage) {
      const msg =  (messages || errorMessages)[code] + (additionalMessage || ``)
          ;
      const error = new SyntaxError(String(msg));
      error.code = code;
      error.loc = loc;
      return error;
  }
  const errorMessages = {
      // parse errors
      [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',
      [1 /* CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',
      [2 /* DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',
      [3 /* END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',
      [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal '/' in tags.",
      [5 /* EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',
      [6 /* EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',
      [7 /* EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',
      [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',
      [9 /* EOF_IN_TAG */]: 'Unexpected EOF in tag.',
      [10 /* INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',
      [11 /* INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',
      [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13 /* MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',
      [14 /* MISSING_END_TAG_NAME */]: 'End tag name was expected.',
      [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',
      [16 /* NESTED_COMMENT */]: "Unexpected '<!--' in comment.",
      [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).',
      [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).',
      [19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: "Attribute name cannot start with '='.",
      [21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: "'<?' is allowed only in XML context.",
      [22 /* UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal '/' in tags.",
      // Vue-specific parse errors
      [23 /* X_INVALID_END_TAG */]: 'Invalid end tag.',
      [24 /* X_MISSING_END_TAG */]: 'Element is missing end tag.',
      [25 /* X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',
      [26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' +
          'Note that dynamic directive argument cannot contain spaces.',
      // transform errors
      [27 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,
      [28 /* X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,
      [29 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if.`,
      [30 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,
      [31 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,
      [32 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,
      [33 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,
      [34 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,
      [35 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,
      [36 /* X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>.` +
          `When there are multiple named slots, all slots should use <template> ` +
          `syntax to avoid scope ambiguity.`,
      [37 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,
      [38 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +
          `default slot. These children will be ignored.`,
      [39 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,
      [40 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,
      [41 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,
      [42 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [43 /* X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,
      [44 /* X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,
      // generic errors
      [45 /* X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [46 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,
      [47 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [48 /* X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`
  };

  const FRAGMENT = Symbol( `Fragment` );
  const TELEPORT = Symbol( `Teleport` );
  const SUSPENSE = Symbol( `Suspense` );
  const KEEP_ALIVE = Symbol( `KeepAlive` );
  const BASE_TRANSITION = Symbol( `BaseTransition` );
  const OPEN_BLOCK = Symbol( `openBlock` );
  const CREATE_BLOCK = Symbol( `createBlock` );
  const CREATE_VNODE = Symbol( `createVNode` );
  const CREATE_COMMENT = Symbol( `createCommentVNode` );
  const CREATE_TEXT = Symbol( `createTextVNode` );
  const CREATE_STATIC = Symbol( `createStaticVNode` );
  const RESOLVE_COMPONENT = Symbol( `resolveComponent` );
  const RESOLVE_DYNAMIC_COMPONENT = Symbol( `resolveDynamicComponent` );
  const RESOLVE_DIRECTIVE = Symbol( `resolveDirective` );
  const WITH_DIRECTIVES = Symbol( `withDirectives` );
  const RENDER_LIST = Symbol( `renderList` );
  const RENDER_SLOT = Symbol( `renderSlot` );
  const CREATE_SLOTS = Symbol( `createSlots` );
  const TO_DISPLAY_STRING = Symbol( `toDisplayString` );
  const MERGE_PROPS = Symbol( `mergeProps` );
  const TO_HANDLERS = Symbol( `toHandlers` );
  const CAMELIZE = Symbol( `camelize` );
  const CAPITALIZE = Symbol( `capitalize` );
  const SET_BLOCK_TRACKING = Symbol( `setBlockTracking` );
  const PUSH_SCOPE_ID = Symbol( `pushScopeId` );
  const POP_SCOPE_ID = Symbol( `popScopeId` );
  const WITH_SCOPE_ID = Symbol( `withScopeId` );
  const WITH_CTX = Symbol( `withCtx` );
  // Name mapping for runtime helpers that need to be imported from 'vue' in
  // generated code. Make sure these are correctly exported in the runtime!
  // Using `any` here because TS doesn't allow symbols as index type.
  const helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_SCOPE_ID]: `withScopeId`,
      [WITH_CTX]: `withCtx`
  };
  function registerRuntimeHelpers(helpers) {
      Object.getOwnPropertySymbols(helpers).forEach(s => {
          helperNameMap[s] = helpers[s];
      });
  }

  // AST Utilities ---------------------------------------------------------------
  // Some expressions, e.g. sequence and conditional expressions, are never
  // associated with template nodes, so their source locations are just a stub.
  // Container types like CompoundExpression also don't need a real location.
  const locStub = {
      source: '',
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 }
  };
  function createRoot(children, loc = locStub) {
      return {
          type: 0 /* ROOT */,
          children,
          helpers: [],
          components: [],
          directives: [],
          hoists: [],
          imports: [],
          cached: 0,
          temps: 0,
          codegenNode: undefined,
          loc
      };
  }
  function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, loc = locStub) {
      if (context) {
          if (isBlock) {
              context.helper(OPEN_BLOCK);
              context.helper(CREATE_BLOCK);
          }
          else {
              context.helper(CREATE_VNODE);
          }
          if (directives) {
              context.helper(WITH_DIRECTIVES);
          }
      }
      return {
          type: 13 /* VNODE_CALL */,
          tag,
          props,
          children,
          patchFlag,
          dynamicProps,
          directives,
          isBlock,
          disableTracking,
          loc
      };
  }
  function createArrayExpression(elements, loc = locStub) {
      return {
          type: 17 /* JS_ARRAY_EXPRESSION */,
          loc,
          elements
      };
  }
  function createObjectExpression(properties, loc = locStub) {
      return {
          type: 15 /* JS_OBJECT_EXPRESSION */,
          loc,
          properties
      };
  }
  function createObjectProperty(key, value) {
      return {
          type: 16 /* JS_PROPERTY */,
          loc: locStub,
          key: isString(key) ? createSimpleExpression(key, true) : key,
          value
      };
  }
  function createSimpleExpression(content, isStatic, loc = locStub, isConstant = false) {
      return {
          type: 4 /* SIMPLE_EXPRESSION */,
          loc,
          isConstant,
          content,
          isStatic
      };
  }
  function createInterpolation(content, loc) {
      return {
          type: 5 /* INTERPOLATION */,
          loc,
          content: isString(content)
              ? createSimpleExpression(content, false, loc)
              : content
      };
  }
  function createCompoundExpression(children, loc = locStub) {
      return {
          type: 8 /* COMPOUND_EXPRESSION */,
          loc,
          children
      };
  }
  function createCallExpression(callee, args = [], loc = locStub) {
      return {
          type: 14 /* JS_CALL_EXPRESSION */,
          loc,
          callee,
          arguments: args
      };
  }
  function createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {
      return {
          type: 18 /* JS_FUNCTION_EXPRESSION */,
          params,
          returns,
          newline,
          isSlot,
          loc
      };
  }
  function createConditionalExpression(test, consequent, alternate, newline = true) {
      return {
          type: 19 /* JS_CONDITIONAL_EXPRESSION */,
          test,
          consequent,
          alternate,
          newline,
          loc: locStub
      };
  }
  function createCacheExpression(index, value, isVNode = false) {
      return {
          type: 20 /* JS_CACHE_EXPRESSION */,
          index,
          value,
          isVNode,
          loc: locStub
      };
  }
  function createBlockStatement(body) {
      return {
          type: 21 /* JS_BLOCK_STATEMENT */,
          body,
          loc: locStub
      };
  }
  function createTemplateLiteral(elements) {
      return {
          type: 22 /* JS_TEMPLATE_LITERAL */,
          elements,
          loc: locStub
      };
  }
  function createIfStatement(test, consequent, alternate) {
      return {
          type: 23 /* JS_IF_STATEMENT */,
          test,
          consequent,
          alternate,
          loc: locStub
      };
  }
  function createAssignmentExpression(left, right) {
      return {
          type: 24 /* JS_ASSIGNMENT_EXPRESSION */,
          left,
          right,
          loc: locStub
      };
  }
  function createSequenceExpression(expressions) {
      return {
          type: 25 /* JS_SEQUENCE_EXPRESSION */,
          expressions,
          loc: locStub
      };
  }
  function createReturnStatement(returns) {
      return {
          type: 26 /* JS_RETURN_STATEMENT */,
          returns,
          loc: locStub
      };
  }

  const isStaticExp = (p) => p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;
  const isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
  function isCoreComponent(tag) {
      if (isBuiltInType(tag, 'Teleport')) {
          return TELEPORT;
      }
      else if (isBuiltInType(tag, 'Suspense')) {
          return SUSPENSE;
      }
      else if (isBuiltInType(tag, 'KeepAlive')) {
          return KEEP_ALIVE;
      }
      else if (isBuiltInType(tag, 'BaseTransition')) {
          return BASE_TRANSITION;
      }
  }
  const nonIdentifierRE = /^\d|[^\$\w]/;
  const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
  const memberExpRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\[[^\]]+\])*$/;
  const isMemberExpression = (path) => {
      if (!path)
          return false;
      return memberExpRE.test(path.trim());
  };
  function getInnerRange(loc, offset, length) {
      const source = loc.source.substr(offset, length);
      const newLoc = {
          source,
          start: advancePositionWithClone(loc.start, loc.source, offset),
          end: loc.end
      };
      if (length != null) {
          newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
      }
      return newLoc;
  }
  function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
      return advancePositionWithMutation(extend({}, pos), source, numberOfCharacters);
  }
  // advance by mutation without cloning (for performance reasons), since this
  // gets called a lot in the parser
  function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
      let linesCount = 0;
      let lastNewLinePos = -1;
      for (let i = 0; i < numberOfCharacters; i++) {
          if (source.charCodeAt(i) === 10 /* newline char code */) {
              linesCount++;
              lastNewLinePos = i;
          }
      }
      pos.offset += numberOfCharacters;
      pos.line += linesCount;
      pos.column =
          lastNewLinePos === -1
              ? pos.column + numberOfCharacters
              : numberOfCharacters - lastNewLinePos;
      return pos;
  }
  function assert(condition, msg) {
      /* istanbul ignore if */
      if (!condition) {
          throw new Error(msg || `unexpected compiler condition`);
      }
  }
  function findDir(node, name, allowEmpty = false) {
      for (let i = 0; i < node.props.length; i++) {
          const p = node.props[i];
          if (p.type === 7 /* DIRECTIVE */ &&
              (allowEmpty || p.exp) &&
              (isString(name) ? p.name === name : name.test(p.name))) {
              return p;
          }
      }
  }
  function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
      for (let i = 0; i < node.props.length; i++) {
          const p = node.props[i];
          if (p.type === 6 /* ATTRIBUTE */) {
              if (dynamicOnly)
                  continue;
              if (p.name === name && (p.value || allowEmpty)) {
                  return p;
              }
          }
          else if (p.name === 'bind' &&
              (p.exp || allowEmpty) &&
              isBindKey(p.arg, name)) {
              return p;
          }
      }
  }
  function isBindKey(arg, name) {
      return !!(arg && isStaticExp(arg) && arg.content === name);
  }
  function hasDynamicKeyVBind(node) {
      return node.props.some(p => p.type === 7 /* DIRECTIVE */ &&
          p.name === 'bind' &&
          (!p.arg || // v-bind="obj"
              p.arg.type !== 4 /* SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]
              !p.arg.isStatic) // v-bind:[foo]
      );
  }
  function isText(node) {
      return node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */;
  }
  function isVSlot(p) {
      return p.type === 7 /* DIRECTIVE */ && p.name === 'slot';
  }
  function isTemplateNode(node) {
      return (node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */);
  }
  function isSlotOutlet(node) {
      return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;
  }
  function injectProp(node, prop, context) {
      let propsWithInjection;
      const props = node.type === 13 /* VNODE_CALL */ ? node.props : node.arguments[2];
      if (props == null || isString(props)) {
          propsWithInjection = createObjectExpression([prop]);
      }
      else if (props.type === 14 /* JS_CALL_EXPRESSION */) {
          // merged props... add ours
          // only inject key to object literal if it's the first argument so that
          // if doesn't override user provided keys
          const first = props.arguments[0];
          if (!isString(first) && first.type === 15 /* JS_OBJECT_EXPRESSION */) {
              first.properties.unshift(prop);
          }
          else {
              props.arguments.unshift(createObjectExpression([prop]));
          }
          propsWithInjection = props;
      }
      else if (props.type === 15 /* JS_OBJECT_EXPRESSION */) {
          let alreadyExists = false;
          // check existing key to avoid overriding user provided keys
          if (prop.key.type === 4 /* SIMPLE_EXPRESSION */) {
              const propKeyName = prop.key.content;
              alreadyExists = props.properties.some(p => p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
                  p.key.content === propKeyName);
          }
          if (!alreadyExists) {
              props.properties.unshift(prop);
          }
          propsWithInjection = props;
      }
      else {
          // single v-bind with expression, return a merged replacement
          propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
              createObjectExpression([prop]),
              props
          ]);
      }
      if (node.type === 13 /* VNODE_CALL */) {
          node.props = propsWithInjection;
      }
      else {
          node.arguments[2] = propsWithInjection;
      }
  }
  function toValidAssetId(name, type) {
      return `_${type}_${name.replace(/[^\w]/g, '_')}`;
  }
  // Check if a node contains expressions that reference current context scope ids
  function hasScopeRef(node, ids) {
      if (!node || Object.keys(ids).length === 0) {
          return false;
      }
      switch (node.type) {
          case 1 /* ELEMENT */:
              for (let i = 0; i < node.props.length; i++) {
                  const p = node.props[i];
                  if (p.type === 7 /* DIRECTIVE */ &&
                      (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
                      return true;
                  }
              }
              return node.children.some(c => hasScopeRef(c, ids));
          case 11 /* FOR */:
              if (hasScopeRef(node.source, ids)) {
                  return true;
              }
              return node.children.some(c => hasScopeRef(c, ids));
          case 9 /* IF */:
              return node.branches.some(b => hasScopeRef(b, ids));
          case 10 /* IF_BRANCH */:
              if (hasScopeRef(node.condition, ids)) {
                  return true;
              }
              return node.children.some(c => hasScopeRef(c, ids));
          case 4 /* SIMPLE_EXPRESSION */:
              return (!node.isStatic &&
                  isSimpleIdentifier(node.content) &&
                  !!ids[node.content]);
          case 8 /* COMPOUND_EXPRESSION */:
              return node.children.some(c => isObject(c) && hasScopeRef(c, ids));
          case 5 /* INTERPOLATION */:
          case 12 /* TEXT_CALL */:
              return hasScopeRef(node.content, ids);
          case 2 /* TEXT */:
          case 3 /* COMMENT */:
              return false;
          default:
              return false;
      }
  }

  // The default decoder only provides escapes for characters reserved as part of
  // the template syntax, and is only used if the custom renderer did not provide
  // a platform-specific decoder.
  const decodeRE = /&(gt|lt|amp|apos|quot);/g;
  const decodeMap = {
      gt: '>',
      lt: '<',
      amp: '&',
      apos: "'",
      quot: '"'
  };
  const defaultParserOptions = {
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0 /* HTML */,
      getTextMode: () => 0 /* DATA */,
      isVoidTag: NO,
      isPreTag: NO,
      isCustomElement: NO,
      decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
      onError: defaultOnError,
      comments: false
  };
  function baseParse(content, options = {}) {
      const context = createParserContext(content, options);
      const start = getCursor(context);
      return createRoot(parseChildren(context, 0 /* DATA */, []), getSelection(context, start));
  }
  function createParserContext(content, rawOptions) {
      const options = extend({}, defaultParserOptions);
      for (const key in rawOptions) {
          // @ts-ignore
          options[key] = rawOptions[key] || defaultParserOptions[key];
      }
      return {
          options,
          column: 1,
          line: 1,
          offset: 0,
          originalSource: content,
          source: content,
          inPre: false,
          inVPre: false
      };
  }
  function parseChildren(context, mode, ancestors) {
      const parent = last(ancestors);
      const ns = parent ? parent.ns : 0 /* HTML */;
      const nodes = [];
      while (!isEnd(context, mode, ancestors)) {
          const s = context.source;
          let node = undefined;
          if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {
              if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
                  // '{{'
                  node = parseInterpolation(context, mode);
              }
              else if (mode === 0 /* DATA */ && s[0] === '<') {
                  // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
                  if (s.length === 1) {
                      emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);
                  }
                  else if (s[1] === '!') {
                      // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
                      if (startsWith(s, '<!--')) {
                          node = parseComment(context);
                      }
                      else if (startsWith(s, '<!DOCTYPE')) {
                          // Ignore DOCTYPE by a limitation.
                          node = parseBogusComment(context);
                      }
                      else if (startsWith(s, '<![CDATA[')) {
                          if (ns !== 0 /* HTML */) {
                              node = parseCDATA(context, ancestors);
                          }
                          else {
                              emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);
                              node = parseBogusComment(context);
                          }
                      }
                      else {
                          emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);
                          node = parseBogusComment(context);
                      }
                  }
                  else if (s[1] === '/') {
                      // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
                      if (s.length === 2) {
                          emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);
                      }
                      else if (s[2] === '>') {
                          emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);
                          advanceBy(context, 3);
                          continue;
                      }
                      else if (/[a-z]/i.test(s[2])) {
                          emitError(context, 23 /* X_INVALID_END_TAG */);
                          parseTag(context, 1 /* End */, parent);
                          continue;
                      }
                      else {
                          emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);
                          node = parseBogusComment(context);
                      }
                  }
                  else if (/[a-z]/i.test(s[1])) {
                      node = parseElement(context, ancestors);
                  }
                  else if (s[1] === '?') {
                      emitError(context, 21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);
                      node = parseBogusComment(context);
                  }
                  else {
                      emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);
                  }
              }
          }
          if (!node) {
              node = parseText(context, mode);
          }
          if (isArray(node)) {
              for (let i = 0; i < node.length; i++) {
                  pushNode(nodes, node[i]);
              }
          }
          else {
              pushNode(nodes, node);
          }
      }
      // Whitespace management for more efficient output
      // (same as v2 whitespace: 'condense')
      let removedWhitespace = false;
      if (mode !== 2 /* RAWTEXT */) {
          if (!context.inPre) {
              for (let i = 0; i < nodes.length; i++) {
                  const node = nodes[i];
                  if (node.type === 2 /* TEXT */) {
                      if (!/[^\t\r\n\f ]/.test(node.content)) {
                          const prev = nodes[i - 1];
                          const next = nodes[i + 1];
                          // If:
                          // - the whitespace is the first or last node, or:
                          // - the whitespace is adjacent to a comment, or:
                          // - the whitespace is between two elements AND contains newline
                          // Then the whitespace is ignored.
                          if (!prev ||
                              !next ||
                              prev.type === 3 /* COMMENT */ ||
                              next.type === 3 /* COMMENT */ ||
                              (prev.type === 1 /* ELEMENT */ &&
                                  next.type === 1 /* ELEMENT */ &&
                                  /[\r\n]/.test(node.content))) {
                              removedWhitespace = true;
                              nodes[i] = null;
                          }
                          else {
                              // Otherwise, condensed consecutive whitespace inside the text
                              // down to a single space
                              node.content = ' ';
                          }
                      }
                      else {
                          node.content = node.content.replace(/[\t\r\n\f ]+/g, ' ');
                      }
                  }
              }
          }
          else if (parent && context.options.isPreTag(parent.tag)) {
              // remove leading newline per html spec
              // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
              const first = nodes[0];
              if (first && first.type === 2 /* TEXT */) {
                  first.content = first.content.replace(/^\r?\n/, '');
              }
          }
      }
      return removedWhitespace ? nodes.filter(Boolean) : nodes;
  }
  function pushNode(nodes, node) {
      if (node.type === 2 /* TEXT */) {
          const prev = last(nodes);
          // Merge if both this and the previous node are text and those are
          // consecutive. This happens for cases like "a < b".
          if (prev &&
              prev.type === 2 /* TEXT */ &&
              prev.loc.end.offset === node.loc.start.offset) {
              prev.content += node.content;
              prev.loc.end = node.loc.end;
              prev.loc.source += node.loc.source;
              return;
          }
      }
      nodes.push(node);
  }
  function parseCDATA(context, ancestors) {
      advanceBy(context, 9);
      const nodes = parseChildren(context, 3 /* CDATA */, ancestors);
      if (context.source.length === 0) {
          emitError(context, 6 /* EOF_IN_CDATA */);
      }
      else {
          advanceBy(context, 3);
      }
      return nodes;
  }
  function parseComment(context) {
      const start = getCursor(context);
      let content;
      // Regular comment.
      const match = /--(\!)?>/.exec(context.source);
      if (!match) {
          content = context.source.slice(4);
          advanceBy(context, context.source.length);
          emitError(context, 7 /* EOF_IN_COMMENT */);
      }
      else {
          if (match.index <= 3) {
              emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);
          }
          if (match[1]) {
              emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */);
          }
          content = context.source.slice(4, match.index);
          // Advancing with reporting nested comments.
          const s = context.source.slice(0, match.index);
          let prevIndex = 1, nestedIndex = 0;
          while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
              advanceBy(context, nestedIndex - prevIndex + 1);
              if (nestedIndex + 4 < s.length) {
                  emitError(context, 16 /* NESTED_COMMENT */);
              }
              prevIndex = nestedIndex + 1;
          }
          advanceBy(context, match.index + match[0].length - prevIndex + 1);
      }
      return {
          type: 3 /* COMMENT */,
          content,
          loc: getSelection(context, start)
      };
  }
  function parseBogusComment(context) {
      const start = getCursor(context);
      const contentStart = context.source[1] === '?' ? 1 : 2;
      let content;
      const closeIndex = context.source.indexOf('>');
      if (closeIndex === -1) {
          content = context.source.slice(contentStart);
          advanceBy(context, context.source.length);
      }
      else {
          content = context.source.slice(contentStart, closeIndex);
          advanceBy(context, closeIndex + 1);
      }
      return {
          type: 3 /* COMMENT */,
          content,
          loc: getSelection(context, start)
      };
  }
  function parseElement(context, ancestors) {
      // Start tag.
      const wasInPre = context.inPre;
      const wasInVPre = context.inVPre;
      const parent = last(ancestors);
      const element = parseTag(context, 0 /* Start */, parent);
      const isPreBoundary = context.inPre && !wasInPre;
      const isVPreBoundary = context.inVPre && !wasInVPre;
      if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
          return element;
      }
      // Children.
      ancestors.push(element);
      const mode = context.options.getTextMode(element, parent);
      const children = parseChildren(context, mode, ancestors);
      ancestors.pop();
      element.children = children;
      // End tag.
      if (startsWithEndTagOpen(context.source, element.tag)) {
          parseTag(context, 1 /* End */, parent);
      }
      else {
          emitError(context, 24 /* X_MISSING_END_TAG */, 0, element.loc.start);
          if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
              const first = children[0];
              if (first && startsWith(first.loc.source, '<!--')) {
                  emitError(context, 8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);
              }
          }
      }
      element.loc = getSelection(context, element.loc.start);
      if (isPreBoundary) {
          context.inPre = false;
      }
      if (isVPreBoundary) {
          context.inVPre = false;
      }
      return element;
  }
  const isSpecialTemplateDirective = /*#__PURE__*/ makeMap(`if,else,else-if,for,slot`);
  /**
   * Parse a tag (E.g. `<div id=a>`) with that type (start tag or end tag).
   */
  function parseTag(context, type, parent) {
      // Tag open.
      const start = getCursor(context);
      const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
      const tag = match[1];
      const ns = context.options.getNamespace(tag, parent);
      advanceBy(context, match[0].length);
      advanceSpaces(context);
      // save current state in case we need to re-parse attributes with v-pre
      const cursor = getCursor(context);
      const currentSource = context.source;
      // Attributes.
      let props = parseAttributes(context, type);
      // check <pre> tag
      if (context.options.isPreTag(tag)) {
          context.inPre = true;
      }
      // check v-pre
      if (!context.inVPre &&
          props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'pre')) {
          context.inVPre = true;
          // reset context
          extend(context, cursor);
          context.source = currentSource;
          // re-parse attrs and filter out v-pre itself
          props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');
      }
      // Tag close.
      let isSelfClosing = false;
      if (context.source.length === 0) {
          emitError(context, 9 /* EOF_IN_TAG */);
      }
      else {
          isSelfClosing = startsWith(context.source, '/>');
          if (type === 1 /* End */ && isSelfClosing) {
              emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);
          }
          advanceBy(context, isSelfClosing ? 2 : 1);
      }
      let tagType = 0 /* ELEMENT */;
      const options = context.options;
      if (!context.inVPre && !options.isCustomElement(tag)) {
          const hasVIs = props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'is');
          if (options.isNativeTag && !hasVIs) {
              if (!options.isNativeTag(tag))
                  tagType = 1 /* COMPONENT */;
          }
          else if (hasVIs ||
              isCoreComponent(tag) ||
              (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
              /^[A-Z]/.test(tag) ||
              tag === 'component') {
              tagType = 1 /* COMPONENT */;
          }
          if (tag === 'slot') {
              tagType = 2 /* SLOT */;
          }
          else if (tag === 'template' &&
              props.some(p => {
                  return (p.type === 7 /* DIRECTIVE */ && isSpecialTemplateDirective(p.name));
              })) {
              tagType = 3 /* TEMPLATE */;
          }
      }
      return {
          type: 1 /* ELEMENT */,
          ns,
          tag,
          tagType,
          props,
          isSelfClosing,
          children: [],
          loc: getSelection(context, start),
          codegenNode: undefined // to be created during transform phase
      };
  }
  function parseAttributes(context, type) {
      const props = [];
      const attributeNames = new Set();
      while (context.source.length > 0 &&
          !startsWith(context.source, '>') &&
          !startsWith(context.source, '/>')) {
          if (startsWith(context.source, '/')) {
              emitError(context, 22 /* UNEXPECTED_SOLIDUS_IN_TAG */);
              advanceBy(context, 1);
              advanceSpaces(context);
              continue;
          }
          if (type === 1 /* End */) {
              emitError(context, 3 /* END_TAG_WITH_ATTRIBUTES */);
          }
          const attr = parseAttribute(context, attributeNames);
          if (type === 0 /* Start */) {
              props.push(attr);
          }
          if (/^[^\t\r\n\f />]/.test(context.source)) {
              emitError(context, 15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);
          }
          advanceSpaces(context);
      }
      return props;
  }
  function parseAttribute(context, nameSet) {
      // Name.
      const start = getCursor(context);
      const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
      const name = match[0];
      if (nameSet.has(name)) {
          emitError(context, 2 /* DUPLICATE_ATTRIBUTE */);
      }
      nameSet.add(name);
      if (name[0] === '=') {
          emitError(context, 19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);
      }
      {
          const pattern = /["'<]/g;
          let m;
          while ((m = pattern.exec(name))) {
              emitError(context, 17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);
          }
      }
      advanceBy(context, name.length);
      // Value
      let value = undefined;
      if (/^[\t\r\n\f ]*=/.test(context.source)) {
          advanceSpaces(context);
          advanceBy(context, 1);
          advanceSpaces(context);
          value = parseAttributeValue(context);
          if (!value) {
              emitError(context, 13 /* MISSING_ATTRIBUTE_VALUE */);
          }
      }
      const loc = getSelection(context, start);
      if (!context.inVPre && /^(v-|:|@|#)/.test(name)) {
          const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
          const dirName = match[1] ||
              (startsWith(name, ':') ? 'bind' : startsWith(name, '@') ? 'on' : 'slot');
          let arg;
          if (match[2]) {
              const isSlot = dirName === 'slot';
              const startOffset = name.indexOf(match[2]);
              const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || '').length));
              let content = match[2];
              let isStatic = true;
              if (content.startsWith('[')) {
                  isStatic = false;
                  if (!content.endsWith(']')) {
                      emitError(context, 26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);
                  }
                  content = content.substr(1, content.length - 2);
              }
              else if (isSlot) {
                  // #1241 special case for v-slot: vuetify relies extensively on slot
                  // names containing dots. v-slot doesn't have any modifiers and Vue 2.x
                  // supports such usage so we are keeping it consistent with 2.x.
                  content += match[3] || '';
              }
              arg = {
                  type: 4 /* SIMPLE_EXPRESSION */,
                  content,
                  isStatic,
                  isConstant: isStatic,
                  loc
              };
          }
          if (value && value.isQuoted) {
              const valueLoc = value.loc;
              valueLoc.start.offset++;
              valueLoc.start.column++;
              valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
              valueLoc.source = valueLoc.source.slice(1, -1);
          }
          return {
              type: 7 /* DIRECTIVE */,
              name: dirName,
              exp: value && {
                  type: 4 /* SIMPLE_EXPRESSION */,
                  content: value.content,
                  isStatic: false,
                  // Treat as non-constant by default. This can be potentially set to
                  // true by `transformExpression` to make it eligible for hoisting.
                  isConstant: false,
                  loc: value.loc
              },
              arg,
              modifiers: match[3] ? match[3].substr(1).split('.') : [],
              loc
          };
      }
      return {
          type: 6 /* ATTRIBUTE */,
          name,
          value: value && {
              type: 2 /* TEXT */,
              content: value.content,
              loc: value.loc
          },
          loc
      };
  }
  function parseAttributeValue(context) {
      const start = getCursor(context);
      let content;
      const quote = context.source[0];
      const isQuoted = quote === `"` || quote === `'`;
      if (isQuoted) {
          // Quoted value.
          advanceBy(context, 1);
          const endIndex = context.source.indexOf(quote);
          if (endIndex === -1) {
              content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);
          }
          else {
              content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);
              advanceBy(context, 1);
          }
      }
      else {
          // Unquoted
          const match = /^[^\t\r\n\f >]+/.exec(context.source);
          if (!match) {
              return undefined;
          }
          const unexpectedChars = /["'<=`]/g;
          let m;
          while ((m = unexpectedChars.exec(match[0]))) {
              emitError(context, 18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);
          }
          content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);
      }
      return { content, isQuoted, loc: getSelection(context, start) };
  }
  function parseInterpolation(context, mode) {
      const [open, close] = context.options.delimiters;
      const closeIndex = context.source.indexOf(close, open.length);
      if (closeIndex === -1) {
          emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);
          return undefined;
      }
      const start = getCursor(context);
      advanceBy(context, open.length);
      const innerStart = getCursor(context);
      const innerEnd = getCursor(context);
      const rawContentLength = closeIndex - open.length;
      const rawContent = context.source.slice(0, rawContentLength);
      const preTrimContent = parseTextData(context, rawContentLength, mode);
      const content = preTrimContent.trim();
      const startOffset = preTrimContent.indexOf(content);
      if (startOffset > 0) {
          advancePositionWithMutation(innerStart, rawContent, startOffset);
      }
      const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
      advancePositionWithMutation(innerEnd, rawContent, endOffset);
      advanceBy(context, close.length);
      return {
          type: 5 /* INTERPOLATION */,
          content: {
              type: 4 /* SIMPLE_EXPRESSION */,
              isStatic: false,
              // Set `isConstant` to false by default and will decide in transformExpression
              isConstant: false,
              content,
              loc: getSelection(context, innerStart, innerEnd)
          },
          loc: getSelection(context, start)
      };
  }
  function parseText(context, mode) {
      const endTokens = ['<', context.options.delimiters[0]];
      if (mode === 3 /* CDATA */) {
          endTokens.push(']]>');
      }
      let endIndex = context.source.length;
      for (let i = 0; i < endTokens.length; i++) {
          const index = context.source.indexOf(endTokens[i], 1);
          if (index !== -1 && endIndex > index) {
              endIndex = index;
          }
      }
      const start = getCursor(context);
      const content = parseTextData(context, endIndex, mode);
      return {
          type: 2 /* TEXT */,
          content,
          loc: getSelection(context, start)
      };
  }
  /**
   * Get text data with a given length from the current location.
   * This translates HTML entities in the text data.
   */
  function parseTextData(context, length, mode) {
      const rawText = context.source.slice(0, length);
      advanceBy(context, length);
      if (mode === 2 /* RAWTEXT */ ||
          mode === 3 /* CDATA */ ||
          rawText.indexOf('&') === -1) {
          return rawText;
      }
      else {
          // DATA or RCDATA containing "&"". Entity decoding required.
          return context.options.decodeEntities(rawText, mode === 4 /* ATTRIBUTE_VALUE */);
      }
  }
  function getCursor(context) {
      const { column, line, offset } = context;
      return { column, line, offset };
  }
  function getSelection(context, start, end) {
      end = end || getCursor(context);
      return {
          start,
          end,
          source: context.originalSource.slice(start.offset, end.offset)
      };
  }
  function last(xs) {
      return xs[xs.length - 1];
  }
  function startsWith(source, searchString) {
      return source.startsWith(searchString);
  }
  function advanceBy(context, numberOfCharacters) {
      const { source } = context;
      advancePositionWithMutation(context, source, numberOfCharacters);
      context.source = source.slice(numberOfCharacters);
  }
  function advanceSpaces(context) {
      const match = /^[\t\r\n\f ]+/.exec(context.source);
      if (match) {
          advanceBy(context, match[0].length);
      }
  }
  function getNewPosition(context, start, numberOfCharacters) {
      return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
  }
  function emitError(context, code, offset, loc = getCursor(context)) {
      if (offset) {
          loc.offset += offset;
          loc.column += offset;
      }
      context.options.onError(createCompilerError(code, {
          start: loc,
          end: loc,
          source: ''
      }));
  }
  function isEnd(context, mode, ancestors) {
      const s = context.source;
      switch (mode) {
          case 0 /* DATA */:
              if (startsWith(s, '</')) {
                  //TODO: probably bad performance
                  for (let i = ancestors.length - 1; i >= 0; --i) {
                      if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                          return true;
                      }
                  }
              }
              break;
          case 1 /* RCDATA */:
          case 2 /* RAWTEXT */: {
              const parent = last(ancestors);
              if (parent && startsWithEndTagOpen(s, parent.tag)) {
                  return true;
              }
              break;
          }
          case 3 /* CDATA */:
              if (startsWith(s, ']]>')) {
                  return true;
              }
              break;
      }
      return !s;
  }
  function startsWithEndTagOpen(source, tag) {
      return (startsWith(source, '</') &&
          source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() &&
          /[\t\r\n\f />]/.test(source[2 + tag.length] || '>'));
  }

  function hoistStatic(root, context) {
      walk(root, context, new Map(), 
      // Root node is unfortunately non-hoistable due to potential parent
      // fallthrough attributes.
      isSingleElementRoot(root, root.children[0]));
  }
  function isSingleElementRoot(root, child) {
      const { children } = root;
      return (children.length === 1 &&
          child.type === 1 /* ELEMENT */ &&
          !isSlotOutlet(child));
  }
  function walk(node, context, resultCache, doNotHoistNode = false) {
      let hasHoistedNode = false;
      // Some transforms, e.g. transformAssetUrls from @vue/compiler-sfc, replaces
      // static bindings with expressions. These expressions are guaranteed to be
      // constant so they are still eligible for hoisting, but they are only
      // available at runtime and therefore cannot be evaluated ahead of time.
      // This is only a concern for pre-stringification (via transformHoist by
      // @vue/compiler-dom), but doing it here allows us to perform only one full
      // walk of the AST and allow `stringifyStatic` to stop walking as soon as its
      // stringficiation threshold is met.
      let hasRuntimeConstant = false;
      const { children } = node;
      for (let i = 0; i < children.length; i++) {
          const child = children[i];
          // only plain elements & text calls are eligible for hoisting.
          if (child.type === 1 /* ELEMENT */ &&
              child.tagType === 0 /* ELEMENT */) {
              let staticType;
              if (!doNotHoistNode &&
                  (staticType = getStaticType(child, resultCache)) > 0) {
                  if (staticType === 2 /* HAS_RUNTIME_CONSTANT */) {
                      hasRuntimeConstant = true;
                  }
                  child.codegenNode.patchFlag =
                      -1 /* HOISTED */ + ( ` /* HOISTED */` );
                  child.codegenNode = context.hoist(child.codegenNode);
                  hasHoistedNode = true;
                  continue;
              }
              else {
                  // node may contain dynamic children, but its props may be eligible for
                  // hoisting.
                  const codegenNode = child.codegenNode;
                  if (codegenNode.type === 13 /* VNODE_CALL */) {
                      const flag = getPatchFlag(codegenNode);
                      if ((!flag ||
                          flag === 512 /* NEED_PATCH */ ||
                          flag === 1 /* TEXT */) &&
                          !hasNonHoistableProps(child)) {
                          const props = getNodeProps(child);
                          if (props) {
                              codegenNode.props = context.hoist(props);
                          }
                      }
                  }
              }
          }
          else if (child.type === 12 /* TEXT_CALL */) {
              const staticType = getStaticType(child.content, resultCache);
              if (staticType > 0) {
                  if (staticType === 2 /* HAS_RUNTIME_CONSTANT */) {
                      hasRuntimeConstant = true;
                  }
                  child.codegenNode = context.hoist(child.codegenNode);
                  hasHoistedNode = true;
              }
          }
          // walk further
          if (child.type === 1 /* ELEMENT */) {
              walk(child, context, resultCache);
          }
          else if (child.type === 11 /* FOR */) {
              // Do not hoist v-for single child because it has to be a block
              walk(child, context, resultCache, child.children.length === 1);
          }
          else if (child.type === 9 /* IF */) {
              for (let i = 0; i < child.branches.length; i++) {
                  // Do not hoist v-if single child because it has to be a block
                  walk(child.branches[i], context, resultCache, child.branches[i].children.length === 1);
              }
          }
      }
      if (!hasRuntimeConstant && hasHoistedNode && context.transformHoist) {
          context.transformHoist(children, context, node);
      }
  }
  function getStaticType(node, resultCache = new Map()) {
      switch (node.type) {
          case 1 /* ELEMENT */:
              if (node.tagType !== 0 /* ELEMENT */) {
                  return 0 /* NOT_STATIC */;
              }
              const cached = resultCache.get(node);
              if (cached !== undefined) {
                  return cached;
              }
              const codegenNode = node.codegenNode;
              if (codegenNode.type !== 13 /* VNODE_CALL */) {
                  return 0 /* NOT_STATIC */;
              }
              const flag = getPatchFlag(codegenNode);
              if (!flag && !hasNonHoistableProps(node)) {
                  // element self is static. check its children.
                  let returnType = 1 /* FULL_STATIC */;
                  for (let i = 0; i < node.children.length; i++) {
                      const childType = getStaticType(node.children[i], resultCache);
                      if (childType === 0 /* NOT_STATIC */) {
                          resultCache.set(node, 0 /* NOT_STATIC */);
                          return 0 /* NOT_STATIC */;
                      }
                      else if (childType === 2 /* HAS_RUNTIME_CONSTANT */) {
                          returnType = 2 /* HAS_RUNTIME_CONSTANT */;
                      }
                  }
                  // check if any of the props contain runtime constants
                  if (returnType !== 2 /* HAS_RUNTIME_CONSTANT */) {
                      for (let i = 0; i < node.props.length; i++) {
                          const p = node.props[i];
                          if (p.type === 7 /* DIRECTIVE */ &&
                              p.name === 'bind' &&
                              p.exp &&
                              (p.exp.type === 8 /* COMPOUND_EXPRESSION */ ||
                                  p.exp.isRuntimeConstant)) {
                              returnType = 2 /* HAS_RUNTIME_CONSTANT */;
                          }
                      }
                  }
                  // only svg/foreignObject could be block here, however if they are
                  // stati then they don't need to be blocks since there will be no
                  // nested updates.
                  if (codegenNode.isBlock) {
                      codegenNode.isBlock = false;
                  }
                  resultCache.set(node, returnType);
                  return returnType;
              }
              else {
                  resultCache.set(node, 0 /* NOT_STATIC */);
                  return 0 /* NOT_STATIC */;
              }
          case 2 /* TEXT */:
          case 3 /* COMMENT */:
              return 1 /* FULL_STATIC */;
          case 9 /* IF */:
          case 11 /* FOR */:
          case 10 /* IF_BRANCH */:
              return 0 /* NOT_STATIC */;
          case 5 /* INTERPOLATION */:
          case 12 /* TEXT_CALL */:
              return getStaticType(node.content, resultCache);
          case 4 /* SIMPLE_EXPRESSION */:
              return node.isConstant
                  ? node.isRuntimeConstant
                      ? 2 /* HAS_RUNTIME_CONSTANT */
                      : 1 /* FULL_STATIC */
                  : 0 /* NOT_STATIC */;
          case 8 /* COMPOUND_EXPRESSION */:
              let returnType = 1 /* FULL_STATIC */;
              for (let i = 0; i < node.children.length; i++) {
                  const child = node.children[i];
                  if (isString(child) || isSymbol(child)) {
                      continue;
                  }
                  const childType = getStaticType(child, resultCache);
                  if (childType === 0 /* NOT_STATIC */) {
                      return 0 /* NOT_STATIC */;
                  }
                  else if (childType === 2 /* HAS_RUNTIME_CONSTANT */) {
                      returnType = 2 /* HAS_RUNTIME_CONSTANT */;
                  }
              }
              return returnType;
          default:
              return 0 /* NOT_STATIC */;
      }
  }
  /**
   * Even for a node with no patch flag, it is possible for it to contain
   * non-hoistable expressions that refers to scope variables, e.g. compiler
   * injected keys or cached event handlers. Therefore we need to always check the
   * codegenNode's props to be sure.
   */
  function hasNonHoistableProps(node) {
      const props = getNodeProps(node);
      if (props && props.type === 15 /* JS_OBJECT_EXPRESSION */) {
          const { properties } = props;
          for (let i = 0; i < properties.length; i++) {
              const { key, value } = properties[i];
              if (key.type !== 4 /* SIMPLE_EXPRESSION */ ||
                  !key.isStatic ||
                  (value.type !== 4 /* SIMPLE_EXPRESSION */ ||
                      (!value.isStatic && !value.isConstant))) {
                  return true;
              }
          }
      }
      return false;
  }
  function getNodeProps(node) {
      const codegenNode = node.codegenNode;
      if (codegenNode.type === 13 /* VNODE_CALL */) {
          return codegenNode.props;
      }
  }
  function getPatchFlag(node) {
      const flag = node.patchFlag;
      return flag ? parseInt(flag, 10) : undefined;
  }

  function createTransformContext(root, { prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, ssr = false, ssrCssVars = ``, bindingMetadata = {}, onError = defaultOnError }) {
      const context = {
          // options
          prefixIdentifiers,
          hoistStatic,
          cacheHandlers,
          nodeTransforms,
          directiveTransforms,
          transformHoist,
          isBuiltInComponent,
          isCustomElement,
          expressionPlugins,
          scopeId,
          ssr,
          ssrCssVars,
          bindingMetadata,
          onError,
          // state
          root,
          helpers: new Set(),
          components: new Set(),
          directives: new Set(),
          hoists: [],
          imports: new Set(),
          temps: 0,
          cached: 0,
          identifiers: Object.create(null),
          scopes: {
              vFor: 0,
              vSlot: 0,
              vPre: 0,
              vOnce: 0
          },
          parent: null,
          currentNode: root,
          childIndex: 0,
          // methods
          helper(name) {
              context.helpers.add(name);
              return name;
          },
          helperString(name) {
              return `_${helperNameMap[context.helper(name)]}`;
          },
          replaceNode(node) {
              /* istanbul ignore if */
              {
                  if (!context.currentNode) {
                      throw new Error(`Node being replaced is already removed.`);
                  }
                  if (!context.parent) {
                      throw new Error(`Cannot replace root node.`);
                  }
              }
              context.parent.children[context.childIndex] = context.currentNode = node;
          },
          removeNode(node) {
              if ( !context.parent) {
                  throw new Error(`Cannot remove root node.`);
              }
              const list = context.parent.children;
              const removalIndex = node
                  ? list.indexOf(node)
                  : context.currentNode
                      ? context.childIndex
                      : -1;
              /* istanbul ignore if */
              if ( removalIndex < 0) {
                  throw new Error(`node being removed is not a child of current parent`);
              }
              if (!node || node === context.currentNode) {
                  // current node removed
                  context.currentNode = null;
                  context.onNodeRemoved();
              }
              else {
                  // sibling node removed
                  if (context.childIndex > removalIndex) {
                      context.childIndex--;
                      context.onNodeRemoved();
                  }
              }
              context.parent.children.splice(removalIndex, 1);
          },
          onNodeRemoved: () => { },
          addIdentifiers(exp) {
              // identifier tracking only happens in non-browser builds.
              {
                  if (isString(exp)) {
                      addId(exp);
                  }
                  else if (exp.identifiers) {
                      exp.identifiers.forEach(addId);
                  }
                  else if (exp.type === 4 /* SIMPLE_EXPRESSION */) {
                      addId(exp.content);
                  }
              }
          },
          removeIdentifiers(exp) {
              {
                  if (isString(exp)) {
                      removeId(exp);
                  }
                  else if (exp.identifiers) {
                      exp.identifiers.forEach(removeId);
                  }
                  else if (exp.type === 4 /* SIMPLE_EXPRESSION */) {
                      removeId(exp.content);
                  }
              }
          },
          hoist(exp) {
              context.hoists.push(exp);
              const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, true);
              identifier.hoisted = exp;
              return identifier;
          },
          cache(exp, isVNode = false) {
              return createCacheExpression(++context.cached, exp, isVNode);
          }
      };
      function addId(id) {
          const { identifiers } = context;
          if (identifiers[id] === undefined) {
              identifiers[id] = 0;
          }
          identifiers[id]++;
      }
      function removeId(id) {
          context.identifiers[id]--;
      }
      return context;
  }
  function transform(root, options) {
      const context = createTransformContext(root, options);
      traverseNode(root, context);
      if (options.hoistStatic) {
          hoistStatic(root, context);
      }
      if (!options.ssr) {
          createRootCodegen(root, context);
      }
      // finalize meta information
      root.helpers = [...context.helpers];
      root.components = [...context.components];
      root.directives = [...context.directives];
      root.imports = [...context.imports];
      root.hoists = context.hoists;
      root.temps = context.temps;
      root.cached = context.cached;
  }
  function createRootCodegen(root, context) {
      const { helper } = context;
      const { children } = root;
      if (children.length === 1) {
          const child = children[0];
          // if the single child is an element, turn it into a block.
          if (isSingleElementRoot(root, child) && child.codegenNode) {
              // single element root is never hoisted so codegenNode will never be
              // SimpleExpressionNode
              const codegenNode = child.codegenNode;
              if (codegenNode.type === 13 /* VNODE_CALL */) {
                  codegenNode.isBlock = true;
                  helper(OPEN_BLOCK);
                  helper(CREATE_BLOCK);
              }
              root.codegenNode = codegenNode;
          }
          else {
              // - single <slot/>, IfNode, ForNode: already blocks.
              // - single text node: always patched.
              // root codegen falls through via genNode()
              root.codegenNode = child;
          }
      }
      else if (children.length > 1) {
          // root has multiple nodes - return a fragment block.
          root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, `${64 /* STABLE_FRAGMENT */} /* ${PatchFlagNames[64 /* STABLE_FRAGMENT */]} */`, undefined, undefined, true);
      }
      else ;
  }
  function traverseChildren(parent, context) {
      let i = 0;
      const nodeRemoved = () => {
          i--;
      };
      for (; i < parent.children.length; i++) {
          const child = parent.children[i];
          if (isString(child))
              continue;
          context.parent = parent;
          context.childIndex = i;
          context.onNodeRemoved = nodeRemoved;
          traverseNode(child, context);
      }
  }
  function traverseNode(node, context) {
      context.currentNode = node;
      // apply transform plugins
      const { nodeTransforms } = context;
      const exitFns = [];
      for (let i = 0; i < nodeTransforms.length; i++) {
          const onExit = nodeTransforms[i](node, context);
          if (onExit) {
              if (isArray(onExit)) {
                  exitFns.push(...onExit);
              }
              else {
                  exitFns.push(onExit);
              }
          }
          if (!context.currentNode) {
              // node was removed
              return;
          }
          else {
              // node may have been replaced
              node = context.currentNode;
          }
      }
      switch (node.type) {
          case 3 /* COMMENT */:
              if (!context.ssr) {
                  // inject import for the Comment symbol, which is needed for creating
                  // comment nodes with `createVNode`
                  context.helper(CREATE_COMMENT);
              }
              break;
          case 5 /* INTERPOLATION */:
              // no need to traverse, but we need to inject toString helper
              if (!context.ssr) {
                  context.helper(TO_DISPLAY_STRING);
              }
              break;
          // for container types, further traverse downwards
          case 9 /* IF */:
              for (let i = 0; i < node.branches.length; i++) {
                  traverseNode(node.branches[i], context);
              }
              break;
          case 10 /* IF_BRANCH */:
          case 11 /* FOR */:
          case 1 /* ELEMENT */:
          case 0 /* ROOT */:
              traverseChildren(node, context);
              break;
      }
      // exit transforms
      context.currentNode = node;
      let i = exitFns.length;
      while (i--) {
          exitFns[i]();
      }
  }
  function createStructuralDirectiveTransform(name, fn) {
      const matches = isString(name)
          ? (n) => n === name
          : (n) => name.test(n);
      return (node, context) => {
          if (node.type === 1 /* ELEMENT */) {
              const { props } = node;
              // structural directive transforms are not concerned with slots
              // as they are handled separately in vSlot.ts
              if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {
                  return;
              }
              const exitFns = [];
              for (let i = 0; i < props.length; i++) {
                  const prop = props[i];
                  if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {
                      // structural directives are removed to avoid infinite recursion
                      // also we remove them *before* applying so that it can further
                      // traverse itself in case it moves the node around
                      props.splice(i, 1);
                      i--;
                      const onExit = fn(node, prop, context);
                      if (onExit)
                          exitFns.push(onExit);
                  }
              }
              return exitFns;
          }
      };
  }

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  var encode = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };

  /**
   * Decode a single base 64 character code digit to an integer. Returns -1 on
   * failure.
   */
  var decode = function (charCode) {
    var bigA = 65;     // 'A'
    var bigZ = 90;     // 'Z'

    var littleA = 97;  // 'a'
    var littleZ = 122; // 'z'

    var zero = 48;     // '0'
    var nine = 57;     // '9'

    var plus = 43;     // '+'
    var slash = 47;    // '/'

    var littleOffset = 26;
    var numberOffset = 52;

    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
      return (charCode - bigA);
    }

    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
      return (charCode - littleA + littleOffset);
    }

    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
      return (charCode - zero + numberOffset);
    }

    // 62: +
    if (charCode == plus) {
      return 62;
    }

    // 63: /
    if (charCode == slash) {
      return 63;
    }

    // Invalid base64 digit.
    return -1;
  };

  var base64 = {
  	encode: encode,
  	decode: decode
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   *
   * Based on the Base 64 VLQ implementation in Closure Compiler:
   * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
   *
   * Copyright 2011 The Closure Compiler Authors. All rights reserved.
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   *  * Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   *  * Redistributions in binary form must reproduce the above
   *    copyright notice, this list of conditions and the following
   *    disclaimer in the documentation and/or other materials provided
   *    with the distribution.
   *  * Neither the name of Google Inc. nor the names of its
   *    contributors may be used to endorse or promote products derived
   *    from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */



  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  var encode$1 = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }

      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };

  var base64Vlq = {
  	encode: encode$1,
  	decode: decode$1
  };

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  	  path: basedir,
  	  exports: {},
  	  require: function (path, base) {
        return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
      }
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var util = createCommonjsModule(function (module, exports) {
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consecutive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  exports.isAbsolute = function (aPath) {
    return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
  };

  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');

    // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.
    var level = 0;
    while (aPath.indexOf(aRoot + '/') !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }

      // If the only part of the root that is left is the scheme (i.e. http://,
      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
      // have exhausted all components, so the path is not relative to the root.
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }

      ++level;
    }

    // Make sure we add a "../" for each component we removed from the root.
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports.relative = relative;

  var supportsNullProto = (function () {
    var obj = Object.create(null);
    return !('__proto__' in obj);
  }());

  function identity (s) {
    return s;
  }

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return '$' + aStr;
    }

    return aStr;
  }
  exports.toSetString = supportsNullProto ? identity : toSetString;

  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }

    return aStr;
  }
  exports.fromSetString = supportsNullProto ? identity : fromSetString;

  function isProtoString(s) {
    if (!s) {
      return false;
    }

    var length = s.length;

    if (length < 9 /* "__proto__".length */) {
      return false;
    }

    if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
        s.charCodeAt(length - 2) !== 95  /* '_' */ ||
        s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
        s.charCodeAt(length - 4) !== 116 /* 't' */ ||
        s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
        s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
        s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
        s.charCodeAt(length - 8) !== 95  /* '_' */ ||
        s.charCodeAt(length - 9) !== 95  /* '_' */) {
      return false;
    }

    for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36 /* '$' */) {
        return false;
      }
    }

    return true;
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings with deflated source and name indices where
   * the generated positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }

    if (aStr1 === null) {
      return 1; // aStr2 !== null
    }

    if (aStr2 === null) {
      return -1; // aStr1 !== null
    }

    if (aStr1 > aStr2) {
      return 1;
    }

    return -1;
  }

  /**
   * Comparator between two mappings with inflated source and name strings where
   * the generated positions are compared.
   */
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

  /**
   * Strip any JSON XSSI avoidance prefix from the string (as documented
   * in the source maps specification), and then parse the string as
   * JSON.
   */
  function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
  }
  exports.parseSourceMapInput = parseSourceMapInput;

  /**
   * Compute the URL of a source given the the source root, the source's
   * URL, and the source map's URL.
   */
  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || '';

    if (sourceRoot) {
      // This follows what Chrome does.
      if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
        sourceRoot += '/';
      }
      // The spec says:
      //   Line 4: An optional source root, useful for relocating source
      //   files on a server or removing repeated values in the
      //   “sources” entry.  This value is prepended to the individual
      //   entries in the “source” field.
      sourceURL = sourceRoot + sourceURL;
    }

    // Historically, SourceMapConsumer did not take the sourceMapURL as
    // a parameter.  This mode is still somewhat supported, which is why
    // this code block is conditional.  However, it's preferable to pass
    // the source map URL to SourceMapConsumer, so that this function
    // can implement the source URL resolution algorithm as outlined in
    // the spec.  This block is basically the equivalent of:
    //    new URL(sourceURL, sourceMapURL).toString()
    // ... except it avoids using URL, which wasn't available in the
    // older releases of node still supported by this library.
    //
    // The spec says:
    //   If the sources are not absolute URLs after prepending of the
    //   “sourceRoot”, the sources are resolved relative to the
    //   SourceMap (like resolving script src in a html document).
    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        // Strip the last path component, but keep the "/".
        var index = parsed.path.lastIndexOf('/');
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join(urlGenerate(parsed), sourceURL);
    }

    return normalize(sourceURL);
  }
  exports.computeSourceURL = computeSourceURL;
  });

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */


  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Return how many unique items are in this ArraySet. If duplicates have been
   * added, than those do not count towards the size.
   *
   * @returns Number
   */
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
          return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }

    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  var ArraySet_1 = ArraySet;

  var arraySet = {
  	ArraySet: ArraySet_1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2014 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */



  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA ||
           util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }

  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {generatedLine: -1, generatedColumn: 0};
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  MappingList.prototype.unsortedForEach =
    function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };

  var MappingList_1 = MappingList;

  var mappingList = {
  	MappingList: MappingList_1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */



  var ArraySet$1 = arraySet.ArraySet;
  var MappingList$1 = mappingList.MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet$1();
    this._names = new ArraySet$1();
    this._mappings = new MappingList$1();
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }

        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }

        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }

      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }

      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }

      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "sourceFile" relative if an absolute Url is passed.
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet$1();
      var newNames = new ArraySet$1();

      // Find mappings for the "sourceFile"
      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      // When aOriginal is truthy but has empty values for .line and .column,
      // it is most likely a programmer error. In this case we throw a very
      // specific error message to try to guide them the right way.
      // For example: https://github.com/Polymer/polymer-bundler/pull/519
      if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
          throw new Error(
              'original.line and original.column are not numbers -- you probably meant to omit ' +
              'the original mapping entirely and only map the generated position. If so, pass ' +
              'null for the original mapping instead of an object with empty or null values.'
          );
      }

      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;

      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = '';

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ',';
          }
        }

        next += base64Vlq.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64Vlq.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;

          // lines are stored 0-based in SourceMap spec version 3
          next += base64Vlq.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          next += base64Vlq.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64Vlq.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }

        result += next;
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };

  var SourceMapGenerator_1 = SourceMapGenerator;

  var sourceMapGenerator = {
  	SourceMapGenerator: SourceMapGenerator_1
  };

  var binarySearch = createCommonjsModule(function (module, exports) {
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next-closest element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element than the one we are searching for, so we return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    }
    else if (cmp > 0) {
      // Our needle is greater than aHaystack[mid].
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }

      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    }
    else {
      // Our needle is less than aHaystack[mid].
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }

      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the index of the closest element if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }

    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }

    // We have found either the exact element, or the next-closest element than
    // the one we are searching for. However, there may be more than one such
    // element. Make sure we always return the smallest of these.
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }

    return index;
  };
  });

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  // It turns out that some (most?) JavaScript engines don't self-host
  // `Array.prototype.sort`. This makes sense because C++ will likely remain
  // faster than JS when doing raw CPU-intensive sorting. However, when using a
  // custom comparator function, calling back and forth between the VM's C++ and
  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
  // worse generated code for the comparator function than would be optimal. In
  // fact, when sorting with a comparator, these costs outweigh the benefits of
  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
  // a ~3500ms mean speed-up in `bench/bench.html`.

  /**
   * Swap the elements indexed by `x` and `y` in the array `ary`.
   *
   * @param {Array} ary
   *        The array.
   * @param {Number} x
   *        The index of the first item.
   * @param {Number} y
   *        The index of the second item.
   */
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }

  /**
   * Returns a random integer within the range `low .. high` inclusive.
   *
   * @param {Number} low
   *        The lower bound on the range.
   * @param {Number} high
   *        The upper bound on the range.
   */
  function randomIntInRange(low, high) {
    return Math.round(low + (Math.random() * (high - low)));
  }

  /**
   * The Quick Sort algorithm.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   * @param {Number} p
   *        Start index of the array
   * @param {Number} r
   *        End index of the array
   */
  function doQuickSort(ary, comparator, p, r) {
    // If our lower bound is less than our upper bound, we (1) partition the
    // array into two pieces and (2) recurse on each half. If it is not, this is
    // the empty array and our base case.

    if (p < r) {
      // (1) Partitioning.
      //
      // The partitioning chooses a pivot between `p` and `r` and moves all
      // elements that are less than or equal to the pivot to the before it, and
      // all the elements that are greater than it after it. The effect is that
      // once partition is done, the pivot is in the exact place it will be when
      // the array is put in sorted order, and it will not need to be moved
      // again. This runs in O(n) time.

      // Always choose a random pivot so that an input array which is reverse
      // sorted does not cause O(n^2) running time.
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;

      swap(ary, pivotIndex, r);
      var pivot = ary[r];

      // Immediately after `j` is incremented in this loop, the following hold
      // true:
      //
      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
      //
      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }

      swap(ary, i + 1, j);
      var q = i + 1;

      // (2) Recurse on each half.

      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }

  /**
   * Sort the given array in-place with the given comparator function.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   */
  var quickSort_1 = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };

  var quickSort = {
  	quickSort: quickSort_1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */



  var ArraySet$2 = arraySet.ArraySet;

  var quickSort$1 = quickSort.quickSort;

  function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }

    return sourceMap.sections != null
      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  }

  SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    configurable: true,
    enumerable: true,
    get: function () {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    configurable: true,
    enumerable: true,
    get: function () {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._charIsMappingSeparator =
    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };

  /**
   * Returns all generated line and column information for the original source,
   * line, and column provided. If no column is provided, returns all mappings
   * corresponding to a either the line we are searching for or the next
   * closest line that has any mappings. Otherwise, returns all mappings
   * corresponding to the given line and either the column we are searching for
   * or the next closest column that has any offsets.
   *
   * The only argument is an object with the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number is 1-based.
   *   - column: Optional. the column number in the original source.
   *    The column number is 0-based.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *    line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *    The column number is 0-based.
   */
  SourceMapConsumer.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, 'line');

      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
      // returns the index of the closest mapping less than the needle. By
      // setting needle.originalColumn to 0, we thus find the last mapping for
      // the given line, provided such a mapping exists.
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: line,
        originalColumn: util.getArg(aArgs, 'column', 0)
      };

      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }

      var mappings = [];

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions,
                                    binarySearch.LEAST_UPPER_BOUND);
      if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (aArgs.column === undefined) {
          var originalLine = mapping.originalLine;

          // Iterate until either we run out of mappings, or we run into
          // a mapping for a different line than the one we found. Since
          // mappings are sorted, this is guaranteed to find all mappings for
          // the line we found.
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            });

            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;

          // Iterate until either we run out of mappings, or we run into
          // a mapping for a different line than the one we were searching for.
          // Since mappings are sorted, this is guaranteed to find all mappings for
          // the line we are searching for.
          while (mapping &&
                 mapping.originalLine === line &&
                 mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            });

            mapping = this._originalMappings[++index];
          }
        }
      }

      return mappings;
    };

  var SourceMapConsumer_1 = SourceMapConsumer;

  /**
   * A BasicSourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The first parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * The second parameter, if given, is a string whose value is the URL
   * at which the source map was found.  This URL is used to compute the
   * sources array.
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    if (sourceRoot) {
      sourceRoot = util.normalize(sourceRoot);
    }

    sources = sources
      .map(String)
      // Some source maps produce relative source paths like "./foo.js" instead of
      // "foo.js".  Normalize these first so that future comparisons will succeed.
      // See bugzil.la/1090768.
      .map(util.normalize)
      // Always ensure that absolute sources are internally stored relative to
      // the source root, if the source root is absolute. Not doing this would
      // be particularly problematic when the source root is a prefix of the
      // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
      .map(function (source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
          ? util.relative(sourceRoot, source)
          : source;
      });

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet$2.fromArray(names.map(String), true);
    this._sources = ArraySet$2.fromArray(sources, true);

    this._absoluteSources = this._sources.toArray().map(function (s) {
      return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
  }

  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

  /**
   * Utility function to find the index of a source.  Returns -1 if not
   * found.
   */
  BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }

    // Maybe aSource is an absolute URL as returned by |sources|.  In
    // this case we can't simply undo the transform.
    var i;
    for (i = 0; i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }

    return -1;
  };

  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @param String aSourceMapURL
   *        The URL at which the source map can be found (optional)
   * @returns BasicSourceMapConsumer
   */
  BasicSourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);

      var names = smc._names = ArraySet$2.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet$2.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function (s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });

      // Because we are modifying the entries (by converting string sources and
      // names to indices into the sources and names ArraySets), we have to make
      // a copy of the entry or else bad things happen. Shared mutable state
      // strikes again! See github issue #191.

      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];

      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping;
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;

        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;

          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }

          destOriginalMappings.push(destMapping);
        }

        destGeneratedMappings.push(destMapping);
      }

      quickSort$1(smc.__originalMappings, util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  BasicSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._absoluteSources.slice();
    }
  });

  /**
   * Provide the JIT with a nice shape / hidden class.
   */
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  BasicSourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;

      while (index < length) {
        if (aStr.charAt(index) === ';') {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        }
        else if (aStr.charAt(index) === ',') {
          index++;
        }
        else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;

          // Because each offset is encoded relative to the previous one,
          // many segments often have the same encoding. We can exploit this
          // fact by caching the parsed variable length fields of each segment,
          // allowing us to avoid a second parse if we encounter the same
          // segment again.
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);

          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64Vlq.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }

            if (segment.length === 2) {
              throw new Error('Found a source, but no line and column');
            }

            if (segment.length === 3) {
              throw new Error('Found a source and line, but no column');
            }

            cachedSegments[str] = segment;
          }

          // Generated column.
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;

          if (segment.length > 1) {
            // Original source.
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];

            // Original line.
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;

            // Original column.
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;

            if (segment.length > 4) {
              // Original name.
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }

          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            originalMappings.push(mapping);
          }
        }
      }

      quickSort$1(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;

      quickSort$1(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  BasicSourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator, aBias) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  BasicSourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];

          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }

        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
      }
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  BasicSourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
      );

      if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, 'source', null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, 'name', null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source: source,
            line: util.getArg(mapping, 'originalLine', null),
            column: util.getArg(mapping, 'originalColumn', null),
            name: name
          };
        }
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
    function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() &&
        !this.sourcesContent.some(function (sc) { return sc == null; });
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  BasicSourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }

      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }

      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }

      var url;
      if (this.sourceRoot != null
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }

      // This function is used recursively from
      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
      // don't want to throw if we can't find the source - we just want to
      // return null, so we provide a flag to exit gracefully.
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  BasicSourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, 'source');
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }

      var needle = {
        source: source,
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
      );

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          };
        }
      }

      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };

  var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

  /**
   * An IndexedSourceMapConsumer instance represents a parsed source map which
   * we can query for information. It differs from BasicSourceMapConsumer in
   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
   * input.
   *
   * The first parameter is a raw source map (either as a JSON string, or already
   * parsed to an object). According to the spec for indexed source maps, they
   * have the following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - file: Optional. The generated file this source map is associated with.
   *   - sections: A list of section definitions.
   *
   * Each value under the "sections" field has two fields:
   *   - offset: The offset into the original specified at which this section
   *       begins to apply, defined as an object with a "line" and "column"
   *       field.
   *   - map: A source map definition. This source map could also be indexed,
   *       but doesn't have to be.
   *
   * Instead of the "map" field, it's also possible to have a "url" field
   * specifying a URL to retrieve a source map from, but that's currently
   * unsupported.
   *
   * Here's an example source map, taken from the source map spec[0], but
   * modified to omit a section which uses the "url" field.
   *
   *  {
   *    version : 3,
   *    file: "app.js",
   *    sections: [{
   *      offset: {line:100, column:10},
   *      map: {
   *        version : 3,
   *        file: "section.js",
   *        sources: ["foo.js", "bar.js"],
   *        names: ["src", "maps", "are", "fun"],
   *        mappings: "AAAA,E;;ABCDE;"
   *      }
   *    }],
   *  }
   *
   * The second parameter, if given, is a string whose value is the URL
   * at which the source map was found.  This URL is used to compute the
   * sources array.
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
   */
  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }

    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    this._sources = new ArraySet$2();
    this._names = new ArraySet$2();

    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        // The url field will require support for asynchronicity.
        // See https://github.com/mozilla/source-map/issues/16
        throw new Error('Support for url field in sections not implemented.');
      }
      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');

      if (offsetLine < lastOffset.line ||
          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }
      lastOffset = offset;

      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
      }
    });
  }

  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

  /**
   * The version of the source mapping spec that we are consuming.
   */
  IndexedSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function () {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    }
  });

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  IndexedSourceMapConsumer.prototype.originalPositionFor =
    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      // Find the section containing the generated position we're trying to map
      // to an original position.
      var sectionIndex = binarySearch.search(needle, this._sections,
        function(needle, section) {
          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }

          return (needle.generatedColumn -
                  section.generatedOffset.generatedColumn);
        });
      var section = this._sections[sectionIndex];

      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }

      return section.consumer.originalPositionFor({
        line: needle.generatedLine -
          (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn -
          (section.generatedOffset.generatedLine === needle.generatedLine
           ? section.generatedOffset.generatedColumn - 1
           : 0),
        bias: aArgs.bias
      });
    };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
    function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function (s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  IndexedSourceMapConsumer.prototype.sourceContentFor =
    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based. 
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  IndexedSourceMapConsumer.prototype.generatedPositionFor =
    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        // Only consider this section if the requested source is in the list of
        // sources of the consumer.
        if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line +
              (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column +
              (section.generatedOffset.generatedLine === generatedPosition.line
               ? section.generatedOffset.generatedColumn - 1
               : 0)
          };
          return ret;
        }
      }

      return {
        line: null,
        column: null
      };
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  IndexedSourceMapConsumer.prototype._parseMappings =
    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];

          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);

          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }

          // The mappings coming from the consumer for the section have
          // generated positions relative to the start of the section, so we
          // need to offset them to be relative to the start of the concatenated
          // generated file.
          var adjustedMapping = {
            source: source,
            generatedLine: mapping.generatedLine +
              (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn +
              (section.generatedOffset.generatedLine === mapping.generatedLine
              ? section.generatedOffset.generatedColumn - 1
              : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: name
          };

          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === 'number') {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }

      quickSort$1(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort$1(this.__originalMappings, util.compareByOriginalPositions);
    };

  var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;

  var sourceMapConsumer = {
  	SourceMapConsumer: SourceMapConsumer_1,
  	BasicSourceMapConsumer: BasicSourceMapConsumer_1,
  	IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
  };

  /*
   * Copyright 2009-2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE.txt or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
  var SourceMapConsumer$1 = sourceMapConsumer.SourceMapConsumer;

  const PURE_ANNOTATION = `/*#__PURE__*/`;
  function createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssr = false }) {
      const context = {
          mode,
          prefixIdentifiers,
          sourceMap,
          filename,
          scopeId,
          optimizeImports,
          runtimeGlobalName,
          runtimeModuleName,
          ssr,
          source: ast.loc.source,
          code: ``,
          column: 1,
          line: 1,
          offset: 0,
          indentLevel: 0,
          pure: false,
          map: undefined,
          helper(key) {
              return `_${helperNameMap[key]}`;
          },
          push(code, node) {
              context.code += code;
              if ( context.map) {
                  if (node) {
                      let name;
                      if (node.type === 4 /* SIMPLE_EXPRESSION */ && !node.isStatic) {
                          const content = node.content.replace(/^_ctx\./, '');
                          if (content !== node.content && isSimpleIdentifier(content)) {
                              name = content;
                          }
                      }
                      addMapping(node.loc.start, name);
                  }
                  advancePositionWithMutation(context, code);
                  if (node && node.loc !== locStub) {
                      addMapping(node.loc.end);
                  }
              }
          },
          indent() {
              newline(++context.indentLevel);
          },
          deindent(withoutNewLine = false) {
              if (withoutNewLine) {
                  --context.indentLevel;
              }
              else {
                  newline(--context.indentLevel);
              }
          },
          newline() {
              newline(context.indentLevel);
          }
      };
      function newline(n) {
          context.push('\n' + `  `.repeat(n));
      }
      function addMapping(loc, name) {
          context.map.addMapping({
              name,
              source: context.filename,
              original: {
                  line: loc.line,
                  column: loc.column - 1 // source-map column is 0 based
              },
              generated: {
                  line: context.line,
                  column: context.column - 1
              }
          });
      }
      if ( sourceMap) {
          // lazy require source-map implementation, only in non-browser builds
          context.map = new SourceMapGenerator$1();
          context.map.setSourceContent(filename, context.source);
      }
      return context;
  }
  function generate(ast, options = {}) {
      const context = createCodegenContext(ast, options);
      if (options.onContextCreated)
          options.onContextCreated(context);
      const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
      const hasHelpers = ast.helpers.length > 0;
      const useWithBlock = !prefixIdentifiers && mode !== 'module';
      const genScopeId =  scopeId != null && mode === 'module';
      // preambles
      if ( mode === 'module') {
          genModulePreamble(ast, context, genScopeId);
      }
      else {
          genFunctionPreamble(ast, context);
      }
      // binding optimizations
      const optimizeSources = options.bindingMetadata
          ? `, $props, $setup, $data, $options`
          : ``;
      // enter render function
      if (!ssr) {
          if (genScopeId) {
              push(`const render = ${PURE_ANNOTATION}_withId(`);
          }
          push(`function render(_ctx, _cache${optimizeSources}) {`);
      }
      else {
          if (genScopeId) {
              push(`const ssrRender = ${PURE_ANNOTATION}_withId(`);
          }
          push(`function ssrRender(_ctx, _push, _parent, _attrs${optimizeSources}) {`);
      }
      indent();
      if (useWithBlock) {
          push(`with (_ctx) {`);
          indent();
          // function mode const declarations should be inside with block
          // also they should be renamed to avoid collision with user properties
          if (hasHelpers) {
              push(`const { ${ast.helpers
                .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)
                .join(', ')} } = _Vue`);
              push(`\n`);
              newline();
          }
      }
      // generate asset resolution statements
      if (ast.components.length) {
          genAssets(ast.components, 'component', context);
          if (ast.directives.length || ast.temps > 0) {
              newline();
          }
      }
      if (ast.directives.length) {
          genAssets(ast.directives, 'directive', context);
          if (ast.temps > 0) {
              newline();
          }
      }
      if (ast.temps > 0) {
          push(`let `);
          for (let i = 0; i < ast.temps; i++) {
              push(`${i > 0 ? `, ` : ``}_temp${i}`);
          }
      }
      if (ast.components.length || ast.directives.length || ast.temps) {
          push(`\n`);
          newline();
      }
      // generate the VNode tree expression
      if (!ssr) {
          push(`return `);
      }
      if (ast.codegenNode) {
          genNode(ast.codegenNode, context);
      }
      else {
          push(`null`);
      }
      if (useWithBlock) {
          deindent();
          push(`}`);
      }
      deindent();
      push(`}`);
      if (genScopeId) {
          push(`)`);
      }
      return {
          ast,
          code: context.code,
          // SourceMapGenerator does have toJSON() method but it's not in the types
          map: context.map ? context.map.toJSON() : undefined
      };
  }
  function genFunctionPreamble(ast, context) {
      const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName } = context;
      const VueBinding =  ssr
          ? `require(${JSON.stringify(runtimeModuleName)})`
          : runtimeGlobalName;
      const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
      // Generate const declaration for helpers
      // In prefix mode, we place the const declaration at top so it's done
      // only once; But if we not prefixing, we place the declaration inside the
      // with block so it doesn't incur the `in` check cost for every helper access.
      if (ast.helpers.length > 0) {
          if ( prefixIdentifiers) {
              push(`const { ${ast.helpers.map(aliasHelper).join(', ')} } = ${VueBinding}\n`);
          }
          else {
              // "with" mode.
              // save Vue in a separate variable to avoid collision
              push(`const _Vue = ${VueBinding}\n`);
              // in "with" mode, helpers are declared inside the with block to avoid
              // has check cost, but hoists are lifted out of the function - we need
              // to provide the helper here.
              if (ast.hoists.length) {
                  const staticHelpers = [
                      CREATE_VNODE,
                      CREATE_COMMENT,
                      CREATE_TEXT,
                      CREATE_STATIC
                  ]
                      .filter(helper => ast.helpers.includes(helper))
                      .map(aliasHelper)
                      .join(', ');
                  push(`const { ${staticHelpers} } = _Vue\n`);
              }
          }
      }
      // generate variables for ssr helpers
      if ( ast.ssrHelpers && ast.ssrHelpers.length) {
          // ssr guarantees prefixIdentifier: true
          push(`const { ${ast.ssrHelpers
            .map(aliasHelper)
            .join(', ')} } = require("@vue/server-renderer")\n`);
      }
      genHoists(ast.hoists, context);
      newline();
      push(`return `);
  }
  function genModulePreamble(ast, context, genScopeId) {
      const { push, helper, newline, scopeId, optimizeImports, runtimeModuleName } = context;
      if (genScopeId) {
          ast.helpers.push(WITH_SCOPE_ID);
          if (ast.hoists.length) {
              ast.helpers.push(PUSH_SCOPE_ID, POP_SCOPE_ID);
          }
      }
      // generate import statements for helpers
      if (ast.helpers.length) {
          if (optimizeImports) {
              // when bundled with webpack with code-split, calling an import binding
              // as a function leads to it being wrapped with `Object(a.b)` or `(0,a.b)`,
              // incurring both payload size increase and potential perf overhead.
              // therefore we assign the imports to variables (which is a constant ~50b
              // cost per-component instead of scaling with template size)
              push(`import { ${ast.helpers
                .map(s => helperNameMap[s])
                .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\n`);
              push(`\n// Binding optimization for webpack code-split\nconst ${ast.helpers
                .map(s => `_${helperNameMap[s]} = ${helperNameMap[s]}`)
                .join(', ')}\n`);
          }
          else {
              push(`import { ${ast.helpers
                .map(s => `${helperNameMap[s]} as _${helperNameMap[s]}`)
                .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\n`);
          }
      }
      if (ast.ssrHelpers && ast.ssrHelpers.length) {
          push(`import { ${ast.ssrHelpers
            .map(s => `${helperNameMap[s]} as _${helperNameMap[s]}`)
            .join(', ')} } from "@vue/server-renderer"\n`);
      }
      if (ast.imports.length) {
          genImports(ast.imports, context);
          newline();
      }
      if (genScopeId) {
          push(`const _withId = ${PURE_ANNOTATION}${helper(WITH_SCOPE_ID)}("${scopeId}")`);
          newline();
      }
      genHoists(ast.hoists, context);
      newline();
      push(`export `);
  }
  function genAssets(assets, type, { helper, push, newline }) {
      const resolver = helper(type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
      for (let i = 0; i < assets.length; i++) {
          const id = assets[i];
          push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)})`);
          if (i < assets.length - 1) {
              newline();
          }
      }
  }
  function genHoists(hoists, context) {
      if (!hoists.length) {
          return;
      }
      context.pure = true;
      const { push, newline, helper, scopeId, mode } = context;
      const genScopeId =  scopeId != null && mode !== 'function';
      newline();
      // push scope Id before initializing hoisted vnodes so that these vnodes
      // get the proper scopeId as well.
      if (genScopeId) {
          push(`${helper(PUSH_SCOPE_ID)}("${scopeId}")`);
          newline();
      }
      hoists.forEach((exp, i) => {
          if (exp) {
              push(`const _hoisted_${i + 1} = `);
              genNode(exp, context);
              newline();
          }
      });
      if (genScopeId) {
          push(`${helper(POP_SCOPE_ID)}()`);
          newline();
      }
      context.pure = false;
  }
  function genImports(importsOptions, context) {
      if (!importsOptions.length) {
          return;
      }
      importsOptions.forEach(imports => {
          context.push(`import `);
          genNode(imports.exp, context);
          context.push(` from '${imports.path}'`);
          context.newline();
      });
  }
  function isText$1(n) {
      return (isString(n) ||
          n.type === 4 /* SIMPLE_EXPRESSION */ ||
          n.type === 2 /* TEXT */ ||
          n.type === 5 /* INTERPOLATION */ ||
          n.type === 8 /* COMPOUND_EXPRESSION */);
  }
  function genNodeListAsArray(nodes, context) {
      const multilines = nodes.length > 3 ||
          ( nodes.some(n => isArray(n) || !isText$1(n)));
      context.push(`[`);
      multilines && context.indent();
      genNodeList(nodes, context, multilines);
      multilines && context.deindent();
      context.push(`]`);
  }
  function genNodeList(nodes, context, multilines = false, comma = true) {
      const { push, newline } = context;
      for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (isString(node)) {
              push(node);
          }
          else if (isArray(node)) {
              genNodeListAsArray(node, context);
          }
          else {
              genNode(node, context);
          }
          if (i < nodes.length - 1) {
              if (multilines) {
                  comma && push(',');
                  newline();
              }
              else {
                  comma && push(', ');
              }
          }
      }
  }
  function genNode(node, context) {
      if (isString(node)) {
          context.push(node);
          return;
      }
      if (isSymbol(node)) {
          context.push(context.helper(node));
          return;
      }
      switch (node.type) {
          case 1 /* ELEMENT */:
          case 9 /* IF */:
          case 11 /* FOR */:
              
                  assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. ` +
                      `Apply appropriate transforms first.`);
              genNode(node.codegenNode, context);
              break;
          case 2 /* TEXT */:
              genText(node, context);
              break;
          case 4 /* SIMPLE_EXPRESSION */:
              genExpression(node, context);
              break;
          case 5 /* INTERPOLATION */:
              genInterpolation(node, context);
              break;
          case 12 /* TEXT_CALL */:
              genNode(node.codegenNode, context);
              break;
          case 8 /* COMPOUND_EXPRESSION */:
              genCompoundExpression(node, context);
              break;
          case 3 /* COMMENT */:
              genComment(node, context);
              break;
          case 13 /* VNODE_CALL */:
              genVNodeCall(node, context);
              break;
          case 14 /* JS_CALL_EXPRESSION */:
              genCallExpression(node, context);
              break;
          case 15 /* JS_OBJECT_EXPRESSION */:
              genObjectExpression(node, context);
              break;
          case 17 /* JS_ARRAY_EXPRESSION */:
              genArrayExpression(node, context);
              break;
          case 18 /* JS_FUNCTION_EXPRESSION */:
              genFunctionExpression(node, context);
              break;
          case 19 /* JS_CONDITIONAL_EXPRESSION */:
              genConditionalExpression(node, context);
              break;
          case 20 /* JS_CACHE_EXPRESSION */:
              genCacheExpression(node, context);
              break;
          // SSR only types
          case 21 /* JS_BLOCK_STATEMENT */:
               genNodeList(node.body, context, true, false);
              break;
          case 22 /* JS_TEMPLATE_LITERAL */:
               genTemplateLiteral(node, context);
              break;
          case 23 /* JS_IF_STATEMENT */:
               genIfStatement(node, context);
              break;
          case 24 /* JS_ASSIGNMENT_EXPRESSION */:
               genAssignmentExpression(node, context);
              break;
          case 25 /* JS_SEQUENCE_EXPRESSION */:
               genSequenceExpression(node, context);
              break;
          case 26 /* JS_RETURN_STATEMENT */:
               genReturnStatement(node, context);
              break;
          /* istanbul ignore next */
          case 10 /* IF_BRANCH */:
              // noop
              break;
          default:
              {
                  assert(false, `unhandled codegen node type: ${node.type}`);
                  // make sure we exhaust all possible types
                  const exhaustiveCheck = node;
                  return exhaustiveCheck;
              }
      }
  }
  function genText(node, context) {
      context.push(JSON.stringify(node.content), node);
  }
  function genExpression(node, context) {
      const { content, isStatic } = node;
      context.push(isStatic ? JSON.stringify(content) : content, node);
  }
  function genInterpolation(node, context) {
      const { push, helper, pure } = context;
      if (pure)
          push(PURE_ANNOTATION);
      push(`${helper(TO_DISPLAY_STRING)}(`);
      genNode(node.content, context);
      push(`)`);
  }
  function genCompoundExpression(node, context) {
      for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          if (isString(child)) {
              context.push(child);
          }
          else {
              genNode(child, context);
          }
      }
  }
  function genExpressionAsPropertyKey(node, context) {
      const { push } = context;
      if (node.type === 8 /* COMPOUND_EXPRESSION */) {
          push(`[`);
          genCompoundExpression(node, context);
          push(`]`);
      }
      else if (node.isStatic) {
          // only quote keys if necessary
          const text = isSimpleIdentifier(node.content)
              ? node.content
              : JSON.stringify(node.content);
          push(text, node);
      }
      else {
          push(`[${node.content}]`, node);
      }
  }
  function genComment(node, context) {
      {
          const { push, helper, pure } = context;
          if (pure) {
              push(PURE_ANNOTATION);
          }
          push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
      }
  }
  function genVNodeCall(node, context) {
      const { push, helper, pure } = context;
      const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking } = node;
      if (directives) {
          push(helper(WITH_DIRECTIVES) + `(`);
      }
      if (isBlock) {
          push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
      }
      if (pure) {
          push(PURE_ANNOTATION);
      }
      push(helper(isBlock ? CREATE_BLOCK : CREATE_VNODE) + `(`, node);
      genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
      push(`)`);
      if (isBlock) {
          push(`)`);
      }
      if (directives) {
          push(`, `);
          genNode(directives, context);
          push(`)`);
      }
  }
  function genNullableArgs(args) {
      let i = args.length;
      while (i--) {
          if (args[i] != null)
              break;
      }
      return args.slice(0, i + 1).map(arg => arg || `null`);
  }
  // JavaScript
  function genCallExpression(node, context) {
      const { push, helper, pure } = context;
      const callee = isString(node.callee) ? node.callee : helper(node.callee);
      if (pure) {
          push(PURE_ANNOTATION);
      }
      push(callee + `(`, node);
      genNodeList(node.arguments, context);
      push(`)`);
  }
  function genObjectExpression(node, context) {
      const { push, indent, deindent, newline } = context;
      const { properties } = node;
      if (!properties.length) {
          push(`{}`, node);
          return;
      }
      const multilines = properties.length > 1 ||
          (
              properties.some(p => p.value.type !== 4 /* SIMPLE_EXPRESSION */));
      push(multilines ? `{` : `{ `);
      multilines && indent();
      for (let i = 0; i < properties.length; i++) {
          const { key, value } = properties[i];
          // key
          genExpressionAsPropertyKey(key, context);
          push(`: `);
          // value
          genNode(value, context);
          if (i < properties.length - 1) {
              // will only reach this if it's multilines
              push(`,`);
              newline();
          }
      }
      multilines && deindent();
      push(multilines ? `}` : ` }`);
  }
  function genArrayExpression(node, context) {
      genNodeListAsArray(node.elements, context);
  }
  function genFunctionExpression(node, context) {
      const { push, indent, deindent, scopeId, mode } = context;
      const { params, returns, body, newline, isSlot } = node;
      // slot functions also need to push scopeId before rendering its content
      const genScopeId =  isSlot && scopeId != null && mode !== 'function';
      if (genScopeId) {
          push(`_withId(`);
      }
      else if (isSlot) {
          push(`_${helperNameMap[WITH_CTX]}(`);
      }
      push(`(`, node);
      if (isArray(params)) {
          genNodeList(params, context);
      }
      else if (params) {
          genNode(params, context);
      }
      push(`) => `);
      if (newline || body) {
          push(`{`);
          indent();
      }
      if (returns) {
          if (newline) {
              push(`return `);
          }
          if (isArray(returns)) {
              genNodeListAsArray(returns, context);
          }
          else {
              genNode(returns, context);
          }
      }
      else if (body) {
          genNode(body, context);
      }
      if (newline || body) {
          deindent();
          push(`}`);
      }
      if (genScopeId || isSlot) {
          push(`)`);
      }
  }
  function genConditionalExpression(node, context) {
      const { test, consequent, alternate, newline: needNewline } = node;
      const { push, indent, deindent, newline } = context;
      if (test.type === 4 /* SIMPLE_EXPRESSION */) {
          const needsParens = !isSimpleIdentifier(test.content);
          needsParens && push(`(`);
          genExpression(test, context);
          needsParens && push(`)`);
      }
      else {
          push(`(`);
          genNode(test, context);
          push(`)`);
      }
      needNewline && indent();
      context.indentLevel++;
      needNewline || push(` `);
      push(`? `);
      genNode(consequent, context);
      context.indentLevel--;
      needNewline && newline();
      needNewline || push(` `);
      push(`: `);
      const isNested = alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */;
      if (!isNested) {
          context.indentLevel++;
      }
      genNode(alternate, context);
      if (!isNested) {
          context.indentLevel--;
      }
      needNewline && deindent(true /* without newline */);
  }
  function genCacheExpression(node, context) {
      const { push, helper, indent, deindent, newline } = context;
      push(`_cache[${node.index}] || (`);
      if (node.isVNode) {
          indent();
          push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
          newline();
      }
      push(`_cache[${node.index}] = `);
      genNode(node.value, context);
      if (node.isVNode) {
          push(`,`);
          newline();
          push(`${helper(SET_BLOCK_TRACKING)}(1),`);
          newline();
          push(`_cache[${node.index}]`);
          deindent();
      }
      push(`)`);
  }
  function genTemplateLiteral(node, context) {
      const { push, indent, deindent } = context;
      push('`');
      const l = node.elements.length;
      const multilines = l > 3;
      for (let i = 0; i < l; i++) {
          const e = node.elements[i];
          if (isString(e)) {
              push(e.replace(/(`|\$|\\)/g, '\\$1'));
          }
          else {
              push('${');
              if (multilines)
                  indent();
              genNode(e, context);
              if (multilines)
                  deindent();
              push('}');
          }
      }
      push('`');
  }
  function genIfStatement(node, context) {
      const { push, indent, deindent } = context;
      const { test, consequent, alternate } = node;
      push(`if (`);
      genNode(test, context);
      push(`) {`);
      indent();
      genNode(consequent, context);
      deindent();
      push(`}`);
      if (alternate) {
          push(` else `);
          if (alternate.type === 23 /* JS_IF_STATEMENT */) {
              genIfStatement(alternate, context);
          }
          else {
              push(`{`);
              indent();
              genNode(alternate, context);
              deindent();
              push(`}`);
          }
      }
  }
  function genAssignmentExpression(node, context) {
      genNode(node.left, context);
      context.push(` = `);
      genNode(node.right, context);
  }
  function genSequenceExpression(node, context) {
      context.push(`(`);
      genNodeList(node.expressions, context);
      context.push(`)`);
  }
  function genReturnStatement({ returns }, context) {
      context.push(`return `);
      if (isArray(returns)) {
          genNodeListAsArray(returns, context);
      }
      else {
          genNode(returns, context);
      }
  }

  var lib = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, '__esModule', { value: true });

  const beforeExpr = true;
  const startsExpr = true;
  const isLoop = true;
  const isAssign = true;
  const prefix = true;
  const postfix = true;
  class TokenType {
    constructor(label, conf = {}) {
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.rightAssociative = !!conf.rightAssociative;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop != null ? conf.binop : null;
      this.updateContext = null;
    }

  }
  const keywords = new Map();

  function createKeyword(name, options = {}) {
    options.keyword = name;
    const token = new TokenType(name, options);
    keywords.set(name, token);
    return token;
  }

  function createBinop(name, binop) {
    return new TokenType(name, {
      beforeExpr,
      binop
    });
  }

  const types = {
    num: new TokenType("num", {
      startsExpr
    }),
    bigint: new TokenType("bigint", {
      startsExpr
    }),
    decimal: new TokenType("decimal", {
      startsExpr
    }),
    regexp: new TokenType("regexp", {
      startsExpr
    }),
    string: new TokenType("string", {
      startsExpr
    }),
    name: new TokenType("name", {
      startsExpr
    }),
    eof: new TokenType("eof"),
    bracketL: new TokenType("[", {
      beforeExpr,
      startsExpr
    }),
    bracketHashL: new TokenType("#[", {
      beforeExpr,
      startsExpr
    }),
    bracketBarL: new TokenType("[|", {
      beforeExpr,
      startsExpr
    }),
    bracketR: new TokenType("]"),
    bracketBarR: new TokenType("|]"),
    braceL: new TokenType("{", {
      beforeExpr,
      startsExpr
    }),
    braceBarL: new TokenType("{|", {
      beforeExpr,
      startsExpr
    }),
    braceHashL: new TokenType("#{", {
      beforeExpr,
      startsExpr
    }),
    braceR: new TokenType("}"),
    braceBarR: new TokenType("|}"),
    parenL: new TokenType("(", {
      beforeExpr,
      startsExpr
    }),
    parenR: new TokenType(")"),
    comma: new TokenType(",", {
      beforeExpr
    }),
    semi: new TokenType(";", {
      beforeExpr
    }),
    colon: new TokenType(":", {
      beforeExpr
    }),
    doubleColon: new TokenType("::", {
      beforeExpr
    }),
    dot: new TokenType("."),
    question: new TokenType("?", {
      beforeExpr
    }),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", {
      beforeExpr
    }),
    template: new TokenType("template"),
    ellipsis: new TokenType("...", {
      beforeExpr
    }),
    backQuote: new TokenType("`", {
      startsExpr
    }),
    dollarBraceL: new TokenType("${", {
      beforeExpr,
      startsExpr
    }),
    at: new TokenType("@"),
    hash: new TokenType("#", {
      startsExpr
    }),
    interpreterDirective: new TokenType("#!..."),
    eq: new TokenType("=", {
      beforeExpr,
      isAssign
    }),
    assign: new TokenType("_=", {
      beforeExpr,
      isAssign
    }),
    incDec: new TokenType("++/--", {
      prefix,
      postfix,
      startsExpr
    }),
    bang: new TokenType("!", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    tilde: new TokenType("~", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    pipeline: createBinop("|>", 0),
    nullishCoalescing: createBinop("??", 1),
    logicalOR: createBinop("||", 1),
    logicalAND: createBinop("&&", 2),
    bitwiseOR: createBinop("|", 3),
    bitwiseXOR: createBinop("^", 4),
    bitwiseAND: createBinop("&", 5),
    equality: createBinop("==/!=/===/!==", 6),
    relational: createBinop("</>/<=/>=", 7),
    bitShift: createBinop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {
      beforeExpr,
      binop: 9,
      prefix,
      startsExpr
    }),
    modulo: new TokenType("%", {
      beforeExpr,
      binop: 10,
      startsExpr
    }),
    star: new TokenType("*", {
      binop: 10
    }),
    slash: createBinop("/", 10),
    exponent: new TokenType("**", {
      beforeExpr,
      binop: 11,
      rightAssociative: true
    }),
    _break: createKeyword("break"),
    _case: createKeyword("case", {
      beforeExpr
    }),
    _catch: createKeyword("catch"),
    _continue: createKeyword("continue"),
    _debugger: createKeyword("debugger"),
    _default: createKeyword("default", {
      beforeExpr
    }),
    _do: createKeyword("do", {
      isLoop,
      beforeExpr
    }),
    _else: createKeyword("else", {
      beforeExpr
    }),
    _finally: createKeyword("finally"),
    _for: createKeyword("for", {
      isLoop
    }),
    _function: createKeyword("function", {
      startsExpr
    }),
    _if: createKeyword("if"),
    _return: createKeyword("return", {
      beforeExpr
    }),
    _switch: createKeyword("switch"),
    _throw: createKeyword("throw", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _try: createKeyword("try"),
    _var: createKeyword("var"),
    _const: createKeyword("const"),
    _while: createKeyword("while", {
      isLoop
    }),
    _with: createKeyword("with"),
    _new: createKeyword("new", {
      beforeExpr,
      startsExpr
    }),
    _this: createKeyword("this", {
      startsExpr
    }),
    _super: createKeyword("super", {
      startsExpr
    }),
    _class: createKeyword("class", {
      startsExpr
    }),
    _extends: createKeyword("extends", {
      beforeExpr
    }),
    _export: createKeyword("export"),
    _import: createKeyword("import", {
      startsExpr
    }),
    _null: createKeyword("null", {
      startsExpr
    }),
    _true: createKeyword("true", {
      startsExpr
    }),
    _false: createKeyword("false", {
      startsExpr
    }),
    _in: createKeyword("in", {
      beforeExpr,
      binop: 7
    }),
    _instanceof: createKeyword("instanceof", {
      beforeExpr,
      binop: 7
    }),
    _typeof: createKeyword("typeof", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _void: createKeyword("void", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _delete: createKeyword("delete", {
      beforeExpr,
      prefix,
      startsExpr
    })
  };

  const SCOPE_OTHER = 0b00000000,
        SCOPE_PROGRAM = 0b00000001,
        SCOPE_FUNCTION = 0b00000010,
        SCOPE_ARROW = 0b00000100,
        SCOPE_SIMPLE_CATCH = 0b00001000,
        SCOPE_SUPER = 0b00010000,
        SCOPE_DIRECT_SUPER = 0b00100000,
        SCOPE_CLASS = 0b01000000,
        SCOPE_TS_MODULE = 0b10000000,
        SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
  const BIND_KIND_VALUE = 0b00000000001,
        BIND_KIND_TYPE = 0b00000000010,
        BIND_SCOPE_VAR = 0b00000000100,
        BIND_SCOPE_LEXICAL = 0b00000001000,
        BIND_SCOPE_FUNCTION = 0b00000010000,
        BIND_FLAGS_NONE = 0b00001000000,
        BIND_FLAGS_CLASS = 0b00010000000,
        BIND_FLAGS_TS_ENUM = 0b00100000000,
        BIND_FLAGS_TS_CONST_ENUM = 0b01000000000,
        BIND_FLAGS_TS_EXPORT_ONLY = 0b10000000000;
  const BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,
        BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,
        BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,
        BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,
        BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,
        BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,
        BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,
        BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
        BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,
        BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,
        BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,
        BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
  const CLASS_ELEMENT_FLAG_STATIC = 0b100,
        CLASS_ELEMENT_KIND_GETTER = 0b010,
        CLASS_ELEMENT_KIND_SETTER = 0b001,
        CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
  const CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,
        CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,
        CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,
        CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,
        CLASS_ELEMENT_OTHER = 0;

  const lineBreak = /\r\n?|[\n\u2028\u2029]/;
  const lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code) {
    switch (code) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;

      default:
        return false;
    }
  }
  const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  function isWhitespace(code) {
    switch (code) {
      case 0x0009:
      case 0x000b:
      case 0x000c:
      case 32:
      case 160:
      case 5760:
      case 0x2000:
      case 0x2001:
      case 0x2002:
      case 0x2003:
      case 0x2004:
      case 0x2005:
      case 0x2006:
      case 0x2007:
      case 0x2008:
      case 0x2009:
      case 0x200a:
      case 0x202f:
      case 0x205f:
      case 0x3000:
      case 0xfeff:
        return true;

      default:
        return false;
    }
  }

  class Position {
    constructor(line, col) {
      this.line = line;
      this.column = col;
    }

  }
  class SourceLocation {
    constructor(start, end) {
      this.start = start;
      this.end = end;
    }

  }
  function getLineInfo(input, offset) {
    let line = 1;
    let lineStart = 0;
    let match;
    lineBreakG.lastIndex = 0;

    while ((match = lineBreakG.exec(input)) && match.index < offset) {
      line++;
      lineStart = lineBreakG.lastIndex;
    }

    return new Position(line, offset - lineStart);
  }

  class BaseParser {
    constructor() {
      this.sawUnambiguousESM = false;
      this.ambiguousScriptDifferentAst = false;
    }

    hasPlugin(name) {
      return this.plugins.has(name);
    }

    getPluginOption(plugin, name) {
      if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];
    }

  }

  function last(stack) {
    return stack[stack.length - 1];
  }

  class CommentsParser extends BaseParser {
    addComment(comment) {
      if (this.filename) comment.loc.filename = this.filename;
      this.state.trailingComments.push(comment);
      this.state.leadingComments.push(comment);
    }

    adjustCommentsAfterTrailingComma(node, elements, takeAllComments) {
      if (this.state.leadingComments.length === 0) {
        return;
      }

      let lastElement = null;
      let i = elements.length;

      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }

      if (lastElement === null) {
        return;
      }

      for (let j = 0; j < this.state.leadingComments.length; j++) {
        if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
          this.state.leadingComments.splice(j, 1);
          j--;
        }
      }

      const newTrailingComments = [];

      for (let i = 0; i < this.state.leadingComments.length; i++) {
        const leadingComment = this.state.leadingComments[i];

        if (leadingComment.end < node.end) {
          newTrailingComments.push(leadingComment);

          if (!takeAllComments) {
            this.state.leadingComments.splice(i, 1);
            i--;
          }
        } else {
          if (node.trailingComments === undefined) {
            node.trailingComments = [];
          }

          node.trailingComments.push(leadingComment);
        }
      }

      if (takeAllComments) this.state.leadingComments = [];

      if (newTrailingComments.length > 0) {
        lastElement.trailingComments = newTrailingComments;
      } else if (lastElement.trailingComments !== undefined) {
        lastElement.trailingComments = [];
      }
    }

    processComment(node) {
      if (node.type === "Program" && node.body.length > 0) return;
      const stack = this.state.commentStack;
      let firstChild, lastChild, trailingComments, i, j;

      if (this.state.trailingComments.length > 0) {
        if (this.state.trailingComments[0].start >= node.end) {
          trailingComments = this.state.trailingComments;
          this.state.trailingComments = [];
        } else {
          this.state.trailingComments.length = 0;
        }
      } else if (stack.length > 0) {
        const lastInStack = last(stack);

        if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
          trailingComments = lastInStack.trailingComments;
          delete lastInStack.trailingComments;
        }
      }

      if (stack.length > 0 && last(stack).start >= node.start) {
        firstChild = stack.pop();
      }

      while (stack.length > 0 && last(stack).start >= node.start) {
        lastChild = stack.pop();
      }

      if (!lastChild && firstChild) lastChild = firstChild;

      if (firstChild) {
        switch (node.type) {
          case "ObjectExpression":
            this.adjustCommentsAfterTrailingComma(node, node.properties);
            break;

          case "ObjectPattern":
            this.adjustCommentsAfterTrailingComma(node, node.properties, true);
            break;

          case "CallExpression":
            this.adjustCommentsAfterTrailingComma(node, node.arguments);
            break;

          case "ArrayExpression":
            this.adjustCommentsAfterTrailingComma(node, node.elements);
            break;

          case "ArrayPattern":
            this.adjustCommentsAfterTrailingComma(node, node.elements, true);
            break;
        }
      } else if (this.state.commentPreviousNode && (this.state.commentPreviousNode.type === "ImportSpecifier" && node.type !== "ImportSpecifier" || this.state.commentPreviousNode.type === "ExportSpecifier" && node.type !== "ExportSpecifier")) {
        this.adjustCommentsAfterTrailingComma(node, [this.state.commentPreviousNode]);
      }

      if (lastChild) {
        if (lastChild.leadingComments) {
          if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {
            node.leadingComments = lastChild.leadingComments;
            delete lastChild.leadingComments;
          } else {
            for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
              if (lastChild.leadingComments[i].end <= node.start) {
                node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
                break;
              }
            }
          }
        }
      } else if (this.state.leadingComments.length > 0) {
        if (last(this.state.leadingComments).end <= node.start) {
          if (this.state.commentPreviousNode) {
            for (j = 0; j < this.state.leadingComments.length; j++) {
              if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
                this.state.leadingComments.splice(j, 1);
                j--;
              }
            }
          }

          if (this.state.leadingComments.length > 0) {
            node.leadingComments = this.state.leadingComments;
            this.state.leadingComments = [];
          }
        } else {
          for (i = 0; i < this.state.leadingComments.length; i++) {
            if (this.state.leadingComments[i].end > node.start) {
              break;
            }
          }

          const leadingComments = this.state.leadingComments.slice(0, i);

          if (leadingComments.length) {
            node.leadingComments = leadingComments;
          }

          trailingComments = this.state.leadingComments.slice(i);

          if (trailingComments.length === 0) {
            trailingComments = null;
          }
        }
      }

      this.state.commentPreviousNode = node;

      if (trailingComments) {
        if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {
          node.innerComments = trailingComments;
        } else {
          const firstTrailingCommentIndex = trailingComments.findIndex(comment => comment.end >= node.end);

          if (firstTrailingCommentIndex > 0) {
            node.innerComments = trailingComments.slice(0, firstTrailingCommentIndex);
            node.trailingComments = trailingComments.slice(firstTrailingCommentIndex);
          } else {
            node.trailingComments = trailingComments;
          }
        }
      }

      stack.push(node);
    }

  }

  const ErrorMessages = Object.freeze({
    AccessorIsGenerator: "A %0ter cannot be a generator",
    ArgumentsDisallowedInInitializer: "'arguments' is not allowed in class field initializer",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function",
    AwaitExpressionFormalParameter: "await is not allowed in async function parameters",
    AwaitNotInAsyncFunction: "Can not use keyword 'await' outside an async function",
    BadGetterArity: "getter must not have any formal parameters",
    BadSetterArity: "setter must have exactly one formal parameter",
    BadSetterRestParameter: "setter function argument must not be a rest parameter",
    ConstructorClassField: "Classes may not have a field named 'constructor'",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'",
    ConstructorIsAccessor: "Class constructor may not be an accessor",
    ConstructorIsAsync: "Constructor can't be an async function",
    ConstructorIsGenerator: "Constructor can't be a generator",
    DeclarationMissingInitializer: "%0 require an initialization value",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon",
    DeletePrivateField: "Deleting a private field is not allowed",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
    DuplicateProto: "Redefinition of __proto__ property",
    DuplicateRegExpFlags: "Duplicate regular expression flag",
    ElementAfterRest: "Rest element must be last element",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape",
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'",
    ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block",
    IllegalBreakContinue: "Unsyntactic %0",
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
    IllegalReturn: "'return' outside of function",
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments",
    ImportCallArity: "import() requires exactly %0",
    ImportCallNotNewExpression: "Cannot use new with import(...)",
    ImportCallSpreadArgument: "... is not allowed in import()",
    ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`,
    ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'`,
    InvalidBigIntLiteral: "Invalid BigIntLiteral",
    InvalidCodePoint: "Code point out of bounds",
    InvalidDecimal: "Invalid decimal",
    InvalidDigit: "Expected number in radix %0",
    InvalidEscapeSequence: "Bad character escape sequence",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template",
    InvalidEscapedReservedWord: "Escape sequence in keyword %0",
    InvalidIdentifier: "Invalid identifier %0",
    InvalidLhs: "Invalid left-hand side in %0",
    InvalidLhsBinding: "Binding invalid left-hand side in %0",
    InvalidNumber: "Invalid number",
    InvalidOrUnexpectedToken: "Unexpected character '%0'",
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern",
    InvalidPrivateFieldResolution: "Private name #%0 is not defined",
    InvalidPropertyBindingPattern: "Binding member expression",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument",
    LabelRedeclaration: "Label '%0' is already declared",
    LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'",
    MalformedRegExpFlags: "Invalid regular expression flag",
    MissingClassName: "A class name is required",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values",
    ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes',
    ModuleExportUndefined: "Export '%0' is not defined",
    MultipleDefaultsInSwitch: "Multiple default clauses",
    NewlineAfterThrow: "Illegal newline after throw",
    NoCatchOrFinally: "Missing catch or finally clause",
    NumberIdentifier: "Identifier directly after number",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences",
    ObsoleteAwaitStar: "await* has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "constructors in/after an Optional Chain are not allowed",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain",
    ParamDupe: "Argument name clash",
    PatternHasAccessor: "Object pattern can't contain getter or setter",
    PatternHasMethod: "Object pattern can't contain methods",
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding",
    PrimaryTopicRequiresSmartPipeline: "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.",
    PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`)",
    PrivateNameRedeclaration: "Duplicate private name #%0",
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
    RecordNoProto: "'__proto__' is not allowed in Record expressions",
    RestTrailingComma: "Unexpected trailing comma after rest element",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement",
    StaticPrototype: "Classes may not have static property named prototype",
    StrictDelete: "Deleting local variable in strict mode",
    StrictEvalArguments: "Assigning to '%0' in strict mode",
    StrictEvalArgumentsBinding: "Binding '%0' in strict mode",
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode",
    StrictWith: "'with' in strict mode",
    SuperNotAllowed: "super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super",
    TrailingDecorator: "Decorators must be attached to a class element",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level",
    UnexpectedKeyword: "Unexpected keyword '%0'",
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context",
    UnexpectedNewTarget: "new.target can only be used in functions",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits",
    UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",
    UnexpectedReservedWord: "Unexpected reserved word '%0'",
    UnexpectedSuper: "super is only allowed in object methods and classes",
    UnexpectedToken: "Unexpected token '%0'",
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "import can only be used in import() or import.meta",
    UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1",
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties",
    UnsupportedSuper: "super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])",
    UnterminatedComment: "Unterminated comment",
    UnterminatedRegExp: "Unterminated regular expression",
    UnterminatedString: "Unterminated string constant",
    UnterminatedTemplate: "Unterminated template",
    VarRedeclaration: "Identifier '%0' has already been declared",
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator",
    YieldInParameter: "yield is not allowed in generator parameters",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0"
  });

  class ParserError extends CommentsParser {
    getLocationForPosition(pos) {
      let loc;
      if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);
      return loc;
    }

    raise(pos, errorTemplate, ...params) {
      return this.raiseWithData(pos, undefined, errorTemplate, ...params);
    }

    raiseWithData(pos, data, errorTemplate, ...params) {
      const loc = this.getLocationForPosition(pos);
      const message = errorTemplate.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;
      return this._raise(Object.assign({
        loc,
        pos
      }, data), message);
    }

    _raise(errorContext, message) {
      const err = new SyntaxError(message);
      Object.assign(err, errorContext);

      if (this.options.errorRecovery) {
        if (!this.isLookahead) this.state.errors.push(err);
        return err;
      } else {
        throw err;
      }
    }

  }

  function isSimpleProperty(node) {
    return node != null && node.type === "Property" && node.kind === "init" && node.method === false;
  }

  var estree = (superClass => class extends superClass {
    estreeParseRegExpLiteral({
      pattern,
      flags
    }) {
      let regex = null;

      try {
        regex = new RegExp(pattern, flags);
      } catch (e) {}

      const node = this.estreeParseLiteral(regex);
      node.regex = {
        pattern,
        flags
      };
      return node;
    }

    estreeParseBigIntLiteral(value) {
      const bigInt = typeof BigInt !== "undefined" ? BigInt(value) : null;
      const node = this.estreeParseLiteral(bigInt);
      node.bigint = String(node.value || value);
      return node;
    }

    estreeParseDecimalLiteral(value) {
      const decimal = null;
      const node = this.estreeParseLiteral(decimal);
      node.decimal = String(node.value || value);
      return node;
    }

    estreeParseLiteral(value) {
      return this.parseLiteral(value, "Literal");
    }

    directiveToStmt(directive) {
      const directiveLiteral = directive.value;
      const stmt = this.startNodeAt(directive.start, directive.loc.start);
      const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
      expression.value = directiveLiteral.value;
      expression.raw = directiveLiteral.extra.raw;
      stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
      stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
      return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
    }

    initFunction(node, isAsync) {
      super.initFunction(node, isAsync);
      node.expression = false;
    }

    checkDeclaration(node) {
      if (isSimpleProperty(node)) {
        this.checkDeclaration(node.value);
      } else {
        super.checkDeclaration(node);
      }
    }

    checkGetterSetterParams(method) {
      const prop = method;
      const paramCount = prop.kind === "get" ? 0 : 1;
      const start = prop.start;

      if (prop.value.params.length !== paramCount) {
        if (method.kind === "get") {
          this.raise(start, ErrorMessages.BadGetterArity);
        } else {
          this.raise(start, ErrorMessages.BadSetterArity);
        }
      } else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
        this.raise(start, ErrorMessages.BadSetterRestParameter);
      }
    }

    checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription, disallowLetBinding) {
      switch (expr.type) {
        case "ObjectPattern":
          expr.properties.forEach(prop => {
            this.checkLVal(prop.type === "Property" ? prop.value : prop, bindingType, checkClashes, "object destructuring pattern", disallowLetBinding);
          });
          break;

        default:
          super.checkLVal(expr, bindingType, checkClashes, contextDescription, disallowLetBinding);
      }
    }

    checkProto(prop, isRecord, protoRef, refExpressionErrors) {
      if (prop.method) {
        return;
      }

      super.checkProto(prop, isRecord, protoRef, refExpressionErrors);
    }

    isValidDirective(stmt) {
      var _stmt$expression$extr;

      return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) == null ? void 0 : _stmt$expression$extr.parenthesized);
    }

    stmtToDirective(stmt) {
      const directive = super.stmtToDirective(stmt);
      const value = stmt.expression.value;
      directive.value.value = value;
      return directive;
    }

    parseBlockBody(node, allowDirectives, topLevel, end) {
      super.parseBlockBody(node, allowDirectives, topLevel, end);
      const directiveStatements = node.directives.map(d => this.directiveToStmt(d));
      node.body = directiveStatements.concat(node.body);
      delete node.directives;
    }

    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);

      if (method.typeParameters) {
        method.value.typeParameters = method.typeParameters;
        delete method.typeParameters;
      }

      classBody.body.push(method);
    }

    parseExprAtom(refExpressionErrors) {
      switch (this.state.type) {
        case types.num:
        case types.string:
          return this.estreeParseLiteral(this.state.value);

        case types.regexp:
          return this.estreeParseRegExpLiteral(this.state.value);

        case types.bigint:
          return this.estreeParseBigIntLiteral(this.state.value);

        case types.decimal:
          return this.estreeParseDecimalLiteral(this.state.value);

        case types._null:
          return this.estreeParseLiteral(null);

        case types._true:
          return this.estreeParseLiteral(true);

        case types._false:
          return this.estreeParseLiteral(false);

        default:
          return super.parseExprAtom(refExpressionErrors);
      }
    }

    parseLiteral(value, type, startPos, startLoc) {
      const node = super.parseLiteral(value, type, startPos, startLoc);
      node.raw = node.extra.raw;
      delete node.extra;
      return node;
    }

    parseFunctionBody(node, allowExpression, isMethod = false) {
      super.parseFunctionBody(node, allowExpression, isMethod);
      node.expression = node.body.type !== "BlockStatement";
    }

    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
      let funcNode = this.startNode();
      funcNode.kind = node.kind;
      funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
      funcNode.type = "FunctionExpression";
      delete funcNode.kind;
      node.value = funcNode;
      type = type === "ClassMethod" ? "MethodDefinition" : type;
      return this.finishNode(node, type);
    }

    parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);

      if (node) {
        node.type = "Property";
        if (node.kind === "method") node.kind = "init";
        node.shorthand = false;
      }

      return node;
    }

    parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
      const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);

      if (node) {
        node.kind = "init";
        node.type = "Property";
      }

      return node;
    }

    toAssignable(node) {
      if (isSimpleProperty(node)) {
        this.toAssignable(node.value);
        return node;
      }

      return super.toAssignable(node);
    }

    toAssignableObjectExpressionProp(prop, isLast) {
      if (prop.kind === "get" || prop.kind === "set") {
        throw this.raise(prop.key.start, ErrorMessages.PatternHasAccessor);
      } else if (prop.method) {
        throw this.raise(prop.key.start, ErrorMessages.PatternHasMethod);
      } else {
        super.toAssignableObjectExpressionProp(prop, isLast);
      }
    }

    finishCallExpression(node, optional) {
      super.finishCallExpression(node, optional);

      if (node.callee.type === "Import") {
        node.type = "ImportExpression";
        node.source = node.arguments[0];
        delete node.arguments;
        delete node.callee;
      }

      return node;
    }

    toReferencedListDeep(exprList, isParenthesizedExpr) {
      if (!exprList) {
        return;
      }

      super.toReferencedListDeep(exprList, isParenthesizedExpr);
    }

    parseExport(node) {
      super.parseExport(node);

      switch (node.type) {
        case "ExportAllDeclaration":
          node.exported = null;
          break;

        case "ExportNamedDeclaration":
          if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
            node.type = "ExportAllDeclaration";
            node.exported = node.specifiers[0].exported;
            delete node.specifiers;
          }

          break;
      }

      return node;
    }

    parseSubscript(base, startPos, startLoc, noCalls, state) {
      const node = super.parseSubscript(base, startPos, startLoc, noCalls, state);

      if (state.optionalChainMember) {
        if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
          node.type = node.type.substring(8);
        }

        if (state.stop) {
          const chain = this.startNodeAtNode(node);
          chain.expression = node;
          return this.finishNode(chain, "ChainExpression");
        }
      } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
        node.optional = false;
      }

      return node;
    }

  });

  class TokContext {
    constructor(token, isExpr, preserveSpace, override) {
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
    }

  }
  const types$1 = {
    braceStatement: new TokContext("{", false),
    braceExpression: new TokContext("{", true),
    recordExpression: new TokContext("#{", true),
    templateQuasi: new TokContext("${", false),
    parenStatement: new TokContext("(", false),
    parenExpression: new TokContext("(", true),
    template: new TokContext("`", true, true, p => p.readTmplToken()),
    functionExpression: new TokContext("function", true),
    functionStatement: new TokContext("function", false)
  };

  types.parenR.updateContext = types.braceR.updateContext = function () {
    if (this.state.context.length === 1) {
      this.state.exprAllowed = true;
      return;
    }

    let out = this.state.context.pop();

    if (out === types$1.braceStatement && this.curContext().token === "function") {
      out = this.state.context.pop();
    }

    this.state.exprAllowed = !out.isExpr;
  };

  types.name.updateContext = function (prevType) {
    let allowed = false;

    if (prevType !== types.dot) {
      if (this.state.value === "of" && !this.state.exprAllowed && prevType !== types._function && prevType !== types._class || this.state.value === "yield" && this.prodParam.hasYield) {
        allowed = true;
      }
    }

    this.state.exprAllowed = allowed;

    if (this.state.isIterator) {
      this.state.isIterator = false;
    }
  };

  types.braceL.updateContext = function (prevType) {
    this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);
    this.state.exprAllowed = true;
  };

  types.dollarBraceL.updateContext = function () {
    this.state.context.push(types$1.templateQuasi);
    this.state.exprAllowed = true;
  };

  types.parenL.updateContext = function (prevType) {
    const statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
    this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);
    this.state.exprAllowed = true;
  };

  types.incDec.updateContext = function () {};

  types._function.updateContext = types._class.updateContext = function (prevType) {
    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && this.hasPrecedingLineBreak()) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
      this.state.context.push(types$1.functionExpression);
    } else {
      this.state.context.push(types$1.functionStatement);
    }

    this.state.exprAllowed = false;
  };

  types.backQuote.updateContext = function () {
    if (this.curContext() === types$1.template) {
      this.state.context.pop();
    } else {
      this.state.context.push(types$1.template);
    }

    this.state.exprAllowed = false;
  };

  types.braceHashL.updateContext = function () {
    this.state.context.push(types$1.recordExpression);
    this.state.exprAllowed = true;
  };

  let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  let nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
  const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
  const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

  function isInAstralSet(code, set) {
    let pos = 0x10000;

    for (let i = 0, length = set.length; i < length; i += 2) {
      pos += set[i];
      if (pos > code) return false;
      pos += set[i + 1];
      if (pos >= code) return true;
    }

    return false;
  }

  function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }

    return isInAstralSet(code, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
    }

    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }

  const reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  const keywords$1 = new Set(reservedWords.keyword);
  const reservedWordsStrictSet = new Set(reservedWords.strict);
  const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }
  function isKeyword(word) {
    return keywords$1.has(word);
  }

  const keywordRelationalOperator = /^in(stanceof)?$/;
  function isIteratorStart(current, next) {
    return current === 64 && next === 64;
  }

  const reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
  const FlowErrors = Object.freeze({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module",
    AssignReservedType: "Cannot overwrite reserved type %0",
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement",
    EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
    EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
    EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
    EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
    EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
    EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
    EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
    EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
    EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
    EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
    EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions",
    InexactVariance: "Explicit inexact syntax cannot have variance",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment",
    OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.",
    SpreadVariance: "Spread properties cannot have variance",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object",
    UnexpectedReservedType: "Unexpected reserved type %0",
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint"',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`",
    UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead",
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module",
    UnterminatedFlowComment: "Unterminated flow-comment"
  });

  function isEsModuleType(bodyElement) {
    return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
  }

  function hasTypeImportKind(node) {
    return node.importKind === "type" || node.importKind === "typeof";
  }

  function isMaybeDefaultImport(state) {
    return (state.type === types.name || !!state.type.keyword) && state.value !== "from";
  }

  const exportSuggestions = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };

  function partition(list, test) {
    const list1 = [];
    const list2 = [];

    for (let i = 0; i < list.length; i++) {
      (test(list[i], i, list) ? list1 : list2).push(list[i]);
    }

    return [list1, list2];
  }

  const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
  var flow = (superClass => class extends superClass {
    constructor(options, input) {
      super(options, input);
      this.flowPragma = undefined;
    }

    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }

    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }

    finishToken(type, val) {
      if (type !== types.string && type !== types.semi && type !== types.interpreterDirective) {
        if (this.flowPragma === undefined) {
          this.flowPragma = null;
        }
      }

      return super.finishToken(type, val);
    }

    addComment(comment) {
      if (this.flowPragma === undefined) {
        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);

        if (!matches) ; else if (matches[1] === "flow") {
          this.flowPragma = "flow";
        } else if (matches[1] === "noflow") {
          this.flowPragma = "noflow";
        } else {
          throw new Error("Unexpected flow pragma");
        }
      }

      return super.addComment(comment);
    }

    flowParseTypeInitialiser(tok) {
      const oldInType = this.state.inType;
      this.state.inType = true;
      this.expect(tok || types.colon);
      const type = this.flowParseType();
      this.state.inType = oldInType;
      return type;
    }

    flowParsePredicate() {
      const node = this.startNode();
      const moduloLoc = this.state.startLoc;
      const moduloPos = this.state.start;
      this.expect(types.modulo);
      const checksLoc = this.state.startLoc;
      this.expectContextual("checks");

      if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {
        this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);
      }

      if (this.eat(types.parenL)) {
        node.value = this.parseExpression();
        this.expect(types.parenR);
        return this.finishNode(node, "DeclaredPredicate");
      } else {
        return this.finishNode(node, "InferredPredicate");
      }
    }

    flowParseTypeAndPredicateInitialiser() {
      const oldInType = this.state.inType;
      this.state.inType = true;
      this.expect(types.colon);
      let type = null;
      let predicate = null;

      if (this.match(types.modulo)) {
        this.state.inType = oldInType;
        predicate = this.flowParsePredicate();
      } else {
        type = this.flowParseType();
        this.state.inType = oldInType;

        if (this.match(types.modulo)) {
          predicate = this.flowParsePredicate();
        }
      }

      return [type, predicate];
    }

    flowParseDeclareClass(node) {
      this.next();
      this.flowParseInterfaceish(node, true);
      return this.finishNode(node, "DeclareClass");
    }

    flowParseDeclareFunction(node) {
      this.next();
      const id = node.id = this.parseIdentifier();
      const typeNode = this.startNode();
      const typeContainer = this.startNode();

      if (this.isRelational("<")) {
        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        typeNode.typeParameters = null;
      }

      this.expect(types.parenL);
      const tmp = this.flowParseFunctionTypeParams();
      typeNode.params = tmp.params;
      typeNode.rest = tmp.rest;
      this.expect(types.parenR);
      [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
      typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
      id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
      this.resetEndLocation(id);
      this.semicolon();
      return this.finishNode(node, "DeclareFunction");
    }

    flowParseDeclare(node, insideModule) {
      if (this.match(types._class)) {
        return this.flowParseDeclareClass(node);
      } else if (this.match(types._function)) {
        return this.flowParseDeclareFunction(node);
      } else if (this.match(types._var)) {
        return this.flowParseDeclareVariable(node);
      } else if (this.eatContextual("module")) {
        if (this.match(types.dot)) {
          return this.flowParseDeclareModuleExports(node);
        } else {
          if (insideModule) {
            this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);
          }

          return this.flowParseDeclareModule(node);
        }
      } else if (this.isContextual("type")) {
        return this.flowParseDeclareTypeAlias(node);
      } else if (this.isContextual("opaque")) {
        return this.flowParseDeclareOpaqueType(node);
      } else if (this.isContextual("interface")) {
        return this.flowParseDeclareInterface(node);
      } else if (this.match(types._export)) {
        return this.flowParseDeclareExportDeclaration(node, insideModule);
      } else {
        throw this.unexpected();
      }
    }

    flowParseDeclareVariable(node) {
      this.next();
      node.id = this.flowParseTypeAnnotatableIdentifier(true);
      this.scope.declareName(node.id.name, BIND_VAR, node.id.start);
      this.semicolon();
      return this.finishNode(node, "DeclareVariable");
    }

    flowParseDeclareModule(node) {
      this.scope.enter(SCOPE_OTHER);

      if (this.match(types.string)) {
        node.id = this.parseExprAtom();
      } else {
        node.id = this.parseIdentifier();
      }

      const bodyNode = node.body = this.startNode();
      const body = bodyNode.body = [];
      this.expect(types.braceL);

      while (!this.match(types.braceR)) {
        let bodyNode = this.startNode();

        if (this.match(types._import)) {
          this.next();

          if (!this.isContextual("type") && !this.match(types._typeof)) {
            this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);
          }

          this.parseImport(bodyNode);
        } else {
          this.expectContextual("declare", FlowErrors.UnsupportedStatementInDeclareModule);
          bodyNode = this.flowParseDeclare(bodyNode, true);
        }

        body.push(bodyNode);
      }

      this.scope.exit();
      this.expect(types.braceR);
      this.finishNode(bodyNode, "BlockStatement");
      let kind = null;
      let hasModuleExport = false;
      body.forEach(bodyElement => {
        if (isEsModuleType(bodyElement)) {
          if (kind === "CommonJS") {
            this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
          }

          kind = "ES";
        } else if (bodyElement.type === "DeclareModuleExports") {
          if (hasModuleExport) {
            this.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);
          }

          if (kind === "ES") {
            this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
          }

          kind = "CommonJS";
          hasModuleExport = true;
        }
      });
      node.kind = kind || "CommonJS";
      return this.finishNode(node, "DeclareModule");
    }

    flowParseDeclareExportDeclaration(node, insideModule) {
      this.expect(types._export);

      if (this.eat(types._default)) {
        if (this.match(types._function) || this.match(types._class)) {
          node.declaration = this.flowParseDeclare(this.startNode());
        } else {
          node.declaration = this.flowParseType();
          this.semicolon();
        }

        node.default = true;
        return this.finishNode(node, "DeclareExportDeclaration");
      } else {
        if (this.match(types._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !insideModule) {
          const label = this.state.value;
          const suggestion = exportSuggestions[label];
          throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);
        }

        if (this.match(types._var) || this.match(types._function) || this.match(types._class) || this.isContextual("opaque")) {
            node.declaration = this.flowParseDeclare(this.startNode());
            node.default = false;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else if (this.match(types.star) || this.match(types.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) {
            node = this.parseExport(node);

            if (node.type === "ExportNamedDeclaration") {
              node.type = "ExportDeclaration";
              node.default = false;
              delete node.exportKind;
            }

            node.type = "Declare" + node.type;
            return node;
          }
      }

      throw this.unexpected();
    }

    flowParseDeclareModuleExports(node) {
      this.next();
      this.expectContextual("exports");
      node.typeAnnotation = this.flowParseTypeAnnotation();
      this.semicolon();
      return this.finishNode(node, "DeclareModuleExports");
    }

    flowParseDeclareTypeAlias(node) {
      this.next();
      this.flowParseTypeAlias(node);
      node.type = "DeclareTypeAlias";
      return node;
    }

    flowParseDeclareOpaqueType(node) {
      this.next();
      this.flowParseOpaqueType(node, true);
      node.type = "DeclareOpaqueType";
      return node;
    }

    flowParseDeclareInterface(node) {
      this.next();
      this.flowParseInterfaceish(node);
      return this.finishNode(node, "DeclareInterface");
    }

    flowParseInterfaceish(node, isClass = false) {
      node.id = this.flowParseRestrictedIdentifier(!isClass, true);
      this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);

      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }

      node.extends = [];
      node.implements = [];
      node.mixins = [];

      if (this.eat(types._extends)) {
        do {
          node.extends.push(this.flowParseInterfaceExtends());
        } while (!isClass && this.eat(types.comma));
      }

      if (this.isContextual("mixins")) {
        this.next();

        do {
          node.mixins.push(this.flowParseInterfaceExtends());
        } while (this.eat(types.comma));
      }

      if (this.isContextual("implements")) {
        this.next();

        do {
          node.implements.push(this.flowParseInterfaceExtends());
        } while (this.eat(types.comma));
      }

      node.body = this.flowParseObjectType({
        allowStatic: isClass,
        allowExact: false,
        allowSpread: false,
        allowProto: isClass,
        allowInexact: false
      });
    }

    flowParseInterfaceExtends() {
      const node = this.startNode();
      node.id = this.flowParseQualifiedTypeIdentifier();

      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterInstantiation();
      } else {
        node.typeParameters = null;
      }

      return this.finishNode(node, "InterfaceExtends");
    }

    flowParseInterface(node) {
      this.flowParseInterfaceish(node);
      return this.finishNode(node, "InterfaceDeclaration");
    }

    checkNotUnderscore(word) {
      if (word === "_") {
        this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);
      }
    }

    checkReservedType(word, startLoc, declaration) {
      if (!reservedTypes.has(word)) return;
      this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);
    }

    flowParseRestrictedIdentifier(liberal, declaration) {
      this.checkReservedType(this.state.value, this.state.start, declaration);
      return this.parseIdentifier(liberal);
    }

    flowParseTypeAlias(node) {
      node.id = this.flowParseRestrictedIdentifier(false, true);
      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }

      node.right = this.flowParseTypeInitialiser(types.eq);
      this.semicolon();
      return this.finishNode(node, "TypeAlias");
    }

    flowParseOpaqueType(node, declare) {
      this.expectContextual("type");
      node.id = this.flowParseRestrictedIdentifier(true, true);
      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }

      node.supertype = null;

      if (this.match(types.colon)) {
        node.supertype = this.flowParseTypeInitialiser(types.colon);
      }

      node.impltype = null;

      if (!declare) {
        node.impltype = this.flowParseTypeInitialiser(types.eq);
      }

      this.semicolon();
      return this.finishNode(node, "OpaqueType");
    }

    flowParseTypeParameter(requireDefault = false) {
      const nodeStart = this.state.start;
      const node = this.startNode();
      const variance = this.flowParseVariance();
      const ident = this.flowParseTypeAnnotatableIdentifier();
      node.name = ident.name;
      node.variance = variance;
      node.bound = ident.typeAnnotation;

      if (this.match(types.eq)) {
        this.eat(types.eq);
        node.default = this.flowParseType();
      } else {
        if (requireDefault) {
          this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);
        }
      }

      return this.finishNode(node, "TypeParameter");
    }

    flowParseTypeParameterDeclaration() {
      const oldInType = this.state.inType;
      const node = this.startNode();
      node.params = [];
      this.state.inType = true;

      if (this.isRelational("<") || this.match(types.jsxTagStart)) {
        this.next();
      } else {
        this.unexpected();
      }

      let defaultRequired = false;

      do {
        const typeParameter = this.flowParseTypeParameter(defaultRequired);
        node.params.push(typeParameter);

        if (typeParameter.default) {
          defaultRequired = true;
        }

        if (!this.isRelational(">")) {
          this.expect(types.comma);
        }
      } while (!this.isRelational(">"));

      this.expectRelational(">");
      this.state.inType = oldInType;
      return this.finishNode(node, "TypeParameterDeclaration");
    }

    flowParseTypeParameterInstantiation() {
      const node = this.startNode();
      const oldInType = this.state.inType;
      node.params = [];
      this.state.inType = true;
      this.expectRelational("<");
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = false;

      while (!this.isRelational(">")) {
        node.params.push(this.flowParseType());

        if (!this.isRelational(">")) {
          this.expect(types.comma);
        }
      }

      this.state.noAnonFunctionType = oldNoAnonFunctionType;
      this.expectRelational(">");
      this.state.inType = oldInType;
      return this.finishNode(node, "TypeParameterInstantiation");
    }

    flowParseTypeParameterInstantiationCallOrNew() {
      const node = this.startNode();
      const oldInType = this.state.inType;
      node.params = [];
      this.state.inType = true;
      this.expectRelational("<");

      while (!this.isRelational(">")) {
        node.params.push(this.flowParseTypeOrImplicitInstantiation());

        if (!this.isRelational(">")) {
          this.expect(types.comma);
        }
      }

      this.expectRelational(">");
      this.state.inType = oldInType;
      return this.finishNode(node, "TypeParameterInstantiation");
    }

    flowParseInterfaceType() {
      const node = this.startNode();
      this.expectContextual("interface");
      node.extends = [];

      if (this.eat(types._extends)) {
        do {
          node.extends.push(this.flowParseInterfaceExtends());
        } while (this.eat(types.comma));
      }

      node.body = this.flowParseObjectType({
        allowStatic: false,
        allowExact: false,
        allowSpread: false,
        allowProto: false,
        allowInexact: false
      });
      return this.finishNode(node, "InterfaceTypeAnnotation");
    }

    flowParseObjectPropertyKey() {
      return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
    }

    flowParseObjectTypeIndexer(node, isStatic, variance) {
      node.static = isStatic;

      if (this.lookahead().type === types.colon) {
        node.id = this.flowParseObjectPropertyKey();
        node.key = this.flowParseTypeInitialiser();
      } else {
        node.id = null;
        node.key = this.flowParseType();
      }

      this.expect(types.bracketR);
      node.value = this.flowParseTypeInitialiser();
      node.variance = variance;
      return this.finishNode(node, "ObjectTypeIndexer");
    }

    flowParseObjectTypeInternalSlot(node, isStatic) {
      node.static = isStatic;
      node.id = this.flowParseObjectPropertyKey();
      this.expect(types.bracketR);
      this.expect(types.bracketR);

      if (this.isRelational("<") || this.match(types.parenL)) {
        node.method = true;
        node.optional = false;
        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
      } else {
        node.method = false;

        if (this.eat(types.question)) {
          node.optional = true;
        }

        node.value = this.flowParseTypeInitialiser();
      }

      return this.finishNode(node, "ObjectTypeInternalSlot");
    }

    flowParseObjectTypeMethodish(node) {
      node.params = [];
      node.rest = null;
      node.typeParameters = null;

      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }

      this.expect(types.parenL);

      while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
        node.params.push(this.flowParseFunctionTypeParam());

        if (!this.match(types.parenR)) {
          this.expect(types.comma);
        }
      }

      if (this.eat(types.ellipsis)) {
        node.rest = this.flowParseFunctionTypeParam();
      }

      this.expect(types.parenR);
      node.returnType = this.flowParseTypeInitialiser();
      return this.finishNode(node, "FunctionTypeAnnotation");
    }

    flowParseObjectTypeCallProperty(node, isStatic) {
      const valueNode = this.startNode();
      node.static = isStatic;
      node.value = this.flowParseObjectTypeMethodish(valueNode);
      return this.finishNode(node, "ObjectTypeCallProperty");
    }

    flowParseObjectType({
      allowStatic,
      allowExact,
      allowSpread,
      allowProto,
      allowInexact
    }) {
      const oldInType = this.state.inType;
      this.state.inType = true;
      const nodeStart = this.startNode();
      nodeStart.callProperties = [];
      nodeStart.properties = [];
      nodeStart.indexers = [];
      nodeStart.internalSlots = [];
      let endDelim;
      let exact;
      let inexact = false;

      if (allowExact && this.match(types.braceBarL)) {
        this.expect(types.braceBarL);
        endDelim = types.braceBarR;
        exact = true;
      } else {
        this.expect(types.braceL);
        endDelim = types.braceR;
        exact = false;
      }

      nodeStart.exact = exact;

      while (!this.match(endDelim)) {
        let isStatic = false;
        let protoStart = null;
        let inexactStart = null;
        const node = this.startNode();

        if (allowProto && this.isContextual("proto")) {
          const lookahead = this.lookahead();

          if (lookahead.type !== types.colon && lookahead.type !== types.question) {
            this.next();
            protoStart = this.state.start;
            allowStatic = false;
          }
        }

        if (allowStatic && this.isContextual("static")) {
          const lookahead = this.lookahead();

          if (lookahead.type !== types.colon && lookahead.type !== types.question) {
            this.next();
            isStatic = true;
          }
        }

        const variance = this.flowParseVariance();

        if (this.eat(types.bracketL)) {
          if (protoStart != null) {
            this.unexpected(protoStart);
          }

          if (this.eat(types.bracketL)) {
            if (variance) {
              this.unexpected(variance.start);
            }

            nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
          } else {
            nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
          }
        } else if (this.match(types.parenL) || this.isRelational("<")) {
          if (protoStart != null) {
            this.unexpected(protoStart);
          }

          if (variance) {
            this.unexpected(variance.start);
          }

          nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
        } else {
          let kind = "init";

          if (this.isContextual("get") || this.isContextual("set")) {
            const lookahead = this.lookahead();

            if (lookahead.type === types.name || lookahead.type === types.string || lookahead.type === types.num) {
              kind = this.state.value;
              this.next();
            }
          }

          const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);

          if (propOrInexact === null) {
            inexact = true;
            inexactStart = this.state.lastTokStart;
          } else {
            nodeStart.properties.push(propOrInexact);
          }
        }

        this.flowObjectTypeSemicolon();

        if (inexactStart && !this.match(types.braceR) && !this.match(types.braceBarR)) {
          this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);
        }
      }

      this.expect(endDelim);

      if (allowSpread) {
        nodeStart.inexact = inexact;
      }

      const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
      this.state.inType = oldInType;
      return out;
    }

    flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {
      if (this.eat(types.ellipsis)) {
        const isInexactToken = this.match(types.comma) || this.match(types.semi) || this.match(types.braceR) || this.match(types.braceBarR);

        if (isInexactToken) {
          if (!allowSpread) {
            this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);
          } else if (!allowInexact) {
            this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);
          }

          if (variance) {
            this.raise(variance.start, FlowErrors.InexactVariance);
          }

          return null;
        }

        if (!allowSpread) {
          this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);
        }

        if (protoStart != null) {
          this.unexpected(protoStart);
        }

        if (variance) {
          this.raise(variance.start, FlowErrors.SpreadVariance);
        }

        node.argument = this.flowParseType();
        return this.finishNode(node, "ObjectTypeSpreadProperty");
      } else {
        node.key = this.flowParseObjectPropertyKey();
        node.static = isStatic;
        node.proto = protoStart != null;
        node.kind = kind;
        let optional = false;

        if (this.isRelational("<") || this.match(types.parenL)) {
          node.method = true;

          if (protoStart != null) {
            this.unexpected(protoStart);
          }

          if (variance) {
            this.unexpected(variance.start);
          }

          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));

          if (kind === "get" || kind === "set") {
            this.flowCheckGetterSetterParams(node);
          }
        } else {
          if (kind !== "init") this.unexpected();
          node.method = false;

          if (this.eat(types.question)) {
            optional = true;
          }

          node.value = this.flowParseTypeInitialiser();
          node.variance = variance;
        }

        node.optional = optional;
        return this.finishNode(node, "ObjectTypeProperty");
      }
    }

    flowCheckGetterSetterParams(property) {
      const paramCount = property.kind === "get" ? 0 : 1;
      const start = property.start;
      const length = property.value.params.length + (property.value.rest ? 1 : 0);

      if (length !== paramCount) {
        if (property.kind === "get") {
          this.raise(start, ErrorMessages.BadGetterArity);
        } else {
          this.raise(start, ErrorMessages.BadSetterArity);
        }
      }

      if (property.kind === "set" && property.value.rest) {
        this.raise(start, ErrorMessages.BadSetterRestParameter);
      }
    }

    flowObjectTypeSemicolon() {
      if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {
        this.unexpected();
      }
    }

    flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
      startPos = startPos || this.state.start;
      startLoc = startLoc || this.state.startLoc;
      let node = id || this.flowParseRestrictedIdentifier(true);

      while (this.eat(types.dot)) {
        const node2 = this.startNodeAt(startPos, startLoc);
        node2.qualification = node;
        node2.id = this.flowParseRestrictedIdentifier(true);
        node = this.finishNode(node2, "QualifiedTypeIdentifier");
      }

      return node;
    }

    flowParseGenericType(startPos, startLoc, id) {
      const node = this.startNodeAt(startPos, startLoc);
      node.typeParameters = null;
      node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterInstantiation();
      }

      return this.finishNode(node, "GenericTypeAnnotation");
    }

    flowParseTypeofType() {
      const node = this.startNode();
      this.expect(types._typeof);
      node.argument = this.flowParsePrimaryType();
      return this.finishNode(node, "TypeofTypeAnnotation");
    }

    flowParseTupleType() {
      const node = this.startNode();
      node.types = [];
      this.expect(types.bracketL);

      while (this.state.pos < this.length && !this.match(types.bracketR)) {
        node.types.push(this.flowParseType());
        if (this.match(types.bracketR)) break;
        this.expect(types.comma);
      }

      this.expect(types.bracketR);
      return this.finishNode(node, "TupleTypeAnnotation");
    }

    flowParseFunctionTypeParam() {
      let name = null;
      let optional = false;
      let typeAnnotation = null;
      const node = this.startNode();
      const lh = this.lookahead();

      if (lh.type === types.colon || lh.type === types.question) {
        name = this.parseIdentifier();

        if (this.eat(types.question)) {
          optional = true;
        }

        typeAnnotation = this.flowParseTypeInitialiser();
      } else {
        typeAnnotation = this.flowParseType();
      }

      node.name = name;
      node.optional = optional;
      node.typeAnnotation = typeAnnotation;
      return this.finishNode(node, "FunctionTypeParam");
    }

    reinterpretTypeAsFunctionTypeParam(type) {
      const node = this.startNodeAt(type.start, type.loc.start);
      node.name = null;
      node.optional = false;
      node.typeAnnotation = type;
      return this.finishNode(node, "FunctionTypeParam");
    }

    flowParseFunctionTypeParams(params = []) {
      let rest = null;

      while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
        params.push(this.flowParseFunctionTypeParam());

        if (!this.match(types.parenR)) {
          this.expect(types.comma);
        }
      }

      if (this.eat(types.ellipsis)) {
        rest = this.flowParseFunctionTypeParam();
      }

      return {
        params,
        rest
      };
    }

    flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
      switch (id.name) {
        case "any":
          return this.finishNode(node, "AnyTypeAnnotation");

        case "bool":
        case "boolean":
          return this.finishNode(node, "BooleanTypeAnnotation");

        case "mixed":
          return this.finishNode(node, "MixedTypeAnnotation");

        case "empty":
          return this.finishNode(node, "EmptyTypeAnnotation");

        case "number":
          return this.finishNode(node, "NumberTypeAnnotation");

        case "string":
          return this.finishNode(node, "StringTypeAnnotation");

        case "symbol":
          return this.finishNode(node, "SymbolTypeAnnotation");

        default:
          this.checkNotUnderscore(id.name);
          return this.flowParseGenericType(startPos, startLoc, id);
      }
    }

    flowParsePrimaryType() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const node = this.startNode();
      let tmp;
      let type;
      let isGroupedType = false;
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;

      switch (this.state.type) {
        case types.name:
          if (this.isContextual("interface")) {
            return this.flowParseInterfaceType();
          }

          return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

        case types.braceL:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: true,
            allowProto: false,
            allowInexact: true
          });

        case types.braceBarL:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: true,
            allowSpread: true,
            allowProto: false,
            allowInexact: false
          });

        case types.bracketL:
          this.state.noAnonFunctionType = false;
          type = this.flowParseTupleType();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          return type;

        case types.relational:
          if (this.state.value === "<") {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
            this.expect(types.parenL);
            tmp = this.flowParseFunctionTypeParams();
            node.params = tmp.params;
            node.rest = tmp.rest;
            this.expect(types.parenR);
            this.expect(types.arrow);
            node.returnType = this.flowParseType();
            return this.finishNode(node, "FunctionTypeAnnotation");
          }

          break;

        case types.parenL:
          this.next();

          if (!this.match(types.parenR) && !this.match(types.ellipsis)) {
            if (this.match(types.name)) {
              const token = this.lookahead().type;
              isGroupedType = token !== types.question && token !== types.colon;
            } else {
              isGroupedType = true;
            }
          }

          if (isGroupedType) {
            this.state.noAnonFunctionType = false;
            type = this.flowParseType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;

            if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {
              this.expect(types.parenR);
              return type;
            } else {
              this.eat(types.comma);
            }
          }

          if (type) {
            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
          } else {
            tmp = this.flowParseFunctionTypeParams();
          }

          node.params = tmp.params;
          node.rest = tmp.rest;
          this.expect(types.parenR);
          this.expect(types.arrow);
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");

        case types.string:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

        case types._true:
        case types._false:
          node.value = this.match(types._true);
          this.next();
          return this.finishNode(node, "BooleanLiteralTypeAnnotation");

        case types.plusMin:
          if (this.state.value === "-") {
            this.next();

            if (this.match(types.num)) {
              return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", node.start, node.loc.start);
            }

            if (this.match(types.bigint)) {
              return this.parseLiteral(-this.state.value, "BigIntLiteralTypeAnnotation", node.start, node.loc.start);
            }

            throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);
          }

          throw this.unexpected();

        case types.num:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

        case types.bigint:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");

        case types._void:
          this.next();
          return this.finishNode(node, "VoidTypeAnnotation");

        case types._null:
          this.next();
          return this.finishNode(node, "NullLiteralTypeAnnotation");

        case types._this:
          this.next();
          return this.finishNode(node, "ThisTypeAnnotation");

        case types.star:
          this.next();
          return this.finishNode(node, "ExistsTypeAnnotation");

        default:
          if (this.state.type.keyword === "typeof") {
            return this.flowParseTypeofType();
          } else if (this.state.type.keyword) {
            const label = this.state.type.label;
            this.next();
            return super.createIdentifier(node, label);
          }

      }

      throw this.unexpected();
    }

    flowParsePostfixType() {
      const startPos = this.state.start,
            startLoc = this.state.startLoc;
      let type = this.flowParsePrimaryType();

      while (this.match(types.bracketL) && !this.canInsertSemicolon()) {
        const node = this.startNodeAt(startPos, startLoc);
        node.elementType = type;
        this.expect(types.bracketL);
        this.expect(types.bracketR);
        type = this.finishNode(node, "ArrayTypeAnnotation");
      }

      return type;
    }

    flowParsePrefixType() {
      const node = this.startNode();

      if (this.eat(types.question)) {
        node.typeAnnotation = this.flowParsePrefixType();
        return this.finishNode(node, "NullableTypeAnnotation");
      } else {
        return this.flowParsePostfixType();
      }
    }

    flowParseAnonFunctionWithoutParens() {
      const param = this.flowParsePrefixType();

      if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
        const node = this.startNodeAt(param.start, param.loc.start);
        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
        node.rest = null;
        node.returnType = this.flowParseType();
        node.typeParameters = null;
        return this.finishNode(node, "FunctionTypeAnnotation");
      }

      return param;
    }

    flowParseIntersectionType() {
      const node = this.startNode();
      this.eat(types.bitwiseAND);
      const type = this.flowParseAnonFunctionWithoutParens();
      node.types = [type];

      while (this.eat(types.bitwiseAND)) {
        node.types.push(this.flowParseAnonFunctionWithoutParens());
      }

      return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
    }

    flowParseUnionType() {
      const node = this.startNode();
      this.eat(types.bitwiseOR);
      const type = this.flowParseIntersectionType();
      node.types = [type];

      while (this.eat(types.bitwiseOR)) {
        node.types.push(this.flowParseIntersectionType());
      }

      return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
    }

    flowParseType() {
      const oldInType = this.state.inType;
      this.state.inType = true;
      const type = this.flowParseUnionType();
      this.state.inType = oldInType;
      this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;
      return type;
    }

    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === types.name && this.state.value === "_") {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const node = this.parseIdentifier();
        return this.flowParseGenericType(startPos, startLoc, node);
      } else {
        return this.flowParseType();
      }
    }

    flowParseTypeAnnotation() {
      const node = this.startNode();
      node.typeAnnotation = this.flowParseTypeInitialiser();
      return this.finishNode(node, "TypeAnnotation");
    }

    flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
      const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();

      if (this.match(types.colon)) {
        ident.typeAnnotation = this.flowParseTypeAnnotation();
        this.resetEndLocation(ident);
      }

      return ident;
    }

    typeCastToParameter(node) {
      node.expression.typeAnnotation = node.typeAnnotation;
      this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
      return node.expression;
    }

    flowParseVariance() {
      let variance = null;

      if (this.match(types.plusMin)) {
        variance = this.startNode();

        if (this.state.value === "+") {
          variance.kind = "plus";
        } else {
          variance.kind = "minus";
        }

        this.next();
        this.finishNode(variance, "Variance");
      }

      return variance;
    }

    parseFunctionBody(node, allowExpressionBody, isMethod = false) {
      if (allowExpressionBody) {
        return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
      }

      return super.parseFunctionBody(node, false, isMethod);
    }

    parseFunctionBodyAndFinish(node, type, isMethod = false) {
      if (this.match(types.colon)) {
        const typeNode = this.startNode();
        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
        node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
      }

      super.parseFunctionBodyAndFinish(node, type, isMethod);
    }

    parseStatement(context, topLevel) {
      if (this.state.strict && this.match(types.name) && this.state.value === "interface") {
        const node = this.startNode();
        this.next();
        return this.flowParseInterface(node);
      } else if (this.shouldParseEnums() && this.isContextual("enum")) {
        const node = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(node);
      } else {
        const stmt = super.parseStatement(context, topLevel);

        if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
          this.flowPragma = null;
        }

        return stmt;
      }
    }

    parseExpressionStatement(node, expr) {
      if (expr.type === "Identifier") {
        if (expr.name === "declare") {
          if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {
            return this.flowParseDeclare(node);
          }
        } else if (this.match(types.name)) {
          if (expr.name === "interface") {
            return this.flowParseInterface(node);
          } else if (expr.name === "type") {
            return this.flowParseTypeAlias(node);
          } else if (expr.name === "opaque") {
            return this.flowParseOpaqueType(node, false);
          }
        }
      }

      return super.parseExpressionStatement(node, expr);
    }

    shouldParseExportDeclaration() {
      return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
    }

    isExportDefaultSpecifier() {
      if (this.match(types.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) {
        return false;
      }

      return super.isExportDefaultSpecifier();
    }

    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual("enum")) {
        const node = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(node);
      }

      return super.parseExportDefaultExpression();
    }

    parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {
      if (!this.match(types.question)) return expr;

      if (refNeedsArrowPos) {
        const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));

        if (!result.node) {
          refNeedsArrowPos.start = result.error.pos || this.state.start;
          return expr;
        }

        if (result.error) this.state = result.failState;
        return result.node;
      }

      this.expect(types.question);
      const state = this.state.clone();
      const originalNoArrowAt = this.state.noArrowAt;
      const node = this.startNodeAt(startPos, startLoc);
      let {
        consequent,
        failed
      } = this.tryParseConditionalConsequent();
      let [valid, invalid] = this.getArrowLikeExpressions(consequent);

      if (failed || invalid.length > 0) {
        const noArrowAt = [...originalNoArrowAt];

        if (invalid.length > 0) {
          this.state = state;
          this.state.noArrowAt = noArrowAt;

          for (let i = 0; i < invalid.length; i++) {
            noArrowAt.push(invalid[i].start);
          }

          ({
            consequent,
            failed
          } = this.tryParseConditionalConsequent());
          [valid, invalid] = this.getArrowLikeExpressions(consequent);
        }

        if (failed && valid.length > 1) {
          this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);
        }

        if (failed && valid.length === 1) {
          this.state = state;
          this.state.noArrowAt = noArrowAt.concat(valid[0].start);
          ({
            consequent,
            failed
          } = this.tryParseConditionalConsequent());
        }
      }

      this.getArrowLikeExpressions(consequent, true);
      this.state.noArrowAt = originalNoArrowAt;
      this.expect(types.colon);
      node.test = expr;
      node.consequent = consequent;
      node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined, undefined));
      return this.finishNode(node, "ConditionalExpression");
    }

    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const consequent = this.parseMaybeAssignAllowIn();
      const failed = !this.match(types.colon);
      this.state.noArrowParamsConversionAt.pop();
      return {
        consequent,
        failed
      };
    }

    getArrowLikeExpressions(node, disallowInvalid) {
      const stack = [node];
      const arrows = [];

      while (stack.length !== 0) {
        const node = stack.pop();

        if (node.type === "ArrowFunctionExpression") {
          if (node.typeParameters || !node.returnType) {
            this.finishArrowValidation(node);
          } else {
            arrows.push(node);
          }

          stack.push(node.body);
        } else if (node.type === "ConditionalExpression") {
          stack.push(node.consequent);
          stack.push(node.alternate);
        }
      }

      if (disallowInvalid) {
        arrows.forEach(node => this.finishArrowValidation(node));
        return [arrows, []];
      }

      return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));
    }

    finishArrowValidation(node) {
      var _node$extra;

      this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma);
      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
      super.checkParams(node, false, true);
      this.scope.exit();
    }

    forwardNoArrowParamsConversionAt(node, parse) {
      let result;

      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        result = parse();
        this.state.noArrowParamsConversionAt.pop();
      } else {
        result = parse();
      }

      return result;
    }

    parseParenItem(node, startPos, startLoc) {
      node = super.parseParenItem(node, startPos, startLoc);

      if (this.eat(types.question)) {
        node.optional = true;
        this.resetEndLocation(node);
      }

      if (this.match(types.colon)) {
        const typeCastNode = this.startNodeAt(startPos, startLoc);
        typeCastNode.expression = node;
        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
        return this.finishNode(typeCastNode, "TypeCastExpression");
      }

      return node;
    }

    assertModuleNodeAllowed(node) {
      if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
        return;
      }

      super.assertModuleNodeAllowed(node);
    }

    parseExport(node) {
      const decl = super.parseExport(node);

      if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
        decl.exportKind = decl.exportKind || "value";
      }

      return decl;
    }

    parseExportDeclaration(node) {
      if (this.isContextual("type")) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();

        if (this.match(types.braceL)) {
          node.specifiers = this.parseExportSpecifiers();
          this.parseExportFrom(node);
          return null;
        } else {
          return this.flowParseTypeAlias(declarationNode);
        }
      } else if (this.isContextual("opaque")) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseOpaqueType(declarationNode, false);
      } else if (this.isContextual("interface")) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseInterface(declarationNode);
      } else if (this.shouldParseEnums() && this.isContextual("enum")) {
        node.exportKind = "value";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(declarationNode);
      } else {
        return super.parseExportDeclaration(node);
      }
    }

    eatExportStar(node) {
      if (super.eatExportStar(...arguments)) return true;

      if (this.isContextual("type") && this.lookahead().type === types.star) {
        node.exportKind = "type";
        this.next();
        this.next();
        return true;
      }

      return false;
    }

    maybeParseExportNamespaceSpecifier(node) {
      const pos = this.state.start;
      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);

      if (hasNamespace && node.exportKind === "type") {
        this.unexpected(pos);
      }

      return hasNamespace;
    }

    parseClassId(node, isStatement, optionalId) {
      super.parseClassId(node, isStatement, optionalId);

      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
    }

    parseClassMember(classBody, member, state, constructorAllowsSuper) {
      const pos = this.state.start;

      if (this.isContextual("declare")) {
        if (this.parseClassMemberFromModifier(classBody, member)) {
          return;
        }

        member.declare = true;
      }

      super.parseClassMember(classBody, member, state, constructorAllowsSuper);

      if (member.declare) {
        if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty") {
          this.raise(pos, FlowErrors.DeclareClassElement);
        } else if (member.value) {
          this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);
        }
      }
    }

    getTokenFromCode(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (code === 123 && next === 124) {
        return this.finishOp(types.braceBarL, 2);
      } else if (this.state.inType && (code === 62 || code === 60)) {
        return this.finishOp(types.relational, 1);
      } else if (this.state.inType && code === 63) {
        return this.finishOp(types.question, 1);
      } else if (isIteratorStart(code, next)) {
        this.state.isIterator = true;
        return super.readWord();
      } else {
        return super.getTokenFromCode(code);
      }
    }

    isAssignable(node, isBinding) {
      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
          return true;

        case "ObjectExpression":
          {
            const last = node.properties.length - 1;
            return node.properties.every((prop, i) => {
              return prop.type !== "ObjectMethod" && (i === last || prop.type === "SpreadElement") && this.isAssignable(prop);
            });
          }

        case "ObjectProperty":
          return this.isAssignable(node.value);

        case "SpreadElement":
          return this.isAssignable(node.argument);

        case "ArrayExpression":
          return node.elements.every(element => this.isAssignable(element));

        case "AssignmentExpression":
          return node.operator === "=";

        case "ParenthesizedExpression":
        case "TypeCastExpression":
          return this.isAssignable(node.expression);

        case "MemberExpression":
        case "OptionalMemberExpression":
          return !isBinding;

        default:
          return false;
      }
    }

    toAssignable(node) {
      if (node.type === "TypeCastExpression") {
        return super.toAssignable(this.typeCastToParameter(node));
      } else {
        return super.toAssignable(node);
      }
    }

    toAssignableList(exprList, trailingCommaPos) {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i];

        if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
          exprList[i] = this.typeCastToParameter(expr);
        }
      }

      return super.toAssignableList(exprList, trailingCommaPos);
    }

    toReferencedList(exprList, isParenthesizedExpr) {
      for (let i = 0; i < exprList.length; i++) {
        var _expr$extra;

        const expr = exprList[i];

        if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) == null ? void 0 : _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
          this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);
        }
      }

      return exprList;
    }

    checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription) {
      if (expr.type !== "TypeCastExpression") {
        return super.checkLVal(expr, bindingType, checkClashes, contextDescription);
      }
    }

    parseClassProperty(node) {
      if (this.match(types.colon)) {
        node.typeAnnotation = this.flowParseTypeAnnotation();
      }

      return super.parseClassProperty(node);
    }

    parseClassPrivateProperty(node) {
      if (this.match(types.colon)) {
        node.typeAnnotation = this.flowParseTypeAnnotation();
      }

      return super.parseClassPrivateProperty(node);
    }

    isClassMethod() {
      return this.isRelational("<") || super.isClassMethod();
    }

    isClassProperty() {
      return this.match(types.colon) || super.isClassProperty();
    }

    isNonstaticConstructor(method) {
      return !this.match(types.colon) && super.isNonstaticConstructor(method);
    }

    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      if (method.variance) {
        this.unexpected(method.variance.start);
      }

      delete method.variance;

      if (this.isRelational("<")) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }

      super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
    }

    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      if (method.variance) {
        this.unexpected(method.variance.start);
      }

      delete method.variance;

      if (this.isRelational("<")) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }

      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    }

    parseClassSuper(node) {
      super.parseClassSuper(node);

      if (node.superClass && this.isRelational("<")) {
        node.superTypeParameters = this.flowParseTypeParameterInstantiation();
      }

      if (this.isContextual("implements")) {
        this.next();
        const implemented = node.implements = [];

        do {
          const node = this.startNode();
          node.id = this.flowParseRestrictedIdentifier(true);

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            node.typeParameters = null;
          }

          implemented.push(this.finishNode(node, "ClassImplements"));
        } while (this.eat(types.comma));
      }
    }

    parsePropertyName(node, isPrivateNameAllowed) {
      const variance = this.flowParseVariance();
      const key = super.parsePropertyName(node, isPrivateNameAllowed);
      node.variance = variance;
      return key;
    }

    parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      if (prop.variance) {
        this.unexpected(prop.variance.start);
      }

      delete prop.variance;
      let typeParameters;

      if (this.isRelational("<") && !isAccessor) {
        typeParameters = this.flowParseTypeParameterDeclaration();
        if (!this.match(types.parenL)) this.unexpected();
      }

      super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);

      if (typeParameters) {
        (prop.value || prop).typeParameters = typeParameters;
      }
    }

    parseAssignableListItemTypes(param) {
      if (this.eat(types.question)) {
        if (param.type !== "Identifier") {
          this.raise(param.start, FlowErrors.OptionalBindingPattern);
        }

        param.optional = true;
      }

      if (this.match(types.colon)) {
        param.typeAnnotation = this.flowParseTypeAnnotation();
      }

      this.resetEndLocation(param);
      return param;
    }

    parseMaybeDefault(startPos, startLoc, left) {
      const node = super.parseMaybeDefault(startPos, startLoc, left);

      if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
        this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);
      }

      return node;
    }

    shouldParseDefaultImport(node) {
      if (!hasTypeImportKind(node)) {
        return super.shouldParseDefaultImport(node);
      }

      return isMaybeDefaultImport(this.state);
    }

    parseImportSpecifierLocal(node, specifier, type, contextDescription) {
      specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
      this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);
      node.specifiers.push(this.finishNode(specifier, type));
    }

    maybeParseDefaultImportSpecifier(node) {
      node.importKind = "value";
      let kind = null;

      if (this.match(types._typeof)) {
        kind = "typeof";
      } else if (this.isContextual("type")) {
        kind = "type";
      }

      if (kind) {
        const lh = this.lookahead();

        if (kind === "type" && lh.type === types.star) {
          this.unexpected(lh.start);
        }

        if (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) {
          this.next();
          node.importKind = kind;
        }
      }

      return super.maybeParseDefaultImportSpecifier(node);
    }

    parseImportSpecifier(node) {
      const specifier = this.startNode();
      const firstIdentLoc = this.state.start;
      const firstIdent = this.parseIdentifier(true);
      let specifierTypeKind = null;

      if (firstIdent.name === "type") {
        specifierTypeKind = "type";
      } else if (firstIdent.name === "typeof") {
        specifierTypeKind = "typeof";
      }

      let isBinding = false;

      if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
        const as_ident = this.parseIdentifier(true);

        if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {
          specifier.imported = as_ident;
          specifier.importKind = specifierTypeKind;
          specifier.local = as_ident.__clone();
        } else {
          specifier.imported = firstIdent;
          specifier.importKind = null;
          specifier.local = this.parseIdentifier();
        }
      } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {
        specifier.imported = this.parseIdentifier(true);
        specifier.importKind = specifierTypeKind;

        if (this.eatContextual("as")) {
          specifier.local = this.parseIdentifier();
        } else {
          isBinding = true;
          specifier.local = specifier.imported.__clone();
        }
      } else {
        isBinding = true;
        specifier.imported = firstIdent;
        specifier.importKind = null;
        specifier.local = specifier.imported.__clone();
      }

      const nodeIsTypeImport = hasTypeImportKind(node);
      const specifierIsTypeImport = hasTypeImportKind(specifier);

      if (nodeIsTypeImport && specifierIsTypeImport) {
        this.raise(firstIdentLoc, FlowErrors.ImportTypeShorthandOnlyInPureImport);
      }

      if (nodeIsTypeImport || specifierIsTypeImport) {
        this.checkReservedType(specifier.local.name, specifier.local.start, true);
      }

      if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
        this.checkReservedWord(specifier.local.name, specifier.start, true, true);
      }

      this.checkLVal(specifier.local, BIND_LEXICAL, undefined, "import specifier");
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    }

    parseFunctionParams(node, allowModifiers) {
      const kind = node.kind;

      if (kind !== "get" && kind !== "set" && this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }

      super.parseFunctionParams(node, allowModifiers);
    }

    parseVarId(decl, kind) {
      super.parseVarId(decl, kind);

      if (this.match(types.colon)) {
        decl.id.typeAnnotation = this.flowParseTypeAnnotation();
        this.resetEndLocation(decl.id);
      }
    }

    parseAsyncArrowFromCallExpression(node, call) {
      if (this.match(types.colon)) {
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true;
        node.returnType = this.flowParseTypeAnnotation();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
      }

      return super.parseAsyncArrowFromCallExpression(node, call);
    }

    shouldParseAsyncArrow() {
      return this.match(types.colon) || super.shouldParseAsyncArrow();
    }

    parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
      var _jsx;

      let state = null;
      let jsx;

      if (this.hasPlugin("jsx") && (this.match(types.jsxTagStart) || this.isRelational("<"))) {
        state = this.state.clone();
        jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos), state);
        if (!jsx.error) return jsx.node;
        const {
          context
        } = this.state;

        if (context[context.length - 1] === types$1.j_oTag) {
          context.length -= 2;
        } else if (context[context.length - 1] === types$1.j_expr) {
          context.length -= 1;
        }
      }

      if (((_jsx = jsx) == null ? void 0 : _jsx.error) || this.isRelational("<")) {
        var _jsx2, _jsx3;

        state = state || this.state.clone();
        let typeParameters;
        const arrow = this.tryParse(abort => {
          var _arrowExpression$extr;

          typeParameters = this.flowParseTypeParameterDeclaration();
          const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
            const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos);
            this.resetStartLocationFromNode(result, typeParameters);
            return result;
          });

          if (arrowExpression.type !== "ArrowFunctionExpression" && ((_arrowExpression$extr = arrowExpression.extra) == null ? void 0 : _arrowExpression$extr.parenthesized)) {
            abort();
          }

          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);
          expr.typeParameters = typeParameters;
          this.resetStartLocationFromNode(expr, typeParameters);
          return arrowExpression;
        }, state);
        let arrowExpression = null;

        if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
          if (!arrow.error && !arrow.aborted) {
            if (arrow.node.async) {
              this.raise(typeParameters.start, FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction);
            }

            return arrow.node;
          }

          arrowExpression = arrow.node;
        }

        if ((_jsx2 = jsx) == null ? void 0 : _jsx2.node) {
          this.state = jsx.failState;
          return jsx.node;
        }

        if (arrowExpression) {
          this.state = arrow.failState;
          return arrowExpression;
        }

        if ((_jsx3 = jsx) == null ? void 0 : _jsx3.thrown) throw jsx.error;
        if (arrow.thrown) throw arrow.error;
        throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);
      }

      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos);
    }

    parseArrow(node) {
      if (this.match(types.colon)) {
        const result = this.tryParse(() => {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          const typeNode = this.startNode();
          [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          if (this.canInsertSemicolon()) this.unexpected();
          if (!this.match(types.arrow)) this.unexpected();
          return typeNode;
        });
        if (result.thrown) return null;
        if (result.error) this.state = result.failState;
        node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
      }

      return super.parseArrow(node);
    }

    shouldParseArrow() {
      return this.match(types.colon) || super.shouldParseArrow();
    }

    setArrowFunctionParameters(node, params) {
      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
        node.params = params;
      } else {
        super.setArrowFunctionParameters(node, params);
      }
    }

    checkParams(node, allowDuplicates, isArrowFunction) {
      if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
        return;
      }

      return super.checkParams(...arguments);
    }

    parseParenAndDistinguishExpression(canBeArrow) {
      return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }

    parseSubscripts(base, startPos, startLoc, noCalls) {
      if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
        this.next();
        const node = this.startNodeAt(startPos, startLoc);
        node.callee = base;
        node.arguments = this.parseCallExpressionArguments(types.parenR, false);
        base = this.finishNode(node, "CallExpression");
      } else if (base.type === "Identifier" && base.name === "async" && this.isRelational("<")) {
        const state = this.state.clone();
        const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);
        if (!arrow.error && !arrow.aborted) return arrow.node;
        const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);
        if (result.node && !result.error) return result.node;

        if (arrow.node) {
          this.state = arrow.failState;
          return arrow.node;
        }

        if (result.node) {
          this.state = result.failState;
          return result.node;
        }

        throw arrow.error || result.error;
      }

      return super.parseSubscripts(base, startPos, startLoc, noCalls);
    }

    parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
      if (this.match(types.questionDot) && this.isLookaheadToken_lt()) {
        subscriptState.optionalChainMember = true;

        if (noCalls) {
          subscriptState.stop = true;
          return base;
        }

        this.next();
        const node = this.startNodeAt(startPos, startLoc);
        node.callee = base;
        node.typeArguments = this.flowParseTypeParameterInstantiation();
        this.expect(types.parenL);
        node.arguments = this.parseCallExpressionArguments(types.parenR, false);
        node.optional = true;
        return this.finishCallExpression(node, true);
      } else if (!noCalls && this.shouldParseTypes() && this.isRelational("<")) {
        const node = this.startNodeAt(startPos, startLoc);
        node.callee = base;
        const result = this.tryParse(() => {
          node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
          this.expect(types.parenL);
          node.arguments = this.parseCallExpressionArguments(types.parenR, false);
          if (subscriptState.optionalChainMember) node.optional = false;
          return this.finishCallExpression(node, subscriptState.optionalChainMember);
        });

        if (result.node) {
          if (result.error) this.state = result.failState;
          return result.node;
        }
      }

      return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);
    }

    parseNewArguments(node) {
      let targs = null;

      if (this.shouldParseTypes() && this.isRelational("<")) {
        targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
      }

      node.typeArguments = targs;
      super.parseNewArguments(node);
    }

    parseAsyncArrowWithTypeParameters(startPos, startLoc) {
      const node = this.startNodeAt(startPos, startLoc);
      this.parseFunctionParams(node);
      if (!this.parseArrow(node)) return;
      return this.parseArrowExpression(node, undefined, true);
    }

    readToken_mult_modulo(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (code === 42 && next === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = false;
        this.state.pos += 2;
        this.nextToken();
        return;
      }

      super.readToken_mult_modulo(code);
    }

    readToken_pipe_amp(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (code === 124 && next === 125) {
        this.finishOp(types.braceBarR, 2);
        return;
      }

      super.readToken_pipe_amp(code);
    }

    parseTopLevel(file, program) {
      const fileNode = super.parseTopLevel(file, program);

      if (this.state.hasFlowComment) {
        this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);
      }

      return fileNode;
    }

    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment) {
          this.unexpected(null, FlowErrors.NestedFlowComment);
        }

        this.hasFlowCommentCompletion();
        this.state.pos += this.skipFlowComment();
        this.state.hasFlowComment = true;
        return;
      }

      if (this.state.hasFlowComment) {
        const end = this.input.indexOf("*-/", this.state.pos += 2);

        if (end === -1) {
          throw this.raise(this.state.pos - 2, ErrorMessages.UnterminatedComment);
        }

        this.state.pos = end + 3;
        return;
      }

      super.skipBlockComment();
    }

    skipFlowComment() {
      const {
        pos
      } = this.state;
      let shiftToFirstNonWhiteSpace = 2;

      while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
        shiftToFirstNonWhiteSpace++;
      }

      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);

      if (ch2 === 58 && ch3 === 58) {
        return shiftToFirstNonWhiteSpace + 2;
      }

      if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
        return shiftToFirstNonWhiteSpace + 12;
      }

      if (ch2 === 58 && ch3 !== 58) {
        return shiftToFirstNonWhiteSpace;
      }

      return false;
    }

    hasFlowCommentCompletion() {
      const end = this.input.indexOf("*/", this.state.pos);

      if (end === -1) {
        throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);
      }
    }

    flowEnumErrorBooleanMemberNotInitialized(pos, {
      enumName,
      memberName
    }) {
      this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);
    }

    flowEnumErrorInvalidMemberName(pos, {
      enumName,
      memberName
    }) {
      const suggestion = memberName[0].toUpperCase() + memberName.slice(1);
      this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);
    }

    flowEnumErrorDuplicateMemberName(pos, {
      enumName,
      memberName
    }) {
      this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);
    }

    flowEnumErrorInconsistentMemberValues(pos, {
      enumName
    }) {
      this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);
    }

    flowEnumErrorInvalidExplicitType(pos, {
      enumName,
      suppliedType
    }) {
      return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);
    }

    flowEnumErrorInvalidMemberInitializer(pos, {
      enumName,
      explicitType,
      memberName
    }) {
      let message = null;

      switch (explicitType) {
        case "boolean":
        case "number":
        case "string":
          message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;
          break;

        case "symbol":
          message = FlowErrors.EnumInvalidMemberInitializerSymbolType;
          break;

        default:
          message = FlowErrors.EnumInvalidMemberInitializerUnknownType;
      }

      return this.raise(pos, message, enumName, memberName, explicitType);
    }

    flowEnumErrorNumberMemberNotInitialized(pos, {
      enumName,
      memberName
    }) {
      this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);
    }

    flowEnumErrorStringMemberInconsistentlyInitailized(pos, {
      enumName
    }) {
      this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);
    }

    flowEnumMemberInit() {
      const startPos = this.state.start;

      const endOfInit = () => this.match(types.comma) || this.match(types.braceR);

      switch (this.state.type) {
        case types.num:
          {
            const literal = this.parseLiteral(this.state.value, "NumericLiteral");

            if (endOfInit()) {
              return {
                type: "number",
                pos: literal.start,
                value: literal
              };
            }

            return {
              type: "invalid",
              pos: startPos
            };
          }

        case types.string:
          {
            const literal = this.parseLiteral(this.state.value, "StringLiteral");

            if (endOfInit()) {
              return {
                type: "string",
                pos: literal.start,
                value: literal
              };
            }

            return {
              type: "invalid",
              pos: startPos
            };
          }

        case types._true:
        case types._false:
          {
            const literal = this.parseBooleanLiteral();

            if (endOfInit()) {
              return {
                type: "boolean",
                pos: literal.start,
                value: literal
              };
            }

            return {
              type: "invalid",
              pos: startPos
            };
          }

        default:
          return {
            type: "invalid",
            pos: startPos
          };
      }
    }

    flowEnumMemberRaw() {
      const pos = this.state.start;
      const id = this.parseIdentifier(true);
      const init = this.eat(types.eq) ? this.flowEnumMemberInit() : {
        type: "none",
        pos
      };
      return {
        id,
        init
      };
    }

    flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {
      const {
        explicitType
      } = context;

      if (explicitType === null) {
        return;
      }

      if (explicitType !== expectedType) {
        this.flowEnumErrorInvalidMemberInitializer(pos, context);
      }
    }

    flowEnumMembers({
      enumName,
      explicitType
    }) {
      const seenNames = new Set();
      const members = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      };

      while (!this.match(types.braceR)) {
        const memberNode = this.startNode();
        const {
          id,
          init
        } = this.flowEnumMemberRaw();
        const memberName = id.name;

        if (memberName === "") {
          continue;
        }

        if (/^[a-z]/.test(memberName)) {
          this.flowEnumErrorInvalidMemberName(id.start, {
            enumName,
            memberName
          });
        }

        if (seenNames.has(memberName)) {
          this.flowEnumErrorDuplicateMemberName(id.start, {
            enumName,
            memberName
          });
        }

        seenNames.add(memberName);
        const context = {
          enumName,
          explicitType,
          memberName
        };
        memberNode.id = id;

        switch (init.type) {
          case "boolean":
            {
              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "boolean");
              memberNode.init = init.value;
              members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
              break;
            }

          case "number":
            {
              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "number");
              memberNode.init = init.value;
              members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
              break;
            }

          case "string":
            {
              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "string");
              memberNode.init = init.value;
              members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
              break;
            }

          case "invalid":
            {
              throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);
            }

          case "none":
            {
              switch (explicitType) {
                case "boolean":
                  this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);
                  break;

                case "number":
                  this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);
                  break;

                default:
                  members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
              }
            }
        }

        if (!this.match(types.braceR)) {
          this.expect(types.comma);
        }
      }

      return members;
    }

    flowEnumStringMembers(initializedMembers, defaultedMembers, {
      enumName
    }) {
      if (initializedMembers.length === 0) {
        return defaultedMembers;
      } else if (defaultedMembers.length === 0) {
        return initializedMembers;
      } else if (defaultedMembers.length > initializedMembers.length) {
        for (let _i = 0; _i < initializedMembers.length; _i++) {
          const member = initializedMembers[_i];
          this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
            enumName
          });
        }

        return defaultedMembers;
      } else {
        for (let _i2 = 0; _i2 < defaultedMembers.length; _i2++) {
          const member = defaultedMembers[_i2];
          this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
            enumName
          });
        }

        return initializedMembers;
      }
    }

    flowEnumParseExplicitType({
      enumName
    }) {
      if (this.eatContextual("of")) {
        if (!this.match(types.name)) {
          throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
            enumName,
            suppliedType: null
          });
        }

        const {
          value
        } = this.state;
        this.next();

        if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
          this.flowEnumErrorInvalidExplicitType(this.state.start, {
            enumName,
            suppliedType: value
          });
        }

        return value;
      }

      return null;
    }

    flowEnumBody(node, {
      enumName,
      nameLoc
    }) {
      const explicitType = this.flowEnumParseExplicitType({
        enumName
      });
      this.expect(types.braceL);
      const members = this.flowEnumMembers({
        enumName,
        explicitType
      });

      switch (explicitType) {
        case "boolean":
          node.explicitType = true;
          node.members = members.booleanMembers;
          this.expect(types.braceR);
          return this.finishNode(node, "EnumBooleanBody");

        case "number":
          node.explicitType = true;
          node.members = members.numberMembers;
          this.expect(types.braceR);
          return this.finishNode(node, "EnumNumberBody");

        case "string":
          node.explicitType = true;
          node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
            enumName
          });
          this.expect(types.braceR);
          return this.finishNode(node, "EnumStringBody");

        case "symbol":
          node.members = members.defaultedMembers;
          this.expect(types.braceR);
          return this.finishNode(node, "EnumSymbolBody");

        default:
          {
            const empty = () => {
              node.members = [];
              this.expect(types.braceR);
              return this.finishNode(node, "EnumStringBody");
            };

            node.explicitType = false;
            const boolsLen = members.booleanMembers.length;
            const numsLen = members.numberMembers.length;
            const strsLen = members.stringMembers.length;
            const defaultedLen = members.defaultedMembers.length;

            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
              return empty();
            } else if (!boolsLen && !numsLen) {
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(types.braceR);
              return this.finishNode(node, "EnumStringBody");
            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
              for (let _i3 = 0, _members$defaultedMem = members.defaultedMembers; _i3 < _members$defaultedMem.length; _i3++) {
                const member = _members$defaultedMem[_i3];
                this.flowEnumErrorBooleanMemberNotInitialized(member.start, {
                  enumName,
                  memberName: member.id.name
                });
              }

              node.members = members.booleanMembers;
              this.expect(types.braceR);
              return this.finishNode(node, "EnumBooleanBody");
            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
              for (let _i4 = 0, _members$defaultedMem2 = members.defaultedMembers; _i4 < _members$defaultedMem2.length; _i4++) {
                const member = _members$defaultedMem2[_i4];
                this.flowEnumErrorNumberMemberNotInitialized(member.start, {
                  enumName,
                  memberName: member.id.name
                });
              }

              node.members = members.numberMembers;
              this.expect(types.braceR);
              return this.finishNode(node, "EnumNumberBody");
            } else {
              this.flowEnumErrorInconsistentMemberValues(nameLoc, {
                enumName
              });
              return empty();
            }
          }
      }
    }

    flowParseEnumDeclaration(node) {
      const id = this.parseIdentifier();
      node.id = id;
      node.body = this.flowEnumBody(this.startNode(), {
        enumName: id.name,
        nameLoc: id.start
      });
      return this.finishNode(node, "EnumDeclaration");
    }

    updateContext(prevType) {
      if (this.match(types.name) && this.state.value === "of" && prevType === types.name && this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) === "interface") {
        this.state.exprAllowed = false;
      } else {
        super.updateContext(prevType);
      }
    }

    isLookaheadToken_lt() {
      const next = this.nextTokenStart();

      if (this.input.charCodeAt(next) === 60) {
        const afterNext = this.input.charCodeAt(next + 1);
        return afterNext !== 60 && afterNext !== 61;
      }

      return false;
    }

    maybeUnwrapTypeCastExpression(node) {
      return node.type === "TypeCastExpression" ? node.expression : node;
    }

  });

  const entities = {
    quot: "\u0022",
    amp: "&",
    apos: "\u0027",
    lt: "<",
    gt: ">",
    nbsp: "\u00A0",
    iexcl: "\u00A1",
    cent: "\u00A2",
    pound: "\u00A3",
    curren: "\u00A4",
    yen: "\u00A5",
    brvbar: "\u00A6",
    sect: "\u00A7",
    uml: "\u00A8",
    copy: "\u00A9",
    ordf: "\u00AA",
    laquo: "\u00AB",
    not: "\u00AC",
    shy: "\u00AD",
    reg: "\u00AE",
    macr: "\u00AF",
    deg: "\u00B0",
    plusmn: "\u00B1",
    sup2: "\u00B2",
    sup3: "\u00B3",
    acute: "\u00B4",
    micro: "\u00B5",
    para: "\u00B6",
    middot: "\u00B7",
    cedil: "\u00B8",
    sup1: "\u00B9",
    ordm: "\u00BA",
    raquo: "\u00BB",
    frac14: "\u00BC",
    frac12: "\u00BD",
    frac34: "\u00BE",
    iquest: "\u00BF",
    Agrave: "\u00C0",
    Aacute: "\u00C1",
    Acirc: "\u00C2",
    Atilde: "\u00C3",
    Auml: "\u00C4",
    Aring: "\u00C5",
    AElig: "\u00C6",
    Ccedil: "\u00C7",
    Egrave: "\u00C8",
    Eacute: "\u00C9",
    Ecirc: "\u00CA",
    Euml: "\u00CB",
    Igrave: "\u00CC",
    Iacute: "\u00CD",
    Icirc: "\u00CE",
    Iuml: "\u00CF",
    ETH: "\u00D0",
    Ntilde: "\u00D1",
    Ograve: "\u00D2",
    Oacute: "\u00D3",
    Ocirc: "\u00D4",
    Otilde: "\u00D5",
    Ouml: "\u00D6",
    times: "\u00D7",
    Oslash: "\u00D8",
    Ugrave: "\u00D9",
    Uacute: "\u00DA",
    Ucirc: "\u00DB",
    Uuml: "\u00DC",
    Yacute: "\u00DD",
    THORN: "\u00DE",
    szlig: "\u00DF",
    agrave: "\u00E0",
    aacute: "\u00E1",
    acirc: "\u00E2",
    atilde: "\u00E3",
    auml: "\u00E4",
    aring: "\u00E5",
    aelig: "\u00E6",
    ccedil: "\u00E7",
    egrave: "\u00E8",
    eacute: "\u00E9",
    ecirc: "\u00EA",
    euml: "\u00EB",
    igrave: "\u00EC",
    iacute: "\u00ED",
    icirc: "\u00EE",
    iuml: "\u00EF",
    eth: "\u00F0",
    ntilde: "\u00F1",
    ograve: "\u00F2",
    oacute: "\u00F3",
    ocirc: "\u00F4",
    otilde: "\u00F5",
    ouml: "\u00F6",
    divide: "\u00F7",
    oslash: "\u00F8",
    ugrave: "\u00F9",
    uacute: "\u00FA",
    ucirc: "\u00FB",
    uuml: "\u00FC",
    yacute: "\u00FD",
    thorn: "\u00FE",
    yuml: "\u00FF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  };

  const HEX_NUMBER = /^[\da-fA-F]+$/;
  const DECIMAL_NUMBER = /^\d+$/;
  const JsxErrors = Object.freeze({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression",
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>",
    MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>",
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text",
    UnterminatedJsxContent: "Unterminated JSX contents",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  types$1.j_oTag = new TokContext("<tag", false);
  types$1.j_cTag = new TokContext("</tag", false);
  types$1.j_expr = new TokContext("<tag>...</tag>", true, true);
  types.jsxName = new TokenType("jsxName");
  types.jsxText = new TokenType("jsxText", {
    beforeExpr: true
  });
  types.jsxTagStart = new TokenType("jsxTagStart", {
    startsExpr: true
  });
  types.jsxTagEnd = new TokenType("jsxTagEnd");

  types.jsxTagStart.updateContext = function () {
    this.state.context.push(types$1.j_expr);
    this.state.context.push(types$1.j_oTag);
    this.state.exprAllowed = false;
  };

  types.jsxTagEnd.updateContext = function (prevType) {
    const out = this.state.context.pop();

    if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {
      this.state.context.pop();
      this.state.exprAllowed = this.curContext() === types$1.j_expr;
    } else {
      this.state.exprAllowed = true;
    }
  };

  function isFragment(object) {
    return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
  }

  function getQualifiedJSXName(object) {
    if (object.type === "JSXIdentifier") {
      return object.name;
    }

    if (object.type === "JSXNamespacedName") {
      return object.namespace.name + ":" + object.name.name;
    }

    if (object.type === "JSXMemberExpression") {
      return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }

    throw new Error("Node had unexpected type: " + object.type);
  }

  var jsx = (superClass => class extends superClass {
    jsxReadToken() {
      let out = "";
      let chunkStart = this.state.pos;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);
        }

        const ch = this.input.charCodeAt(this.state.pos);

        switch (ch) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              if (ch === 60 && this.state.exprAllowed) {
                ++this.state.pos;
                return this.finishToken(types.jsxTagStart);
              }

              return super.getTokenFromCode(ch);
            }

            out += this.input.slice(chunkStart, this.state.pos);
            return this.finishToken(types.jsxText, out);

          case 38:
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
            break;

          default:
            if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(true);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }

        }
      }
    }

    jsxReadNewLine(normalizeCRLF) {
      const ch = this.input.charCodeAt(this.state.pos);
      let out;
      ++this.state.pos;

      if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
        ++this.state.pos;
        out = normalizeCRLF ? "\n" : "\r\n";
      } else {
        out = String.fromCharCode(ch);
      }

      ++this.state.curLine;
      this.state.lineStart = this.state.pos;
      return out;
    }

    jsxReadString(quote) {
      let out = "";
      let chunkStart = ++this.state.pos;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        }

        const ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote) break;

        if (ch === 38) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadEntity();
          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadNewLine(false);
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }

      out += this.input.slice(chunkStart, this.state.pos++);
      return this.finishToken(types.string, out);
    }

    jsxReadEntity() {
      let str = "";
      let count = 0;
      let entity;
      let ch = this.input[this.state.pos];
      const startPos = ++this.state.pos;

      while (this.state.pos < this.length && count++ < 10) {
        ch = this.input[this.state.pos++];

        if (ch === ";") {
          if (str[0] === "#") {
            if (str[1] === "x") {
              str = str.substr(2);

              if (HEX_NUMBER.test(str)) {
                entity = String.fromCodePoint(parseInt(str, 16));
              }
            } else {
              str = str.substr(1);

              if (DECIMAL_NUMBER.test(str)) {
                entity = String.fromCodePoint(parseInt(str, 10));
              }
            }
          } else {
            entity = entities[str];
          }

          break;
        }

        str += ch;
      }

      if (!entity) {
        this.state.pos = startPos;
        return "&";
      }

      return entity;
    }

    jsxReadWord() {
      let ch;
      const start = this.state.pos;

      do {
        ch = this.input.charCodeAt(++this.state.pos);
      } while (isIdentifierChar(ch) || ch === 45);

      return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));
    }

    jsxParseIdentifier() {
      const node = this.startNode();

      if (this.match(types.jsxName)) {
        node.name = this.state.value;
      } else if (this.state.type.keyword) {
        node.name = this.state.type.keyword;
      } else {
        this.unexpected();
      }

      this.next();
      return this.finishNode(node, "JSXIdentifier");
    }

    jsxParseNamespacedName() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const name = this.jsxParseIdentifier();
      if (!this.eat(types.colon)) return name;
      const node = this.startNodeAt(startPos, startLoc);
      node.namespace = name;
      node.name = this.jsxParseIdentifier();
      return this.finishNode(node, "JSXNamespacedName");
    }

    jsxParseElementName() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let node = this.jsxParseNamespacedName();

      if (node.type === "JSXNamespacedName") {
        return node;
      }

      while (this.eat(types.dot)) {
        const newNode = this.startNodeAt(startPos, startLoc);
        newNode.object = node;
        newNode.property = this.jsxParseIdentifier();
        node = this.finishNode(newNode, "JSXMemberExpression");
      }

      return node;
    }

    jsxParseAttributeValue() {
      let node;

      switch (this.state.type) {
        case types.braceL:
          node = this.startNode();
          this.next();
          node = this.jsxParseExpressionContainer(node);

          if (node.expression.type === "JSXEmptyExpression") {
            this.raise(node.start, JsxErrors.AttributeIsEmpty);
          }

          return node;

        case types.jsxTagStart:
        case types.string:
          return this.parseExprAtom();

        default:
          throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);
      }
    }

    jsxParseEmptyExpression() {
      const node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
      return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
    }

    jsxParseSpreadChild(node) {
      this.next();
      node.expression = this.parseExpression();
      this.expect(types.braceR);
      return this.finishNode(node, "JSXSpreadChild");
    }

    jsxParseExpressionContainer(node) {
      if (this.match(types.braceR)) {
        node.expression = this.jsxParseEmptyExpression();
      } else {
        node.expression = this.parseExpression();
      }

      this.expect(types.braceR);
      return this.finishNode(node, "JSXExpressionContainer");
    }

    jsxParseAttribute() {
      const node = this.startNode();

      if (this.eat(types.braceL)) {
        this.expect(types.ellipsis);
        node.argument = this.parseMaybeAssignAllowIn();
        this.expect(types.braceR);
        return this.finishNode(node, "JSXSpreadAttribute");
      }

      node.name = this.jsxParseNamespacedName();
      node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;
      return this.finishNode(node, "JSXAttribute");
    }

    jsxParseOpeningElementAt(startPos, startLoc) {
      const node = this.startNodeAt(startPos, startLoc);

      if (this.match(types.jsxTagEnd)) {
        this.expect(types.jsxTagEnd);
        return this.finishNode(node, "JSXOpeningFragment");
      }

      node.name = this.jsxParseElementName();
      return this.jsxParseOpeningElementAfterName(node);
    }

    jsxParseOpeningElementAfterName(node) {
      const attributes = [];

      while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {
        attributes.push(this.jsxParseAttribute());
      }

      node.attributes = attributes;
      node.selfClosing = this.eat(types.slash);
      this.expect(types.jsxTagEnd);
      return this.finishNode(node, "JSXOpeningElement");
    }

    jsxParseClosingElementAt(startPos, startLoc) {
      const node = this.startNodeAt(startPos, startLoc);

      if (this.match(types.jsxTagEnd)) {
        this.expect(types.jsxTagEnd);
        return this.finishNode(node, "JSXClosingFragment");
      }

      node.name = this.jsxParseElementName();
      this.expect(types.jsxTagEnd);
      return this.finishNode(node, "JSXClosingElement");
    }

    jsxParseElementAt(startPos, startLoc) {
      const node = this.startNodeAt(startPos, startLoc);
      const children = [];
      const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
      let closingElement = null;

      if (!openingElement.selfClosing) {
        contents: for (;;) {
          switch (this.state.type) {
            case types.jsxTagStart:
              startPos = this.state.start;
              startLoc = this.state.startLoc;
              this.next();

              if (this.eat(types.slash)) {
                closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                break contents;
              }

              children.push(this.jsxParseElementAt(startPos, startLoc));
              break;

            case types.jsxText:
              children.push(this.parseExprAtom());
              break;

            case types.braceL:
              {
                const node = this.startNode();
                this.next();

                if (this.match(types.ellipsis)) {
                  children.push(this.jsxParseSpreadChild(node));
                } else {
                  children.push(this.jsxParseExpressionContainer(node));
                }

                break;
              }

            default:
              throw this.unexpected();
          }
        }

        if (isFragment(openingElement) && !isFragment(closingElement)) {
          this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);
        } else if (!isFragment(openingElement) && isFragment(closingElement)) {
          this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
          if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
            this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
          }
        }
      }

      if (isFragment(openingElement)) {
        node.openingFragment = openingElement;
        node.closingFragment = closingElement;
      } else {
        node.openingElement = openingElement;
        node.closingElement = closingElement;
      }

      node.children = children;

      if (this.isRelational("<")) {
        throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);
      }

      return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
    }

    jsxParseElement() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      this.next();
      return this.jsxParseElementAt(startPos, startLoc);
    }

    parseExprAtom(refExpressionErrors) {
      if (this.match(types.jsxText)) {
        return this.parseLiteral(this.state.value, "JSXText");
      } else if (this.match(types.jsxTagStart)) {
        return this.jsxParseElement();
      } else if (this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33) {
        this.finishToken(types.jsxTagStart);
        return this.jsxParseElement();
      } else {
        return super.parseExprAtom(refExpressionErrors);
      }
    }

    getTokenFromCode(code) {
      if (this.state.inPropertyName) return super.getTokenFromCode(code);
      const context = this.curContext();

      if (context === types$1.j_expr) {
        return this.jsxReadToken();
      }

      if (context === types$1.j_oTag || context === types$1.j_cTag) {
        if (isIdentifierStart(code)) {
          return this.jsxReadWord();
        }

        if (code === 62) {
          ++this.state.pos;
          return this.finishToken(types.jsxTagEnd);
        }

        if ((code === 34 || code === 39) && context === types$1.j_oTag) {
          return this.jsxReadString(code);
        }
      }

      if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos;
        return this.finishToken(types.jsxTagStart);
      }

      return super.getTokenFromCode(code);
    }

    updateContext(prevType) {
      if (this.match(types.braceL)) {
        const curContext = this.curContext();

        if (curContext === types$1.j_oTag) {
          this.state.context.push(types$1.braceExpression);
        } else if (curContext === types$1.j_expr) {
          this.state.context.push(types$1.templateQuasi);
        } else {
          super.updateContext(prevType);
        }

        this.state.exprAllowed = true;
      } else if (this.match(types.slash) && prevType === types.jsxTagStart) {
        this.state.context.length -= 2;
        this.state.context.push(types$1.j_cTag);
        this.state.exprAllowed = false;
      } else {
        return super.updateContext(prevType);
      }
    }

  });

  class Scope {
    constructor(flags) {
      this.var = [];
      this.lexical = [];
      this.functions = [];
      this.flags = flags;
    }

  }
  class ScopeHandler {
    constructor(raise, inModule) {
      this.scopeStack = [];
      this.undefinedExports = new Map();
      this.undefinedPrivateNames = new Map();
      this.raise = raise;
      this.inModule = inModule;
    }

    get inFunction() {
      return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
    }

    get allowSuper() {
      return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
    }

    get allowDirectSuper() {
      return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
    }

    get inClass() {
      return (this.currentThisScope().flags & SCOPE_CLASS) > 0;
    }

    get inNonArrowFunction() {
      return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
    }

    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }

    createScope(flags) {
      return new Scope(flags);
    }

    enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    }

    exit() {
      this.scopeStack.pop();
    }

    treatFunctionsAsVarInScope(scope) {
      return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);
    }

    declareName(name, bindingType, pos) {
      let scope = this.currentScope();

      if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
        this.checkRedeclarationInScope(scope, name, bindingType, pos);

        if (bindingType & BIND_SCOPE_FUNCTION) {
          scope.functions.push(name);
        } else {
          scope.lexical.push(name);
        }

        if (bindingType & BIND_SCOPE_LEXICAL) {
          this.maybeExportDefined(scope, name);
        }
      } else if (bindingType & BIND_SCOPE_VAR) {
        for (let i = this.scopeStack.length - 1; i >= 0; --i) {
          scope = this.scopeStack[i];
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          scope.var.push(name);
          this.maybeExportDefined(scope, name);
          if (scope.flags & SCOPE_VAR) break;
        }
      }

      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports.delete(name);
      }
    }

    maybeExportDefined(scope, name) {
      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports.delete(name);
      }
    }

    checkRedeclarationInScope(scope, name, bindingType, pos) {
      if (this.isRedeclaredInScope(scope, name, bindingType)) {
        this.raise(pos, ErrorMessages.VarRedeclaration, name);
      }
    }

    isRedeclaredInScope(scope, name, bindingType) {
      if (!(bindingType & BIND_KIND_VALUE)) return false;

      if (bindingType & BIND_SCOPE_LEXICAL) {
        return scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
      }

      if (bindingType & BIND_SCOPE_FUNCTION) {
        return scope.lexical.indexOf(name) > -1 || !this.treatFunctionsAsVarInScope(scope) && scope.var.indexOf(name) > -1;
      }

      return scope.lexical.indexOf(name) > -1 && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.indexOf(name) > -1;
    }

    checkLocalExport(id) {
      if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1 && this.scopeStack[0].functions.indexOf(id.name) === -1) {
        this.undefinedExports.set(id.name, id.start);
      }
    }

    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }

    currentVarScope() {
      for (let i = this.scopeStack.length - 1;; i--) {
        const scope = this.scopeStack[i];

        if (scope.flags & SCOPE_VAR) {
          return scope;
        }
      }
    }

    currentThisScope() {
      for (let i = this.scopeStack.length - 1;; i--) {
        const scope = this.scopeStack[i];

        if ((scope.flags & SCOPE_VAR || scope.flags & SCOPE_CLASS) && !(scope.flags & SCOPE_ARROW)) {
          return scope;
        }
      }
    }

  }

  class TypeScriptScope extends Scope {
    constructor(...args) {
      super(...args);
      this.types = [];
      this.enums = [];
      this.constEnums = [];
      this.classes = [];
      this.exportOnlyBindings = [];
    }

  }

  class TypeScriptScopeHandler extends ScopeHandler {
    createScope(flags) {
      return new TypeScriptScope(flags);
    }

    declareName(name, bindingType, pos) {
      const scope = this.currentScope();

      if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
        this.maybeExportDefined(scope, name);
        scope.exportOnlyBindings.push(name);
        return;
      }

      super.declareName(...arguments);

      if (bindingType & BIND_KIND_TYPE) {
        if (!(bindingType & BIND_KIND_VALUE)) {
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          this.maybeExportDefined(scope, name);
        }

        scope.types.push(name);
      }

      if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.push(name);
      if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);
      if (bindingType & BIND_FLAGS_CLASS) scope.classes.push(name);
    }

    isRedeclaredInScope(scope, name, bindingType) {
      if (scope.enums.indexOf(name) > -1) {
        if (bindingType & BIND_FLAGS_TS_ENUM) {
          const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
          const wasConst = scope.constEnums.indexOf(name) > -1;
          return isConst !== wasConst;
        }

        return true;
      }

      if (bindingType & BIND_FLAGS_CLASS && scope.classes.indexOf(name) > -1) {
        if (scope.lexical.indexOf(name) > -1) {
          return !!(bindingType & BIND_KIND_VALUE);
        } else {
          return false;
        }
      }

      if (bindingType & BIND_KIND_TYPE && scope.types.indexOf(name) > -1) {
        return true;
      }

      return super.isRedeclaredInScope(...arguments);
    }

    checkLocalExport(id) {
      if (this.scopeStack[0].types.indexOf(id.name) === -1 && this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1) {
        super.checkLocalExport(id);
      }
    }

  }

  const PARAM = 0b0000,
        PARAM_YIELD = 0b0001,
        PARAM_AWAIT = 0b0010,
        PARAM_RETURN = 0b0100,
        PARAM_IN = 0b1000;
  class ProductionParameterHandler {
    constructor() {
      this.stacks = [];
    }

    enter(flags) {
      this.stacks.push(flags);
    }

    exit() {
      this.stacks.pop();
    }

    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }

    get hasAwait() {
      return (this.currentFlags() & PARAM_AWAIT) > 0;
    }

    get hasYield() {
      return (this.currentFlags() & PARAM_YIELD) > 0;
    }

    get hasReturn() {
      return (this.currentFlags() & PARAM_RETURN) > 0;
    }

    get hasIn() {
      return (this.currentFlags() & PARAM_IN) > 0;
    }

  }
  function functionFlags(isAsync, isGenerator) {
    return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
  }

  function nonNull(x) {
    if (x == null) {
      throw new Error(`Unexpected ${x} value.`);
    }

    return x;
  }

  function assert(x) {
    if (!x) {
      throw new Error("Assert fail");
    }
  }

  const TSErrors = Object.freeze({
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier",
    DeclareClassFieldHasInitializer: "'declare' class fields cannot have an initializer",
    DuplicateModifier: "Duplicate modifier: '%0'",
    EmptyHeritageClauseType: "'%0' list cannot be empty.",
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier",
    IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0')",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0')",
    TemplateTypeHasSubstitution: "Template literal types cannot have any substitution",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0"
  });

  function keywordTypeFromName(value) {
    switch (value) {
      case "any":
        return "TSAnyKeyword";

      case "boolean":
        return "TSBooleanKeyword";

      case "bigint":
        return "TSBigIntKeyword";

      case "never":
        return "TSNeverKeyword";

      case "number":
        return "TSNumberKeyword";

      case "object":
        return "TSObjectKeyword";

      case "string":
        return "TSStringKeyword";

      case "symbol":
        return "TSSymbolKeyword";

      case "undefined":
        return "TSUndefinedKeyword";

      case "unknown":
        return "TSUnknownKeyword";

      default:
        return undefined;
    }
  }

  var typescript = (superClass => class extends superClass {
    getScopeHandler() {
      return TypeScriptScopeHandler;
    }

    tsIsIdentifier() {
      return this.match(types.name);
    }

    tsNextTokenCanFollowModifier() {
      this.next();
      return !this.hasPrecedingLineBreak() && !this.match(types.parenL) && !this.match(types.parenR) && !this.match(types.colon) && !this.match(types.eq) && !this.match(types.question) && !this.match(types.bang);
    }

    tsParseModifier(allowedModifiers) {
      if (!this.match(types.name)) {
        return undefined;
      }

      const modifier = this.state.value;

      if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
        return modifier;
      }

      return undefined;
    }

    tsParseModifiers(modified, allowedModifiers) {
      for (;;) {
        const startPos = this.state.start;
        const modifier = this.tsParseModifier(allowedModifiers);
        if (!modifier) break;

        if (Object.hasOwnProperty.call(modified, modifier)) {
          this.raise(startPos, TSErrors.DuplicateModifier, modifier);
        }

        modified[modifier] = true;
      }
    }

    tsIsListTerminator(kind) {
      switch (kind) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(types.braceR);

        case "HeritageClauseElement":
          return this.match(types.braceL);

        case "TupleElementTypes":
          return this.match(types.bracketR);

        case "TypeParametersOrArguments":
          return this.isRelational(">");
      }

      throw new Error("Unreachable");
    }

    tsParseList(kind, parseElement) {
      const result = [];

      while (!this.tsIsListTerminator(kind)) {
        result.push(parseElement());
      }

      return result;
    }

    tsParseDelimitedList(kind, parseElement) {
      return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));
    }

    tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
      const result = [];

      for (;;) {
        if (this.tsIsListTerminator(kind)) {
          break;
        }

        const element = parseElement();

        if (element == null) {
          return undefined;
        }

        result.push(element);

        if (this.eat(types.comma)) {
          continue;
        }

        if (this.tsIsListTerminator(kind)) {
          break;
        }

        if (expectSuccess) {
          this.expect(types.comma);
        }

        return undefined;
      }

      return result;
    }

    tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
      if (!skipFirstToken) {
        if (bracket) {
          this.expect(types.bracketL);
        } else {
          this.expectRelational("<");
        }
      }

      const result = this.tsParseDelimitedList(kind, parseElement);

      if (bracket) {
        this.expect(types.bracketR);
      } else {
        this.expectRelational(">");
      }

      return result;
    }

    tsParseImportType() {
      const node = this.startNode();
      this.expect(types._import);
      this.expect(types.parenL);

      if (!this.match(types.string)) {
        this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);
      }

      node.argument = this.parseExprAtom();
      this.expect(types.parenR);

      if (this.eat(types.dot)) {
        node.qualifier = this.tsParseEntityName(true);
      }

      if (this.isRelational("<")) {
        node.typeParameters = this.tsParseTypeArguments();
      }

      return this.finishNode(node, "TSImportType");
    }

    tsParseEntityName(allowReservedWords) {
      let entity = this.parseIdentifier();

      while (this.eat(types.dot)) {
        const node = this.startNodeAtNode(entity);
        node.left = entity;
        node.right = this.parseIdentifier(allowReservedWords);
        entity = this.finishNode(node, "TSQualifiedName");
      }

      return entity;
    }

    tsParseTypeReference() {
      const node = this.startNode();
      node.typeName = this.tsParseEntityName(false);

      if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
        node.typeParameters = this.tsParseTypeArguments();
      }

      return this.finishNode(node, "TSTypeReference");
    }

    tsParseThisTypePredicate(lhs) {
      this.next();
      const node = this.startNodeAtNode(lhs);
      node.parameterName = lhs;
      node.typeAnnotation = this.tsParseTypeAnnotation(false);
      return this.finishNode(node, "TSTypePredicate");
    }

    tsParseThisTypeNode() {
      const node = this.startNode();
      this.next();
      return this.finishNode(node, "TSThisType");
    }

    tsParseTypeQuery() {
      const node = this.startNode();
      this.expect(types._typeof);

      if (this.match(types._import)) {
        node.exprName = this.tsParseImportType();
      } else {
        node.exprName = this.tsParseEntityName(true);
      }

      return this.finishNode(node, "TSTypeQuery");
    }

    tsParseTypeParameter() {
      const node = this.startNode();
      node.name = this.parseIdentifierName(node.start);
      node.constraint = this.tsEatThenParseType(types._extends);
      node.default = this.tsEatThenParseType(types.eq);
      return this.finishNode(node, "TSTypeParameter");
    }

    tsTryParseTypeParameters() {
      if (this.isRelational("<")) {
        return this.tsParseTypeParameters();
      }
    }

    tsParseTypeParameters() {
      const node = this.startNode();

      if (this.isRelational("<") || this.match(types.jsxTagStart)) {
        this.next();
      } else {
        this.unexpected();
      }

      node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true);
      return this.finishNode(node, "TSTypeParameterDeclaration");
    }

    tsTryNextParseConstantContext() {
      if (this.lookahead().type === types._const) {
        this.next();
        return this.tsParseTypeReference();
      }

      return null;
    }

    tsFillSignature(returnToken, signature) {
      const returnTokenRequired = returnToken === types.arrow;
      signature.typeParameters = this.tsTryParseTypeParameters();
      this.expect(types.parenL);
      signature.parameters = this.tsParseBindingListForSignature();

      if (returnTokenRequired) {
        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
      } else if (this.match(returnToken)) {
        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
      }
    }

    tsParseBindingListForSignature() {
      return this.parseBindingList(types.parenR, 41).map(pattern => {
        if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
          this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);
        }

        return pattern;
      });
    }

    tsParseTypeMemberSemicolon() {
      if (!this.eat(types.comma)) {
        this.semicolon();
      }
    }

    tsParseSignatureMember(kind, node) {
      this.tsFillSignature(types.colon, node);
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(node, kind);
    }

    tsIsUnambiguouslyIndexSignature() {
      this.next();
      return this.eat(types.name) && this.match(types.colon);
    }

    tsTryParseIndexSignature(node) {
      if (!(this.match(types.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
        return undefined;
      }

      this.expect(types.bracketL);
      const id = this.parseIdentifier();
      id.typeAnnotation = this.tsParseTypeAnnotation();
      this.resetEndLocation(id);
      this.expect(types.bracketR);
      node.parameters = [id];
      const type = this.tsTryParseTypeAnnotation();
      if (type) node.typeAnnotation = type;
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(node, "TSIndexSignature");
    }

    tsParsePropertyOrMethodSignature(node, readonly) {
      if (this.eat(types.question)) node.optional = true;
      const nodeAny = node;

      if (!readonly && (this.match(types.parenL) || this.isRelational("<"))) {
        const method = nodeAny;
        this.tsFillSignature(types.colon, method);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(method, "TSMethodSignature");
      } else {
        const property = nodeAny;
        if (readonly) property.readonly = true;
        const type = this.tsTryParseTypeAnnotation();
        if (type) property.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(property, "TSPropertySignature");
      }
    }

    tsParseTypeMember() {
      const node = this.startNode();

      if (this.match(types.parenL) || this.isRelational("<")) {
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
      }

      if (this.match(types._new)) {
        const id = this.startNode();
        this.next();

        if (this.match(types.parenL) || this.isRelational("<")) {
          return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
        } else {
          node.key = this.createIdentifier(id, "new");
          return this.tsParsePropertyOrMethodSignature(node, false);
        }
      }

      const readonly = !!this.tsParseModifier(["readonly"]);
      const idx = this.tsTryParseIndexSignature(node);

      if (idx) {
        if (readonly) node.readonly = true;
        return idx;
      }

      this.parsePropertyName(node, false);
      return this.tsParsePropertyOrMethodSignature(node, readonly);
    }

    tsParseTypeLiteral() {
      const node = this.startNode();
      node.members = this.tsParseObjectTypeMembers();
      return this.finishNode(node, "TSTypeLiteral");
    }

    tsParseObjectTypeMembers() {
      this.expect(types.braceL);
      const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      this.expect(types.braceR);
      return members;
    }

    tsIsStartOfMappedType() {
      this.next();

      if (this.eat(types.plusMin)) {
        return this.isContextual("readonly");
      }

      if (this.isContextual("readonly")) {
        this.next();
      }

      if (!this.match(types.bracketL)) {
        return false;
      }

      this.next();

      if (!this.tsIsIdentifier()) {
        return false;
      }

      this.next();
      return this.match(types._in);
    }

    tsParseMappedTypeParameter() {
      const node = this.startNode();
      node.name = this.parseIdentifierName(node.start);
      node.constraint = this.tsExpectThenParseType(types._in);
      return this.finishNode(node, "TSTypeParameter");
    }

    tsParseMappedType() {
      const node = this.startNode();
      this.expect(types.braceL);

      if (this.match(types.plusMin)) {
        node.readonly = this.state.value;
        this.next();
        this.expectContextual("readonly");
      } else if (this.eatContextual("readonly")) {
        node.readonly = true;
      }

      this.expect(types.bracketL);
      node.typeParameter = this.tsParseMappedTypeParameter();
      this.expect(types.bracketR);

      if (this.match(types.plusMin)) {
        node.optional = this.state.value;
        this.next();
        this.expect(types.question);
      } else if (this.eat(types.question)) {
        node.optional = true;
      }

      node.typeAnnotation = this.tsTryParseType();
      this.semicolon();
      this.expect(types.braceR);
      return this.finishNode(node, "TSMappedType");
    }

    tsParseTupleType() {
      const node = this.startNode();
      node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
      let seenOptionalElement = false;
      let labeledElements = null;
      node.elementTypes.forEach(elementNode => {
        var _labeledElements;

        let {
          type
        } = elementNode;

        if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
          this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);
        }

        seenOptionalElement = seenOptionalElement || type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType";

        if (type === "TSRestType") {
          elementNode = elementNode.typeAnnotation;
          type = elementNode.type;
        }

        const isLabeled = type === "TSNamedTupleMember";
        labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;

        if (labeledElements !== isLabeled) {
          this.raise(elementNode.start, TSErrors.MixedLabeledAndUnlabeledElements);
        }
      });
      return this.finishNode(node, "TSTupleType");
    }

    tsParseTupleElementType() {
      const {
        start: startPos,
        startLoc
      } = this.state;
      const rest = this.eat(types.ellipsis);
      let type = this.tsParseType();
      const optional = this.eat(types.question);
      const labeled = this.eat(types.colon);

      if (labeled) {
        const labeledNode = this.startNodeAtNode(type);
        labeledNode.optional = optional;

        if (type.type === "TSTypeReference" && !type.typeParameters && type.typeName.type === "Identifier") {
          labeledNode.label = type.typeName;
        } else {
          this.raise(type.start, TSErrors.InvalidTupleMemberLabel);
          labeledNode.label = type;
        }

        labeledNode.elementType = this.tsParseType();
        type = this.finishNode(labeledNode, "TSNamedTupleMember");
      } else if (optional) {
        const optionalTypeNode = this.startNodeAtNode(type);
        optionalTypeNode.typeAnnotation = type;
        type = this.finishNode(optionalTypeNode, "TSOptionalType");
      }

      if (rest) {
        const restNode = this.startNodeAt(startPos, startLoc);
        restNode.typeAnnotation = type;
        type = this.finishNode(restNode, "TSRestType");
      }

      return type;
    }

    tsParseParenthesizedType() {
      const node = this.startNode();
      this.expect(types.parenL);
      node.typeAnnotation = this.tsParseType();
      this.expect(types.parenR);
      return this.finishNode(node, "TSParenthesizedType");
    }

    tsParseFunctionOrConstructorType(type) {
      const node = this.startNode();

      if (type === "TSConstructorType") {
        this.expect(types._new);
      }

      this.tsFillSignature(types.arrow, node);
      return this.finishNode(node, type);
    }

    tsParseLiteralTypeNode() {
      const node = this.startNode();

      node.literal = (() => {
        switch (this.state.type) {
          case types.num:
          case types.bigint:
          case types.string:
          case types._true:
          case types._false:
            return this.parseExprAtom();

          default:
            throw this.unexpected();
        }
      })();

      return this.finishNode(node, "TSLiteralType");
    }

    tsParseTemplateLiteralType() {
      const node = this.startNode();
      const templateNode = this.parseTemplate(false);

      if (templateNode.expressions.length > 0) {
        this.raise(templateNode.expressions[0].start, TSErrors.TemplateTypeHasSubstitution);
      }

      node.literal = templateNode;
      return this.finishNode(node, "TSLiteralType");
    }

    tsParseThisTypeOrThisTypePredicate() {
      const thisKeyword = this.tsParseThisTypeNode();

      if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
        return this.tsParseThisTypePredicate(thisKeyword);
      } else {
        return thisKeyword;
      }
    }

    tsParseNonArrayType() {
      switch (this.state.type) {
        case types.name:
        case types._void:
        case types._null:
          {
            const type = this.match(types._void) ? "TSVoidKeyword" : this.match(types._null) ? "TSNullKeyword" : keywordTypeFromName(this.state.value);

            if (type !== undefined && this.lookaheadCharCode() !== 46) {
              const node = this.startNode();
              this.next();
              return this.finishNode(node, type);
            }

            return this.tsParseTypeReference();
          }

        case types.string:
        case types.num:
        case types.bigint:
        case types._true:
        case types._false:
          return this.tsParseLiteralTypeNode();

        case types.plusMin:
          if (this.state.value === "-") {
            const node = this.startNode();
            const nextToken = this.lookahead();

            if (nextToken.type !== types.num && nextToken.type !== types.bigint) {
              throw this.unexpected();
            }

            node.literal = this.parseMaybeUnary();
            return this.finishNode(node, "TSLiteralType");
          }

          break;

        case types._this:
          return this.tsParseThisTypeOrThisTypePredicate();

        case types._typeof:
          return this.tsParseTypeQuery();

        case types._import:
          return this.tsParseImportType();

        case types.braceL:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();

        case types.bracketL:
          return this.tsParseTupleType();

        case types.parenL:
          return this.tsParseParenthesizedType();

        case types.backQuote:
          return this.tsParseTemplateLiteralType();
      }

      throw this.unexpected();
    }

    tsParseArrayTypeOrHigher() {
      let type = this.tsParseNonArrayType();

      while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {
        if (this.match(types.bracketR)) {
          const node = this.startNodeAtNode(type);
          node.elementType = type;
          this.expect(types.bracketR);
          type = this.finishNode(node, "TSArrayType");
        } else {
          const node = this.startNodeAtNode(type);
          node.objectType = type;
          node.indexType = this.tsParseType();
          this.expect(types.bracketR);
          type = this.finishNode(node, "TSIndexedAccessType");
        }
      }

      return type;
    }

    tsParseTypeOperator(operator) {
      const node = this.startNode();
      this.expectContextual(operator);
      node.operator = operator;
      node.typeAnnotation = this.tsParseTypeOperatorOrHigher();

      if (operator === "readonly") {
        this.tsCheckTypeAnnotationForReadOnly(node);
      }

      return this.finishNode(node, "TSTypeOperator");
    }

    tsCheckTypeAnnotationForReadOnly(node) {
      switch (node.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;

        default:
          this.raise(node.start, TSErrors.UnexpectedReadonly);
      }
    }

    tsParseInferType() {
      const node = this.startNode();
      this.expectContextual("infer");
      const typeParameter = this.startNode();
      typeParameter.name = this.parseIdentifierName(typeParameter.start);
      node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
      return this.finishNode(node, "TSInferType");
    }

    tsParseTypeOperatorOrHigher() {
      const operator = ["keyof", "unique", "readonly"].find(kw => this.isContextual(kw));
      return operator ? this.tsParseTypeOperator(operator) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
    }

    tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
      this.eat(operator);
      let type = parseConstituentType();

      if (this.match(operator)) {
        const types = [type];

        while (this.eat(operator)) {
          types.push(parseConstituentType());
        }

        const node = this.startNodeAtNode(type);
        node.types = types;
        type = this.finishNode(node, kind);
      }

      return type;
    }

    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);
    }

    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);
    }

    tsIsStartOfFunctionType() {
      if (this.isRelational("<")) {
        return true;
      }

      return this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }

    tsSkipParameterStart() {
      if (this.match(types.name) || this.match(types._this)) {
        this.next();
        return true;
      }

      if (this.match(types.braceL)) {
        let braceStackCounter = 1;
        this.next();

        while (braceStackCounter > 0) {
          if (this.match(types.braceL)) {
            ++braceStackCounter;
          } else if (this.match(types.braceR)) {
            --braceStackCounter;
          }

          this.next();
        }

        return true;
      }

      if (this.match(types.bracketL)) {
        let braceStackCounter = 1;
        this.next();

        while (braceStackCounter > 0) {
          if (this.match(types.bracketL)) {
            ++braceStackCounter;
          } else if (this.match(types.bracketR)) {
            --braceStackCounter;
          }

          this.next();
        }

        return true;
      }

      return false;
    }

    tsIsUnambiguouslyStartOfFunctionType() {
      this.next();

      if (this.match(types.parenR) || this.match(types.ellipsis)) {
        return true;
      }

      if (this.tsSkipParameterStart()) {
        if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) {
          return true;
        }

        if (this.match(types.parenR)) {
          this.next();

          if (this.match(types.arrow)) {
            return true;
          }
        }
      }

      return false;
    }

    tsParseTypeOrTypePredicateAnnotation(returnToken) {
      return this.tsInType(() => {
        const t = this.startNode();
        this.expect(returnToken);
        const asserts = this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));

        if (asserts && this.match(types._this)) {
          let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();

          if (thisTypePredicate.type === "TSThisType") {
            const node = this.startNodeAtNode(t);
            node.parameterName = thisTypePredicate;
            node.asserts = true;
            thisTypePredicate = this.finishNode(node, "TSTypePredicate");
          } else {
            thisTypePredicate.asserts = true;
          }

          t.typeAnnotation = thisTypePredicate;
          return this.finishNode(t, "TSTypeAnnotation");
        }

        const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));

        if (!typePredicateVariable) {
          if (!asserts) {
            return this.tsParseTypeAnnotation(false, t);
          }

          const node = this.startNodeAtNode(t);
          node.parameterName = this.parseIdentifier();
          node.asserts = asserts;
          t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
          return this.finishNode(t, "TSTypeAnnotation");
        }

        const type = this.tsParseTypeAnnotation(false);
        const node = this.startNodeAtNode(t);
        node.parameterName = typePredicateVariable;
        node.typeAnnotation = type;
        node.asserts = asserts;
        t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
        return this.finishNode(t, "TSTypeAnnotation");
      });
    }

    tsTryParseTypeOrTypePredicateAnnotation() {
      return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : undefined;
    }

    tsTryParseTypeAnnotation() {
      return this.match(types.colon) ? this.tsParseTypeAnnotation() : undefined;
    }

    tsTryParseType() {
      return this.tsEatThenParseType(types.colon);
    }

    tsParseTypePredicatePrefix() {
      const id = this.parseIdentifier();

      if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
        this.next();
        return id;
      }
    }

    tsParseTypePredicateAsserts() {
      if (!this.match(types.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak()) {
        return false;
      }

      const containsEsc = this.state.containsEsc;
      this.next();

      if (!this.match(types.name) && !this.match(types._this)) {
        return false;
      }

      if (containsEsc) {
        this.raise(this.state.lastTokStart, ErrorMessages.InvalidEscapedReservedWord, "asserts");
      }

      return true;
    }

    tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
      this.tsInType(() => {
        if (eatColon) this.expect(types.colon);
        t.typeAnnotation = this.tsParseType();
      });
      return this.finishNode(t, "TSTypeAnnotation");
    }

    tsParseType() {
      assert(this.state.inType);
      const type = this.tsParseNonConditionalType();

      if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {
        return type;
      }

      const node = this.startNodeAtNode(type);
      node.checkType = type;
      node.extendsType = this.tsParseNonConditionalType();
      this.expect(types.question);
      node.trueType = this.tsParseType();
      this.expect(types.colon);
      node.falseType = this.tsParseType();
      return this.finishNode(node, "TSConditionalType");
    }

    tsParseNonConditionalType() {
      if (this.tsIsStartOfFunctionType()) {
        return this.tsParseFunctionOrConstructorType("TSFunctionType");
      }

      if (this.match(types._new)) {
        return this.tsParseFunctionOrConstructorType("TSConstructorType");
      }

      return this.tsParseUnionTypeOrHigher();
    }

    tsParseTypeAssertion() {
      const node = this.startNode();

      const _const = this.tsTryNextParseConstantContext();

      node.typeAnnotation = _const || this.tsNextThenParseType();
      this.expectRelational(">");
      node.expression = this.parseMaybeUnary();
      return this.finishNode(node, "TSTypeAssertion");
    }

    tsParseHeritageClause(descriptor) {
      const originalStart = this.state.start;
      const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));

      if (!delimitedList.length) {
        this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);
      }

      return delimitedList;
    }

    tsParseExpressionWithTypeArguments() {
      const node = this.startNode();
      node.expression = this.tsParseEntityName(false);

      if (this.isRelational("<")) {
        node.typeParameters = this.tsParseTypeArguments();
      }

      return this.finishNode(node, "TSExpressionWithTypeArguments");
    }

    tsParseInterfaceDeclaration(node) {
      node.id = this.parseIdentifier();
      this.checkLVal(node.id, BIND_TS_INTERFACE, undefined, "typescript interface declaration");
      node.typeParameters = this.tsTryParseTypeParameters();

      if (this.eat(types._extends)) {
        node.extends = this.tsParseHeritageClause("extends");
      }

      const body = this.startNode();
      body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
      node.body = this.finishNode(body, "TSInterfaceBody");
      return this.finishNode(node, "TSInterfaceDeclaration");
    }

    tsParseTypeAliasDeclaration(node) {
      node.id = this.parseIdentifier();
      this.checkLVal(node.id, BIND_TS_TYPE, undefined, "typescript type alias");
      node.typeParameters = this.tsTryParseTypeParameters();
      node.typeAnnotation = this.tsExpectThenParseType(types.eq);
      this.semicolon();
      return this.finishNode(node, "TSTypeAliasDeclaration");
    }

    tsInNoContext(cb) {
      const oldContext = this.state.context;
      this.state.context = [oldContext[0]];

      try {
        return cb();
      } finally {
        this.state.context = oldContext;
      }
    }

    tsInType(cb) {
      const oldInType = this.state.inType;
      this.state.inType = true;

      try {
        return cb();
      } finally {
        this.state.inType = oldInType;
      }
    }

    tsEatThenParseType(token) {
      return !this.match(token) ? undefined : this.tsNextThenParseType();
    }

    tsExpectThenParseType(token) {
      return this.tsDoThenParseType(() => this.expect(token));
    }

    tsNextThenParseType() {
      return this.tsDoThenParseType(() => this.next());
    }

    tsDoThenParseType(cb) {
      return this.tsInType(() => {
        cb();
        return this.tsParseType();
      });
    }

    tsParseEnumMember() {
      const node = this.startNode();
      node.id = this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);

      if (this.eat(types.eq)) {
        node.initializer = this.parseMaybeAssignAllowIn();
      }

      return this.finishNode(node, "TSEnumMember");
    }

    tsParseEnumDeclaration(node, isConst) {
      if (isConst) node.const = true;
      node.id = this.parseIdentifier();
      this.checkLVal(node.id, isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM, undefined, "typescript enum declaration");
      this.expect(types.braceL);
      node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
      this.expect(types.braceR);
      return this.finishNode(node, "TSEnumDeclaration");
    }

    tsParseModuleBlock() {
      const node = this.startNode();
      this.scope.enter(SCOPE_OTHER);
      this.expect(types.braceL);
      this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types.braceR);
      this.scope.exit();
      return this.finishNode(node, "TSModuleBlock");
    }

    tsParseModuleOrNamespaceDeclaration(node, nested = false) {
      node.id = this.parseIdentifier();

      if (!nested) {
        this.checkLVal(node.id, BIND_TS_NAMESPACE, null, "module or namespace declaration");
      }

      if (this.eat(types.dot)) {
        const inner = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(inner, true);
        node.body = inner;
      } else {
        this.scope.enter(SCOPE_TS_MODULE);
        this.prodParam.enter(PARAM);
        node.body = this.tsParseModuleBlock();
        this.prodParam.exit();
        this.scope.exit();
      }

      return this.finishNode(node, "TSModuleDeclaration");
    }

    tsParseAmbientExternalModuleDeclaration(node) {
      if (this.isContextual("global")) {
        node.global = true;
        node.id = this.parseIdentifier();
      } else if (this.match(types.string)) {
        node.id = this.parseExprAtom();
      } else {
        this.unexpected();
      }

      if (this.match(types.braceL)) {
        this.scope.enter(SCOPE_TS_MODULE);
        this.prodParam.enter(PARAM);
        node.body = this.tsParseModuleBlock();
        this.prodParam.exit();
        this.scope.exit();
      } else {
        this.semicolon();
      }

      return this.finishNode(node, "TSModuleDeclaration");
    }

    tsParseImportEqualsDeclaration(node, isExport) {
      node.isExport = isExport || false;
      node.id = this.parseIdentifier();
      this.checkLVal(node.id, BIND_LEXICAL, undefined, "import equals declaration");
      this.expect(types.eq);
      node.moduleReference = this.tsParseModuleReference();
      this.semicolon();
      return this.finishNode(node, "TSImportEqualsDeclaration");
    }

    tsIsExternalModuleReference() {
      return this.isContextual("require") && this.lookaheadCharCode() === 40;
    }

    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
    }

    tsParseExternalModuleReference() {
      const node = this.startNode();
      this.expectContextual("require");
      this.expect(types.parenL);

      if (!this.match(types.string)) {
        throw this.unexpected();
      }

      node.expression = this.parseExprAtom();
      this.expect(types.parenR);
      return this.finishNode(node, "TSExternalModuleReference");
    }

    tsLookAhead(f) {
      const state = this.state.clone();
      const res = f();
      this.state = state;
      return res;
    }

    tsTryParseAndCatch(f) {
      const result = this.tryParse(abort => f() || abort());
      if (result.aborted || !result.node) return undefined;
      if (result.error) this.state = result.failState;
      return result.node;
    }

    tsTryParse(f) {
      const state = this.state.clone();
      const result = f();

      if (result !== undefined && result !== false) {
        return result;
      } else {
        this.state = state;
        return undefined;
      }
    }

    tsTryParseDeclare(nany) {
      if (this.isLineTerminator()) {
        return;
      }

      let starttype = this.state.type;
      let kind;

      if (this.isContextual("let")) {
        starttype = types._var;
        kind = "let";
      }

      switch (starttype) {
        case types._function:
          return this.parseFunctionStatement(nany, false, true);

        case types._class:
          nany.declare = true;
          return this.parseClass(nany, true, false);

        case types._const:
          if (this.match(types._const) && this.isLookaheadContextual("enum")) {
            this.expect(types._const);
            this.expectContextual("enum");
            return this.tsParseEnumDeclaration(nany, true);
          }

        case types._var:
          kind = kind || this.state.value;
          return this.parseVarStatement(nany, kind);

        case types.name:
          {
            const value = this.state.value;

            if (value === "global") {
              return this.tsParseAmbientExternalModuleDeclaration(nany);
            } else {
              return this.tsParseDeclaration(nany, value, true);
            }
          }
      }
    }

    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, true);
    }

    tsParseExpressionStatement(node, expr) {
      switch (expr.name) {
        case "declare":
          {
            const declaration = this.tsTryParseDeclare(node);

            if (declaration) {
              declaration.declare = true;
              return declaration;
            }

            break;
          }

        case "global":
          if (this.match(types.braceL)) {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            const mod = node;
            mod.global = true;
            mod.id = expr;
            mod.body = this.tsParseModuleBlock();
            this.scope.exit();
            this.prodParam.exit();
            return this.finishNode(mod, "TSModuleDeclaration");
          }

          break;

        default:
          return this.tsParseDeclaration(node, expr.name, false);
      }
    }

    tsParseDeclaration(node, value, next) {
      switch (value) {
        case "abstract":
          if (this.tsCheckLineTerminatorAndMatch(types._class, next)) {
            const cls = node;
            cls.abstract = true;

            if (next) {
              this.next();

              if (!this.match(types._class)) {
                this.unexpected(null, types._class);
              }
            }

            return this.parseClass(cls, true, false);
          }

          break;

        case "enum":
          if (next || this.match(types.name)) {
            if (next) this.next();
            return this.tsParseEnumDeclaration(node, false);
          }

          break;

        case "interface":
          if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
            if (next) this.next();
            return this.tsParseInterfaceDeclaration(node);
          }

          break;

        case "module":
          if (next) this.next();

          if (this.match(types.string)) {
            return this.tsParseAmbientExternalModuleDeclaration(node);
          } else if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
            return this.tsParseModuleOrNamespaceDeclaration(node);
          }

          break;

        case "namespace":
          if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
            if (next) this.next();
            return this.tsParseModuleOrNamespaceDeclaration(node);
          }

          break;

        case "type":
          if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
            if (next) this.next();
            return this.tsParseTypeAliasDeclaration(node);
          }

          break;
      }
    }

    tsCheckLineTerminatorAndMatch(tokenType, next) {
      return (next || this.match(tokenType)) && !this.isLineTerminator();
    }

    tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
      if (!this.isRelational("<")) {
        return undefined;
      }

      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      const oldYieldPos = this.state.yieldPos;
      const oldAwaitPos = this.state.awaitPos;
      this.state.maybeInArrowParameters = true;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      const res = this.tsTryParseAndCatch(() => {
        const node = this.startNodeAt(startPos, startLoc);
        node.typeParameters = this.tsParseTypeParameters();
        super.parseFunctionParams(node);
        node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
        this.expect(types.arrow);
        return node;
      });
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.yieldPos = oldYieldPos;
      this.state.awaitPos = oldAwaitPos;

      if (!res) {
        return undefined;
      }

      return this.parseArrowExpression(res, null, true);
    }

    tsParseTypeArguments() {
      const node = this.startNode();
      node.params = this.tsInType(() => this.tsInNoContext(() => {
        this.expectRelational("<");
        return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
      }));
      this.state.exprAllowed = false;
      this.expectRelational(">");
      return this.finishNode(node, "TSTypeParameterInstantiation");
    }

    tsIsDeclarationStart() {
      if (this.match(types.name)) {
        switch (this.state.value) {
          case "abstract":
          case "declare":
          case "enum":
          case "interface":
          case "module":
          case "namespace":
          case "type":
            return true;
        }
      }

      return false;
    }

    isExportDefaultSpecifier() {
      if (this.tsIsDeclarationStart()) return false;
      return super.isExportDefaultSpecifier();
    }

    parseAssignableListItem(allowModifiers, decorators) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let accessibility;
      let readonly = false;

      if (allowModifiers) {
        accessibility = this.parseAccessModifier();
        readonly = !!this.tsParseModifier(["readonly"]);
      }

      const left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left);
      const elt = this.parseMaybeDefault(left.start, left.loc.start, left);

      if (accessibility || readonly) {
        const pp = this.startNodeAt(startPos, startLoc);

        if (decorators.length) {
          pp.decorators = decorators;
        }

        if (accessibility) pp.accessibility = accessibility;
        if (readonly) pp.readonly = readonly;

        if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
          this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);
        }

        pp.parameter = elt;
        return this.finishNode(pp, "TSParameterProperty");
      }

      if (decorators.length) {
        left.decorators = decorators;
      }

      return elt;
    }

    parseFunctionBodyAndFinish(node, type, isMethod = false) {
      if (this.match(types.colon)) {
        node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);
      }

      const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" ? "TSDeclareMethod" : undefined;

      if (bodilessType && !this.match(types.braceL) && this.isLineTerminator()) {
        this.finishNode(node, bodilessType);
        return;
      }

      super.parseFunctionBodyAndFinish(node, type, isMethod);
    }

    registerFunctionStatementId(node) {
      if (!node.body && node.id) {
        this.checkLVal(node.id, BIND_TS_AMBIENT, null, "function name");
      } else {
        super.registerFunctionStatementId(...arguments);
      }
    }

    parseSubscript(base, startPos, startLoc, noCalls, state) {
      if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {
        this.state.exprAllowed = false;
        this.next();
        const nonNullExpression = this.startNodeAt(startPos, startLoc);
        nonNullExpression.expression = base;
        return this.finishNode(nonNullExpression, "TSNonNullExpression");
      }

      if (this.isRelational("<")) {
        const result = this.tsTryParseAndCatch(() => {
          if (!noCalls && this.atPossibleAsyncArrow(base)) {
            const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);

            if (asyncArrowFn) {
              return asyncArrowFn;
            }
          }

          const node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          const typeArguments = this.tsParseTypeArguments();

          if (typeArguments) {
            if (!noCalls && this.eat(types.parenL)) {
              node.arguments = this.parseCallExpressionArguments(types.parenR, false);
              node.typeParameters = typeArguments;
              return this.finishCallExpression(node, state.optionalChainMember);
            } else if (this.match(types.backQuote)) {
              const result = this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
              result.typeParameters = typeArguments;
              return result;
            }
          }

          this.unexpected();
        });
        if (result) return result;
      }

      return super.parseSubscript(base, startPos, startLoc, noCalls, state);
    }

    parseNewArguments(node) {
      if (this.isRelational("<")) {
        const typeParameters = this.tsTryParseAndCatch(() => {
          const args = this.tsParseTypeArguments();
          if (!this.match(types.parenL)) this.unexpected();
          return args;
        });

        if (typeParameters) {
          node.typeParameters = typeParameters;
        }
      }

      super.parseNewArguments(node);
    }

    parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
      if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
        const node = this.startNodeAt(leftStartPos, leftStartLoc);
        node.expression = left;

        const _const = this.tsTryNextParseConstantContext();

        if (_const) {
          node.typeAnnotation = _const;
        } else {
          node.typeAnnotation = this.tsNextThenParseType();
        }

        this.finishNode(node, "TSAsExpression");
        this.reScan_lt_gt();
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
      }

      return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);
    }

    checkReservedWord(word, startLoc, checkKeywords, isBinding) {}

    checkDuplicateExports() {}

    parseImport(node) {
      if (this.match(types.name) || this.match(types.star) || this.match(types.braceL)) {
        const ahead = this.lookahead();

        if (this.match(types.name) && ahead.type === types.eq) {
          return this.tsParseImportEqualsDeclaration(node);
        }

        if (this.isContextual("type") && ahead.type !== types.comma && !(ahead.type === types.name && ahead.value === "from")) {
          node.importKind = "type";
          this.next();
        } else {
          node.importKind = "value";
        }
      }

      const importNode = super.parseImport(node);

      if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
        this.raise(importNode.start, "A type-only import can specify a default import or named bindings, but not both.");
      }

      return importNode;
    }

    parseExport(node) {
      if (this.match(types._import)) {
        this.expect(types._import);
        return this.tsParseImportEqualsDeclaration(node, true);
      } else if (this.eat(types.eq)) {
        const assign = node;
        assign.expression = this.parseExpression();
        this.semicolon();
        return this.finishNode(assign, "TSExportAssignment");
      } else if (this.eatContextual("as")) {
        const decl = node;
        this.expectContextual("namespace");
        decl.id = this.parseIdentifier();
        this.semicolon();
        return this.finishNode(decl, "TSNamespaceExportDeclaration");
      } else {
        if (this.isContextual("type") && this.lookahead().type === types.braceL) {
          this.next();
          node.exportKind = "type";
        } else {
          node.exportKind = "value";
        }

        return super.parseExport(node);
      }
    }

    isAbstractClass() {
      return this.isContextual("abstract") && this.lookahead().type === types._class;
    }

    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const cls = this.startNode();
        this.next();
        this.parseClass(cls, true, true);
        cls.abstract = true;
        return cls;
      }

      if (this.state.value === "interface") {
        const result = this.tsParseDeclaration(this.startNode(), this.state.value, true);
        if (result) return result;
      }

      return super.parseExportDefaultExpression();
    }

    parseStatementContent(context, topLevel) {
      if (this.state.type === types._const) {
        const ahead = this.lookahead();

        if (ahead.type === types.name && ahead.value === "enum") {
          const node = this.startNode();
          this.expect(types._const);
          this.expectContextual("enum");
          return this.tsParseEnumDeclaration(node, true);
        }
      }

      return super.parseStatementContent(context, topLevel);
    }

    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }

    parseClassMember(classBody, member, state, constructorAllowsSuper) {
      this.tsParseModifiers(member, ["declare"]);
      const accessibility = this.parseAccessModifier();
      if (accessibility) member.accessibility = accessibility;
      this.tsParseModifiers(member, ["declare"]);
      super.parseClassMember(classBody, member, state, constructorAllowsSuper);
    }

    parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {
      this.tsParseModifiers(member, ["abstract", "readonly", "declare"]);
      const idx = this.tsTryParseIndexSignature(member);

      if (idx) {
        classBody.body.push(idx);

        if (member.abstract) {
          this.raise(member.start, TSErrors.IndexSignatureHasAbstract);
        }

        if (isStatic) {
          this.raise(member.start, TSErrors.IndexSignatureHasStatic);
        }

        if (member.accessibility) {
          this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);
        }

        return;
      }

      super.parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper);
    }

    parsePostMemberNameModifiers(methodOrProp) {
      const optional = this.eat(types.question);
      if (optional) methodOrProp.optional = true;

      if (methodOrProp.readonly && this.match(types.parenL)) {
        this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);
      }

      if (methodOrProp.declare && this.match(types.parenL)) {
        this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);
      }
    }

    parseExpressionStatement(node, expr) {
      const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : undefined;
      return decl || super.parseExpressionStatement(node, expr);
    }

    shouldParseExportDeclaration() {
      if (this.tsIsDeclarationStart()) return true;
      return super.shouldParseExportDeclaration();
    }

    parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {
      if (!refNeedsArrowPos || !this.match(types.question)) {
        return super.parseConditional(expr, startPos, startLoc, refNeedsArrowPos);
      }

      const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));

      if (!result.node) {
        refNeedsArrowPos.start = result.error.pos || this.state.start;
        return expr;
      }

      if (result.error) this.state = result.failState;
      return result.node;
    }

    parseParenItem(node, startPos, startLoc) {
      node = super.parseParenItem(node, startPos, startLoc);

      if (this.eat(types.question)) {
        node.optional = true;
        this.resetEndLocation(node);
      }

      if (this.match(types.colon)) {
        const typeCastNode = this.startNodeAt(startPos, startLoc);
        typeCastNode.expression = node;
        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
        return this.finishNode(typeCastNode, "TSTypeCastExpression");
      }

      return node;
    }

    parseExportDeclaration(node) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const isDeclare = this.eatContextual("declare");
      let declaration;

      if (this.match(types.name)) {
        declaration = this.tsTryParseExportDeclaration();
      }

      if (!declaration) {
        declaration = super.parseExportDeclaration(node);
      }

      if (declaration && (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare)) {
        node.exportKind = "type";
      }

      if (declaration && isDeclare) {
        this.resetStartLocation(declaration, startPos, startLoc);
        declaration.declare = true;
      }

      return declaration;
    }

    parseClassId(node, isStatement, optionalId) {
      if ((!isStatement || optionalId) && this.isContextual("implements")) {
        return;
      }

      super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters) node.typeParameters = typeParameters;
    }

    parseClassPropertyAnnotation(node) {
      if (!node.optional && this.eat(types.bang)) {
        node.definite = true;
      }

      const type = this.tsTryParseTypeAnnotation();
      if (type) node.typeAnnotation = type;
    }

    parseClassProperty(node) {
      this.parseClassPropertyAnnotation(node);

      if (node.declare && this.match(types.equal)) {
        this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);
      }

      return super.parseClassProperty(node);
    }

    parseClassPrivateProperty(node) {
      if (node.abstract) {
        this.raise(node.start, TSErrors.PrivateElementHasAbstract);
      }

      if (node.accessibility) {
        this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility);
      }

      this.parseClassPropertyAnnotation(node);
      return super.parseClassPrivateProperty(node);
    }

    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters) method.typeParameters = typeParameters;
      super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
    }

    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters) method.typeParameters = typeParameters;
      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    }

    parseClassSuper(node) {
      super.parseClassSuper(node);

      if (node.superClass && this.isRelational("<")) {
        node.superTypeParameters = this.tsParseTypeArguments();
      }

      if (this.eatContextual("implements")) {
        node.implements = this.tsParseHeritageClause("implements");
      }
    }

    parseObjPropValue(prop, ...args) {
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters) prop.typeParameters = typeParameters;
      super.parseObjPropValue(prop, ...args);
    }

    parseFunctionParams(node, allowModifiers) {
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters) node.typeParameters = typeParameters;
      super.parseFunctionParams(node, allowModifiers);
    }

    parseVarId(decl, kind) {
      super.parseVarId(decl, kind);

      if (decl.id.type === "Identifier" && this.eat(types.bang)) {
        decl.definite = true;
      }

      const type = this.tsTryParseTypeAnnotation();

      if (type) {
        decl.id.typeAnnotation = type;
        this.resetEndLocation(decl.id);
      }
    }

    parseAsyncArrowFromCallExpression(node, call) {
      if (this.match(types.colon)) {
        node.returnType = this.tsParseTypeAnnotation();
      }

      return super.parseAsyncArrowFromCallExpression(node, call);
    }

    parseMaybeAssign(...args) {
      var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;

      let state;
      let jsx;
      let typeCast;

      if (this.match(types.jsxTagStart)) {
        state = this.state.clone();
        jsx = this.tryParse(() => super.parseMaybeAssign(...args), state);
        if (!jsx.error) return jsx.node;
        const {
          context
        } = this.state;

        if (context[context.length - 1] === types$1.j_oTag) {
          context.length -= 2;
        } else if (context[context.length - 1] === types$1.j_expr) {
          context.length -= 1;
        }
      }

      if (!((_jsx = jsx) == null ? void 0 : _jsx.error) && !this.isRelational("<")) {
        return super.parseMaybeAssign(...args);
      }

      let typeParameters;
      state = state || this.state.clone();
      const arrow = this.tryParse(abort => {
        var _typeParameters;

        typeParameters = this.tsParseTypeParameters();
        const expr = super.parseMaybeAssign(...args);

        if (expr.type !== "ArrowFunctionExpression" || expr.extra && expr.extra.parenthesized) {
          abort();
        }

        if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
          this.resetStartLocationFromNode(expr, typeParameters);
        }

        expr.typeParameters = typeParameters;
        return expr;
      }, state);
      if (!arrow.error && !arrow.aborted) return arrow.node;

      if (!jsx) {
        assert(!this.hasPlugin("jsx"));
        typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);
        if (!typeCast.error) return typeCast.node;
      }

      if ((_jsx2 = jsx) == null ? void 0 : _jsx2.node) {
        this.state = jsx.failState;
        return jsx.node;
      }

      if (arrow.node) {
        this.state = arrow.failState;
        return arrow.node;
      }

      if ((_typeCast = typeCast) == null ? void 0 : _typeCast.node) {
        this.state = typeCast.failState;
        return typeCast.node;
      }

      if ((_jsx3 = jsx) == null ? void 0 : _jsx3.thrown) throw jsx.error;
      if (arrow.thrown) throw arrow.error;
      if ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.thrown) throw typeCast.error;
      throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
    }

    parseMaybeUnary(refExpressionErrors) {
      if (!this.hasPlugin("jsx") && this.isRelational("<")) {
        return this.tsParseTypeAssertion();
      } else {
        return super.parseMaybeUnary(refExpressionErrors);
      }
    }

    parseArrow(node) {
      if (this.match(types.colon)) {
        const result = this.tryParse(abort => {
          const returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);
          if (this.canInsertSemicolon() || !this.match(types.arrow)) abort();
          return returnType;
        });
        if (result.aborted) return;

        if (!result.thrown) {
          if (result.error) this.state = result.failState;
          node.returnType = result.node;
        }
      }

      return super.parseArrow(node);
    }

    parseAssignableListItemTypes(param) {
      if (this.eat(types.question)) {
        if (param.type !== "Identifier") {
          this.raise(param.start, TSErrors.PatternIsOptional);
        }

        param.optional = true;
      }

      const type = this.tsTryParseTypeAnnotation();
      if (type) param.typeAnnotation = type;
      this.resetEndLocation(param);
      return param;
    }

    toAssignable(node) {
      switch (node.type) {
        case "TSTypeCastExpression":
          return super.toAssignable(this.typeCastToParameter(node));

        case "TSParameterProperty":
          return super.toAssignable(node);

        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          node.expression = this.toAssignable(node.expression);
          return node;

        default:
          return super.toAssignable(node);
      }
    }

    checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription) {
      switch (expr.type) {
        case "TSTypeCastExpression":
          return;

        case "TSParameterProperty":
          this.checkLVal(expr.parameter, bindingType, checkClashes, "parameter property");
          return;

        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          this.checkLVal(expr.expression, bindingType, checkClashes, contextDescription);
          return;

        default:
          super.checkLVal(expr, bindingType, checkClashes, contextDescription);
          return;
      }
    }

    parseBindingAtom() {
      switch (this.state.type) {
        case types._this:
          return this.parseIdentifier(true);

        default:
          return super.parseBindingAtom();
      }
    }

    parseMaybeDecoratorArguments(expr) {
      if (this.isRelational("<")) {
        const typeArguments = this.tsParseTypeArguments();

        if (this.match(types.parenL)) {
          const call = super.parseMaybeDecoratorArguments(expr);
          call.typeParameters = typeArguments;
          return call;
        }

        this.unexpected(this.state.start, types.parenL);
      }

      return super.parseMaybeDecoratorArguments(expr);
    }

    isClassMethod() {
      return this.isRelational("<") || super.isClassMethod();
    }

    isClassProperty() {
      return this.match(types.bang) || this.match(types.colon) || super.isClassProperty();
    }

    parseMaybeDefault(...args) {
      const node = super.parseMaybeDefault(...args);

      if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
        this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);
      }

      return node;
    }

    getTokenFromCode(code) {
      if (this.state.inType && (code === 62 || code === 60)) {
        return this.finishOp(types.relational, 1);
      } else {
        return super.getTokenFromCode(code);
      }
    }

    reScan_lt_gt() {
      if (this.match(types.relational)) {
        const code = this.input.charCodeAt(this.state.start);

        if (code === 60 || code === 62) {
          this.state.pos -= 1;
          this.readToken_lt_gt(code);
        }
      }
    }

    toAssignableList(exprList) {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i];
        if (!expr) continue;

        switch (expr.type) {
          case "TSTypeCastExpression":
            exprList[i] = this.typeCastToParameter(expr);
            break;

          case "TSAsExpression":
          case "TSTypeAssertion":
            if (!this.state.maybeInArrowParameters) {
              exprList[i] = this.typeCastToParameter(expr);
            } else {
              this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);
            }

            break;
        }
      }

      return super.toAssignableList(...arguments);
    }

    typeCastToParameter(node) {
      node.expression.typeAnnotation = node.typeAnnotation;
      this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
      return node.expression;
    }

    toReferencedList(exprList, isInParens) {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i];

        if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
          this.raise(expr.start, TSErrors.UnexpectedTypeAnnotation);
        }
      }

      return exprList;
    }

    shouldParseArrow() {
      return this.match(types.colon) || super.shouldParseArrow();
    }

    shouldParseAsyncArrow() {
      return this.match(types.colon) || super.shouldParseAsyncArrow();
    }

    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }

    jsxParseOpeningElementAfterName(node) {
      if (this.isRelational("<")) {
        const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
        if (typeArguments) node.typeParameters = typeArguments;
      }

      return super.jsxParseOpeningElementAfterName(node);
    }

    getGetterSetterExpectedParamCount(method) {
      const baseCount = super.getGetterSetterExpectedParamCount(method);
      const firstParam = method.params[0];
      const hasContextParam = firstParam && firstParam.type === "Identifier" && firstParam.name === "this";
      return hasContextParam ? baseCount + 1 : baseCount;
    }

    parseCatchClauseParam() {
      const param = super.parseCatchClauseParam();
      const type = this.tsTryParseTypeAnnotation();

      if (type) {
        param.typeAnnotation = type;
        this.resetEndLocation(param);
      }

      return param;
    }

  });

  types.placeholder = new TokenType("%%", {
    startsExpr: true
  });
  var placeholders = (superClass => class extends superClass {
    parsePlaceholder(expectedNode) {
      if (this.match(types.placeholder)) {
        const node = this.startNode();
        this.next();
        this.assertNoSpace("Unexpected space in placeholder.");
        node.name = super.parseIdentifier(true);
        this.assertNoSpace("Unexpected space in placeholder.");
        this.expect(types.placeholder);
        return this.finishPlaceholder(node, expectedNode);
      }
    }

    finishPlaceholder(node, expectedNode) {
      const isFinished = !!(node.expectedNode && node.type === "Placeholder");
      node.expectedNode = expectedNode;
      return isFinished ? node : this.finishNode(node, "Placeholder");
    }

    getTokenFromCode(code) {
      if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
        return this.finishOp(types.placeholder, 2);
      }

      return super.getTokenFromCode(...arguments);
    }

    parseExprAtom() {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
    }

    parseIdentifier() {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
    }

    checkReservedWord(word) {
      if (word !== undefined) super.checkReservedWord(...arguments);
    }

    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
    }

    checkLVal(expr) {
      if (expr.type !== "Placeholder") super.checkLVal(...arguments);
    }

    toAssignable(node) {
      if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
        node.expectedNode = "Pattern";
        return node;
      }

      return super.toAssignable(...arguments);
    }

    verifyBreakContinue(node) {
      if (node.label && node.label.type === "Placeholder") return;
      super.verifyBreakContinue(...arguments);
    }

    parseExpressionStatement(node, expr) {
      if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
        return super.parseExpressionStatement(...arguments);
      }

      if (this.match(types.colon)) {
        const stmt = node;
        stmt.label = this.finishPlaceholder(expr, "Identifier");
        this.next();
        stmt.body = this.parseStatement("label");
        return this.finishNode(stmt, "LabeledStatement");
      }

      this.semicolon();
      node.name = expr.name;
      return this.finishPlaceholder(node, "Statement");
    }

    parseBlock() {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
    }

    parseFunctionId() {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
    }

    parseClass(node, isStatement, optionalId) {
      const type = isStatement ? "ClassDeclaration" : "ClassExpression";
      this.next();
      this.takeDecorators(node);
      const oldStrict = this.state.strict;
      const placeholder = this.parsePlaceholder("Identifier");

      if (placeholder) {
        if (this.match(types._extends) || this.match(types.placeholder) || this.match(types.braceL)) {
          node.id = placeholder;
        } else if (optionalId || !isStatement) {
          node.id = null;
          node.body = this.finishPlaceholder(placeholder, "ClassBody");
          return this.finishNode(node, type);
        } else {
          this.unexpected(null, "A class name is required");
        }
      } else {
        this.parseClassId(node, isStatement, optionalId);
      }

      this.parseClassSuper(node);
      node.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node.superClass, oldStrict);
      return this.finishNode(node, type);
    }

    parseExport(node) {
      const placeholder = this.parsePlaceholder("Identifier");
      if (!placeholder) return super.parseExport(...arguments);

      if (!this.isContextual("from") && !this.match(types.comma)) {
        node.specifiers = [];
        node.source = null;
        node.declaration = this.finishPlaceholder(placeholder, "Declaration");
        return this.finishNode(node, "ExportNamedDeclaration");
      }

      this.expectPlugin("exportDefaultFrom");
      const specifier = this.startNode();
      specifier.exported = placeholder;
      node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
      return super.parseExport(node);
    }

    isExportDefaultSpecifier() {
      if (this.match(types._default)) {
        const next = this.nextTokenStart();

        if (this.isUnparsedContextual(next, "from")) {
          if (this.input.startsWith(types.placeholder.label, this.nextTokenStartSince(next + 4))) {
            return true;
          }
        }
      }

      return super.isExportDefaultSpecifier();
    }

    maybeParseExportDefaultSpecifier(node) {
      if (node.specifiers && node.specifiers.length > 0) {
        return true;
      }

      return super.maybeParseExportDefaultSpecifier(...arguments);
    }

    checkExport(node) {
      const {
        specifiers
      } = node;

      if (specifiers == null ? void 0 : specifiers.length) {
        node.specifiers = specifiers.filter(node => node.exported.type === "Placeholder");
      }

      super.checkExport(node);
      node.specifiers = specifiers;
    }

    parseImport(node) {
      const placeholder = this.parsePlaceholder("Identifier");
      if (!placeholder) return super.parseImport(...arguments);
      node.specifiers = [];

      if (!this.isContextual("from") && !this.match(types.comma)) {
        node.source = this.finishPlaceholder(placeholder, "StringLiteral");
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }

      const specifier = this.startNodeAtNode(placeholder);
      specifier.local = placeholder;
      this.finishNode(specifier, "ImportDefaultSpecifier");
      node.specifiers.push(specifier);

      if (this.eat(types.comma)) {
        const hasStarImport = this.maybeParseStarImportSpecifier(node);
        if (!hasStarImport) this.parseNamedImportSpecifiers(node);
      }

      this.expectContextual("from");
      node.source = this.parseImportSource();
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    }

    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
    }

  });

  var v8intrinsic = (superClass => class extends superClass {
    parseV8Intrinsic() {
      if (this.match(types.modulo)) {
        const v8IntrinsicStart = this.state.start;
        const node = this.startNode();
        this.eat(types.modulo);

        if (this.match(types.name)) {
          const name = this.parseIdentifierName(this.state.start);
          const identifier = this.createIdentifier(node, name);
          identifier.type = "V8IntrinsicIdentifier";

          if (this.match(types.parenL)) {
            return identifier;
          }
        }

        this.unexpected(v8IntrinsicStart);
      }
    }

    parseExprAtom() {
      return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
    }

  });

  function hasPlugin(plugins, name) {
    return plugins.some(plugin => {
      if (Array.isArray(plugin)) {
        return plugin[0] === name;
      } else {
        return plugin === name;
      }
    });
  }
  function getPluginOption(plugins, name, option) {
    const plugin = plugins.find(plugin => {
      if (Array.isArray(plugin)) {
        return plugin[0] === name;
      } else {
        return plugin === name;
      }
    });

    if (plugin && Array.isArray(plugin)) {
      return plugin[1][option];
    }

    return null;
  }
  const PIPELINE_PROPOSALS = ["minimal", "smart", "fsharp"];
  const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
  function validatePlugins(plugins) {
    if (hasPlugin(plugins, "decorators")) {
      if (hasPlugin(plugins, "decorators-legacy")) {
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      }

      const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");

      if (decoratorsBeforeExport == null) {
        throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you are migrating from" + " Babylon/Babel 6 or want to use the old decorators proposal, you" + " should use the 'decorators-legacy' plugin instead of 'decorators'.");
      } else if (typeof decoratorsBeforeExport !== "boolean") {
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
      }
    }

    if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
      throw new Error("Cannot combine flow and typescript plugins.");
    }

    if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    }

    if (hasPlugin(plugins, "pipelineOperator") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, "pipelineOperator", "proposal"))) {
      throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + PIPELINE_PROPOSALS.map(p => `'${p}'`).join(", "));
    }

    if (hasPlugin(plugins, "moduleAttributes")) {
      const moduleAttributesVerionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");

      if (moduleAttributesVerionPluginOption !== "may-2020") {
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is 'may-2020'.");
      }
    }

    if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
      throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(", "));
    }
  }
  const mixinPlugins = {
    estree,
    jsx,
    flow,
    typescript,
    v8intrinsic,
    placeholders
  };
  const mixinPluginNames = Object.keys(mixinPlugins);

  const defaultOptions = {
    sourceType: "script",
    sourceFilename: undefined,
    startLine: 1,
    allowAwaitOutsideFunction: false,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowSuperOutsideMethod: false,
    allowUndeclaredExports: false,
    plugins: [],
    strictMode: null,
    ranges: false,
    tokens: false,
    createParenthesizedExpressions: false,
    errorRecovery: false
  };
  function getOptions(opts) {
    const options = {};

    for (let _i = 0, _Object$keys = Object.keys(defaultOptions); _i < _Object$keys.length; _i++) {
      const key = _Object$keys[_i];
      options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
    }

    return options;
  }

  class State {
    constructor() {
      this.errors = [];
      this.potentialArrowAt = -1;
      this.noArrowAt = [];
      this.noArrowParamsConversionAt = [];
      this.inParameters = false;
      this.maybeInArrowParameters = false;
      this.maybeInAsyncArrowHead = false;
      this.inPipeline = false;
      this.inType = false;
      this.noAnonFunctionType = false;
      this.inPropertyName = false;
      this.hasFlowComment = false;
      this.isIterator = false;
      this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      this.soloAwait = false;
      this.inFSharpPipelineDirectBody = false;
      this.labels = [];
      this.decoratorStack = [[]];
      this.yieldPos = -1;
      this.awaitPos = -1;
      this.comments = [];
      this.trailingComments = [];
      this.leadingComments = [];
      this.commentStack = [];
      this.commentPreviousNode = null;
      this.pos = 0;
      this.lineStart = 0;
      this.type = types.eof;
      this.value = null;
      this.start = 0;
      this.end = 0;
      this.lastTokEndLoc = null;
      this.lastTokStartLoc = null;
      this.lastTokStart = 0;
      this.lastTokEnd = 0;
      this.context = [types$1.braceStatement];
      this.exprAllowed = true;
      this.containsEsc = false;
      this.octalPositions = [];
      this.exportedIdentifiers = [];
      this.tokensLength = 0;
    }

    init(options) {
      this.strict = options.strictMode === false ? false : options.sourceType === "module";
      this.curLine = options.startLine;
      this.startLoc = this.endLoc = this.curPosition();
    }

    curPosition() {
      return new Position(this.curLine, this.pos - this.lineStart);
    }

    clone(skipArrays) {
      const state = new State();
      const keys = Object.keys(this);

      for (let i = 0, length = keys.length; i < length; i++) {
        const key = keys[i];
        let val = this[key];

        if (!skipArrays && Array.isArray(val)) {
          val = val.slice();
        }

        state[key] = val;
      }

      return state;
    }

  }

  var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
  };
  const VALID_REGEX_FLAGS = new Set(["g", "m", "s", "i", "y", "u"]);
  const forbiddenNumericSeparatorSiblings = {
    decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
    hex: [46, 88, 95, 120]
  };
  const allowedNumericSeparatorSiblings = {};
  allowedNumericSeparatorSiblings.bin = [48, 49];
  allowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];
  allowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];
  allowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
  class Token {
    constructor(state) {
      this.type = state.type;
      this.value = state.value;
      this.start = state.start;
      this.end = state.end;
      this.loc = new SourceLocation(state.startLoc, state.endLoc);
    }

  }
  class Tokenizer extends ParserError {
    constructor(options, input) {
      super();
      this.tokens = [];
      this.state = new State();
      this.state.init(options);
      this.input = input;
      this.length = input.length;
      this.isLookahead = false;
    }

    pushToken(token) {
      this.tokens.length = this.state.tokensLength;
      this.tokens.push(token);
      ++this.state.tokensLength;
    }

    next() {
      if (!this.isLookahead) {
        this.checkKeywordEscapes();

        if (this.options.tokens) {
          this.pushToken(new Token(this.state));
        }
      }

      this.state.lastTokEnd = this.state.end;
      this.state.lastTokStart = this.state.start;
      this.state.lastTokEndLoc = this.state.endLoc;
      this.state.lastTokStartLoc = this.state.startLoc;
      this.nextToken();
    }

    eat(type) {
      if (this.match(type)) {
        this.next();
        return true;
      } else {
        return false;
      }
    }

    match(type) {
      return this.state.type === type;
    }

    lookahead() {
      const old = this.state;
      this.state = old.clone(true);
      this.isLookahead = true;
      this.next();
      this.isLookahead = false;
      const curr = this.state;
      this.state = old;
      return curr;
    }

    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }

    nextTokenStartSince(pos) {
      skipWhiteSpace.lastIndex = pos;
      const skip = skipWhiteSpace.exec(this.input);
      return pos + skip[0].length;
    }

    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }

    setStrict(strict) {
      this.state.strict = strict;
      if (!this.match(types.num) && !this.match(types.string)) return;
      this.state.pos = this.state.start;

      while (this.state.pos < this.state.lineStart) {
        this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
        --this.state.curLine;
      }

      this.nextToken();
    }

    curContext() {
      return this.state.context[this.state.context.length - 1];
    }

    nextToken() {
      const curContext = this.curContext();
      if (!(curContext == null ? void 0 : curContext.preserveSpace)) this.skipSpace();
      this.state.octalPositions = [];
      this.state.start = this.state.pos;
      this.state.startLoc = this.state.curPosition();

      if (this.state.pos >= this.length) {
        this.finishToken(types.eof);
        return;
      }

      const override = curContext == null ? void 0 : curContext.override;

      if (override) {
        override(this);
      } else {
        this.getTokenFromCode(this.input.codePointAt(this.state.pos));
      }
    }

    pushComment(block, text, start, end, startLoc, endLoc) {
      const comment = {
        type: block ? "CommentBlock" : "CommentLine",
        value: text,
        start: start,
        end: end,
        loc: new SourceLocation(startLoc, endLoc)
      };
      if (this.options.tokens) this.pushToken(comment);
      this.state.comments.push(comment);
      this.addComment(comment);
    }

    skipBlockComment() {
      const startLoc = this.state.curPosition();
      const start = this.state.pos;
      const end = this.input.indexOf("*/", this.state.pos + 2);
      if (end === -1) throw this.raise(start, ErrorMessages.UnterminatedComment);
      this.state.pos = end + 2;
      lineBreakG.lastIndex = start;
      let match;

      while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {
        ++this.state.curLine;
        this.state.lineStart = match.index + match[0].length;
      }

      if (this.isLookahead) return;
      this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
    }

    skipLineComment(startSkip) {
      const start = this.state.pos;
      const startLoc = this.state.curPosition();
      let ch = this.input.charCodeAt(this.state.pos += startSkip);

      if (this.state.pos < this.length) {
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
      }

      if (this.isLookahead) return;
      this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
    }

    skipSpace() {
      loop: while (this.state.pos < this.length) {
        const ch = this.input.charCodeAt(this.state.pos);

        switch (ch) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;

          case 13:
            if (this.input.charCodeAt(this.state.pos + 1) === 10) {
              ++this.state.pos;
            }

          case 10:
          case 8232:
          case 8233:
            ++this.state.pos;
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            break;

          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42:
                this.skipBlockComment();
                break;

              case 47:
                this.skipLineComment(2);
                break;

              default:
                break loop;
            }

            break;

          default:
            if (isWhitespace(ch)) {
              ++this.state.pos;
            } else {
              break loop;
            }

        }
      }
    }

    finishToken(type, val) {
      this.state.end = this.state.pos;
      this.state.endLoc = this.state.curPosition();
      const prevType = this.state.type;
      this.state.type = type;
      this.state.value = val;
      if (!this.isLookahead) this.updateContext(prevType);
    }

    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) {
        return;
      }

      const nextPos = this.state.pos + 1;
      const next = this.input.charCodeAt(nextPos);

      if (next >= 48 && next <= 57) {
        throw this.raise(this.state.pos, ErrorMessages.UnexpectedDigitAfterHash);
      }

      if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
        this.expectPlugin("recordAndTuple");

        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
          throw this.raise(this.state.pos, next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType);
        }

        if (next === 123) {
          this.finishToken(types.braceHashL);
        } else {
          this.finishToken(types.bracketHashL);
        }

        this.state.pos += 2;
      } else {
        this.finishOp(types.hash, 1);
      }
    }

    readToken_dot() {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next >= 48 && next <= 57) {
        this.readNumber(true);
        return;
      }

      if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
        this.state.pos += 3;
        this.finishToken(types.ellipsis);
      } else {
        ++this.state.pos;
        this.finishToken(types.dot);
      }
    }

    readToken_slash() {
      if (this.state.exprAllowed && !this.state.inType) {
        ++this.state.pos;
        this.readRegexp();
        return;
      }

      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.slash, 1);
      }
    }

    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return false;
      let ch = this.input.charCodeAt(this.state.pos + 1);
      if (ch !== 33) return false;
      const start = this.state.pos;
      this.state.pos += 1;

      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos);
      }

      const value = this.input.slice(start + 2, this.state.pos);
      this.finishToken(types.interpreterDirective, value);
      return true;
    }

    readToken_mult_modulo(code) {
      let type = code === 42 ? types.star : types.modulo;
      let width = 1;
      let next = this.input.charCodeAt(this.state.pos + 1);
      const exprAllowed = this.state.exprAllowed;

      if (code === 42 && next === 42) {
        width++;
        next = this.input.charCodeAt(this.state.pos + 2);
        type = types.exponent;
      }

      if (next === 61 && !exprAllowed) {
        width++;
        type = types.assign;
      }

      this.finishOp(type, width);
    }

    readToken_pipe_amp(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
          this.finishOp(types.assign, 3);
        } else {
          this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
        }

        return;
      }

      if (code === 124) {
        if (next === 62) {
          this.finishOp(types.pipeline, 2);
          return;
        }

        if (this.hasPlugin("recordAndTuple") && next === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType);
          }

          this.finishOp(types.braceBarR, 2);
          return;
        }

        if (this.hasPlugin("recordAndTuple") && next === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType);
          }

          this.finishOp(types.bracketBarR, 2);
          return;
        }
      }

      if (next === 61) {
        this.finishOp(types.assign, 2);
        return;
      }

      this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
    }

    readToken_caret() {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.bitwiseXOR, 1);
      }
    }

    readToken_plus_min(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || this.hasPrecedingLineBreak())) {
          this.skipLineComment(3);
          this.skipSpace();
          this.nextToken();
          return;
        }

        this.finishOp(types.incDec, 2);
        return;
      }

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.plusMin, 1);
      }
    }

    readToken_lt_gt(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      let size = 1;

      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;

        if (this.input.charCodeAt(this.state.pos + size) === 61) {
          this.finishOp(types.assign, size + 1);
          return;
        }

        this.finishOp(types.bitShift, size);
        return;
      }

      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
        this.skipLineComment(4);
        this.skipSpace();
        this.nextToken();
        return;
      }

      if (next === 61) {
        size = 2;
      }

      this.finishOp(types.relational, size);
    }

    readToken_eq_excl(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }

      if (code === 61 && next === 62) {
        this.state.pos += 2;
        this.finishToken(types.arrow);
        return;
      }

      this.finishOp(code === 61 ? types.eq : types.bang, 1);
    }

    readToken_question() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      const next2 = this.input.charCodeAt(this.state.pos + 2);

      if (next === 63) {
        if (next2 === 61) {
          this.finishOp(types.assign, 3);
        } else {
          this.finishOp(types.nullishCoalescing, 2);
        }
      } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
        this.state.pos += 2;
        this.finishToken(types.questionDot);
      } else {
        ++this.state.pos;
        this.finishToken(types.question);
      }
    }

    getTokenFromCode(code) {
      switch (code) {
        case 46:
          this.readToken_dot();
          return;

        case 40:
          ++this.state.pos;
          this.finishToken(types.parenL);
          return;

        case 41:
          ++this.state.pos;
          this.finishToken(types.parenR);
          return;

        case 59:
          ++this.state.pos;
          this.finishToken(types.semi);
          return;

        case 44:
          ++this.state.pos;
          this.finishToken(types.comma);
          return;

        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType);
            }

            this.finishToken(types.bracketBarL);
            this.state.pos += 2;
          } else {
            ++this.state.pos;
            this.finishToken(types.bracketL);
          }

          return;

        case 93:
          ++this.state.pos;
          this.finishToken(types.bracketR);
          return;

        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType);
            }

            this.finishToken(types.braceBarL);
            this.state.pos += 2;
          } else {
            ++this.state.pos;
            this.finishToken(types.braceL);
          }

          return;

        case 125:
          ++this.state.pos;
          this.finishToken(types.braceR);
          return;

        case 58:
          if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
            this.finishOp(types.doubleColon, 2);
          } else {
            ++this.state.pos;
            this.finishToken(types.colon);
          }

          return;

        case 63:
          this.readToken_question();
          return;

        case 96:
          ++this.state.pos;
          this.finishToken(types.backQuote);
          return;

        case 48:
          {
            const next = this.input.charCodeAt(this.state.pos + 1);

            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }

            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }

            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }

        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;

        case 34:
        case 39:
          this.readString(code);
          return;

        case 47:
          this.readToken_slash();
          return;

        case 37:
        case 42:
          this.readToken_mult_modulo(code);
          return;

        case 124:
        case 38:
          this.readToken_pipe_amp(code);
          return;

        case 94:
          this.readToken_caret();
          return;

        case 43:
        case 45:
          this.readToken_plus_min(code);
          return;

        case 60:
        case 62:
          this.readToken_lt_gt(code);
          return;

        case 61:
        case 33:
          this.readToken_eq_excl(code);
          return;

        case 126:
          this.finishOp(types.tilde, 1);
          return;

        case 64:
          ++this.state.pos;
          this.finishToken(types.at);
          return;

        case 35:
          this.readToken_numberSign();
          return;

        case 92:
          this.readWord();
          return;

        default:
          if (isIdentifierStart(code)) {
            this.readWord();
            return;
          }

      }

      throw this.raise(this.state.pos, ErrorMessages.InvalidOrUnexpectedToken, String.fromCodePoint(code));
    }

    finishOp(type, size) {
      const str = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size;
      this.finishToken(type, str);
    }

    readRegexp() {
      const start = this.state.pos;
      let escaped, inClass;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(start, ErrorMessages.UnterminatedRegExp);
        }

        const ch = this.input.charAt(this.state.pos);

        if (lineBreak.test(ch)) {
          throw this.raise(start, ErrorMessages.UnterminatedRegExp);
        }

        if (escaped) {
          escaped = false;
        } else {
          if (ch === "[") {
            inClass = true;
          } else if (ch === "]" && inClass) {
            inClass = false;
          } else if (ch === "/" && !inClass) {
            break;
          }

          escaped = ch === "\\";
        }

        ++this.state.pos;
      }

      const content = this.input.slice(start, this.state.pos);
      ++this.state.pos;
      let mods = "";

      while (this.state.pos < this.length) {
        const char = this.input[this.state.pos];
        const charCode = this.input.codePointAt(this.state.pos);

        if (VALID_REGEX_FLAGS.has(char)) {
          if (mods.indexOf(char) > -1) {
            this.raise(this.state.pos + 1, ErrorMessages.DuplicateRegExpFlags);
          }
        } else if (isIdentifierChar(charCode) || charCode === 92) {
          this.raise(this.state.pos + 1, ErrorMessages.MalformedRegExpFlags);
        } else {
          break;
        }

        ++this.state.pos;
        mods += char;
      }

      this.finishToken(types.regexp, {
        pattern: content,
        flags: mods
      });
    }

    readInt(radix, len, forceLen, allowNumSeparator = true) {
      const start = this.state.pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
      let invalid = false;
      let total = 0;

      for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code = this.input.charCodeAt(this.state.pos);
        let val;

        if (code === 95) {
          const prev = this.input.charCodeAt(this.state.pos - 1);
          const next = this.input.charCodeAt(this.state.pos + 1);

          if (allowedSiblings.indexOf(next) === -1) {
            this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
          } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
            this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
          }

          if (!allowNumSeparator) {
            this.raise(this.state.pos, ErrorMessages.NumericSeparatorInEscapeSequence);
          }

          ++this.state.pos;
          continue;
        }

        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (_isDigit(code)) {
          val = code - 48;
        } else {
          val = Infinity;
        }

        if (val >= radix) {
          if (this.options.errorRecovery && val <= 9) {
            val = 0;
            this.raise(this.state.start + i + 2, ErrorMessages.InvalidDigit, radix);
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }

        ++this.state.pos;
        total = total * radix + val;
      }

      if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
        return null;
      }

      return total;
    }

    readRadixNumber(radix) {
      const start = this.state.pos;
      let isBigInt = false;
      this.state.pos += 2;
      const val = this.readInt(radix);

      if (val == null) {
        this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix);
      }

      const next = this.input.charCodeAt(this.state.pos);

      if (next === 110) {
        ++this.state.pos;
        isBigInt = true;
      } else if (next === 109) {
        throw this.raise(start, ErrorMessages.InvalidDecimal);
      }

      if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
        throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
      }

      if (isBigInt) {
        const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(types.bigint, str);
        return;
      }

      this.finishToken(types.num, val);
    }

    readNumber(startsWithDot) {
      const start = this.state.pos;
      let isFloat = false;
      let isBigInt = false;
      let isDecimal = false;
      let hasExponent = false;
      let isOctal = false;

      if (!startsWithDot && this.readInt(10) === null) {
        this.raise(start, ErrorMessages.InvalidNumber);
      }

      const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;

      if (hasLeadingZero) {
        const integer = this.input.slice(start, this.state.pos);

        if (this.state.strict) {
          this.raise(start, ErrorMessages.StrictOctalLiteral);
        } else {
          const underscorePos = integer.indexOf("_");

          if (underscorePos > 0) {
            this.raise(underscorePos + start, ErrorMessages.ZeroDigitNumericSeparator);
          }
        }

        isOctal = hasLeadingZero && !/[89]/.test(integer);
      }

      let next = this.input.charCodeAt(this.state.pos);

      if (next === 46 && !isOctal) {
        ++this.state.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if ((next === 69 || next === 101) && !isOctal) {
        next = this.input.charCodeAt(++this.state.pos);

        if (next === 43 || next === 45) {
          ++this.state.pos;
        }

        if (this.readInt(10) === null) this.raise(start, ErrorMessages.InvalidNumber);
        isFloat = true;
        hasExponent = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if (next === 110) {
        if (isFloat || hasLeadingZero) {
          this.raise(start, ErrorMessages.InvalidBigIntLiteral);
        }

        ++this.state.pos;
        isBigInt = true;
      }

      if (next === 109) {
        this.expectPlugin("decimal", this.state.pos);

        if (hasExponent || hasLeadingZero) {
          this.raise(start, ErrorMessages.InvalidDecimal);
        }

        ++this.state.pos;
        isDecimal = true;
      }

      if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
        throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
      }

      const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");

      if (isBigInt) {
        this.finishToken(types.bigint, str);
        return;
      }

      if (isDecimal) {
        this.finishToken(types.decimal, str);
        return;
      }

      const val = isOctal ? parseInt(str, 8) : parseFloat(str);
      this.finishToken(types.num, val);
    }

    readCodePoint(throwOnInvalid) {
      const ch = this.input.charCodeAt(this.state.pos);
      let code;

      if (ch === 123) {
        const codePos = ++this.state.pos;
        code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
        ++this.state.pos;

        if (code !== null && code > 0x10ffff) {
          if (throwOnInvalid) {
            this.raise(codePos, ErrorMessages.InvalidCodePoint);
          } else {
            return null;
          }
        }
      } else {
        code = this.readHexChar(4, false, throwOnInvalid);
      }

      return code;
    }

    readString(quote) {
      let out = "",
          chunkStart = ++this.state.pos;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        }

        const ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote) break;

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.state.pos;
        } else if (ch === 8232 || ch === 8233) {
          ++this.state.pos;
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
        } else if (isNewLine(ch)) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        } else {
          ++this.state.pos;
        }
      }

      out += this.input.slice(chunkStart, this.state.pos++);
      this.finishToken(types.string, out);
    }

    readTmplToken() {
      let out = "",
          chunkStart = this.state.pos,
          containsInvalid = false;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedTemplate);
        }

        const ch = this.input.charCodeAt(this.state.pos);

        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
          if (this.state.pos === this.state.start && this.match(types.template)) {
            if (ch === 36) {
              this.state.pos += 2;
              this.finishToken(types.dollarBraceL);
              return;
            } else {
              ++this.state.pos;
              this.finishToken(types.backQuote);
              return;
            }
          }

          out += this.input.slice(chunkStart, this.state.pos);
          this.finishToken(types.template, containsInvalid ? null : out);
          return;
        }

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          const escaped = this.readEscapedChar(true);

          if (escaped === null) {
            containsInvalid = true;
          } else {
            out += escaped;
          }

          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          ++this.state.pos;

          switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.state.pos) === 10) {
                ++this.state.pos;
              }

            case 10:
              out += "\n";
              break;

            default:
              out += String.fromCharCode(ch);
              break;
          }

          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
    }

    readEscapedChar(inTemplate) {
      const throwOnInvalid = !inTemplate;
      const ch = this.input.charCodeAt(++this.state.pos);
      ++this.state.pos;

      switch (ch) {
        case 110:
          return "\n";

        case 114:
          return "\r";

        case 120:
          {
            const code = this.readHexChar(2, false, throwOnInvalid);
            return code === null ? null : String.fromCharCode(code);
          }

        case 117:
          {
            const code = this.readCodePoint(throwOnInvalid);
            return code === null ? null : String.fromCodePoint(code);
          }

        case 116:
          return "\t";

        case 98:
          return "\b";

        case 118:
          return "\u000b";

        case 102:
          return "\f";

        case 13:
          if (this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
          }

        case 10:
          this.state.lineStart = this.state.pos;
          ++this.state.curLine;

        case 8232:
        case 8233:
          return "";

        case 56:
        case 57:
          if (inTemplate) {
            return null;
          } else if (this.state.strict) {
            this.raise(this.state.pos - 1, ErrorMessages.StrictNumericEscape);
          }

        default:
          if (ch >= 48 && ch <= 55) {
            const codePos = this.state.pos - 1;
            const match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);

            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }

            this.state.pos += octalStr.length - 1;
            const next = this.input.charCodeAt(this.state.pos);

            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return null;
              } else if (this.state.strict) {
                this.raise(codePos, ErrorMessages.StrictNumericEscape);
              } else {
                this.state.octalPositions.push(codePos);
              }
            }

            return String.fromCharCode(octal);
          }

          return String.fromCharCode(ch);
      }
    }

    readHexChar(len, forceLen, throwOnInvalid) {
      const codePos = this.state.pos;
      const n = this.readInt(16, len, forceLen, false);

      if (n === null) {
        if (throwOnInvalid) {
          this.raise(codePos, ErrorMessages.InvalidEscapeSequence);
        } else {
          this.state.pos = codePos - 1;
        }
      }

      return n;
    }

    readWord1() {
      let word = "";
      this.state.containsEsc = false;
      const start = this.state.pos;
      let chunkStart = this.state.pos;

      while (this.state.pos < this.length) {
        const ch = this.input.codePointAt(this.state.pos);

        if (isIdentifierChar(ch)) {
          this.state.pos += ch <= 0xffff ? 1 : 2;
        } else if (this.state.isIterator && ch === 64) {
          ++this.state.pos;
        } else if (ch === 92) {
          this.state.containsEsc = true;
          word += this.input.slice(chunkStart, this.state.pos);
          const escStart = this.state.pos;
          const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;

          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);
            continue;
          }

          ++this.state.pos;
          const esc = this.readCodePoint(true);

          if (esc !== null) {
            if (!identifierCheck(esc)) {
              this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier);
            }

            word += String.fromCodePoint(esc);
          }

          chunkStart = this.state.pos;
        } else {
          break;
        }
      }

      return word + this.input.slice(chunkStart, this.state.pos);
    }

    isIterator(word) {
      return word === "@@iterator" || word === "@@asyncIterator";
    }

    readWord() {
      const word = this.readWord1();
      const type = keywords.get(word) || types.name;

      if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {
        this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, word);
      }

      this.finishToken(type, word);
    }

    checkKeywordEscapes() {
      const kw = this.state.type.keyword;

      if (kw && this.state.containsEsc) {
        this.raise(this.state.start, ErrorMessages.InvalidEscapedReservedWord, kw);
      }
    }

    braceIsBlock(prevType) {
      const parent = this.curContext();

      if (parent === types$1.functionExpression || parent === types$1.functionStatement) {
        return true;
      }

      if (prevType === types.colon && (parent === types$1.braceStatement || parent === types$1.braceExpression)) {
        return !parent.isExpr;
      }

      if (prevType === types._return || prevType === types.name && this.state.exprAllowed) {
        return this.hasPrecedingLineBreak();
      }

      if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {
        return true;
      }

      if (prevType === types.braceL) {
        return parent === types$1.braceStatement;
      }

      if (prevType === types._var || prevType === types._const || prevType === types.name) {
        return false;
      }

      if (prevType === types.relational) {
        return true;
      }

      return !this.state.exprAllowed;
    }

    updateContext(prevType) {
      const type = this.state.type;
      let update;

      if (type.keyword && (prevType === types.dot || prevType === types.questionDot)) {
        this.state.exprAllowed = false;
      } else if (update = type.updateContext) {
        update.call(this, prevType);
      } else {
        this.state.exprAllowed = type.beforeExpr;
      }
    }

  }

  class UtilParser extends Tokenizer {
    addExtra(node, key, val) {
      if (!node) return;
      const extra = node.extra = node.extra || {};
      extra[key] = val;
    }

    isRelational(op) {
      return this.match(types.relational) && this.state.value === op;
    }

    expectRelational(op) {
      if (this.isRelational(op)) {
        this.next();
      } else {
        this.unexpected(null, types.relational);
      }
    }

    isContextual(name) {
      return this.match(types.name) && this.state.value === name && !this.state.containsEsc;
    }

    isUnparsedContextual(nameStart, name) {
      const nameEnd = nameStart + name.length;
      return this.input.slice(nameStart, nameEnd) === name && (nameEnd === this.input.length || !isIdentifierChar(this.input.charCodeAt(nameEnd)));
    }

    isLookaheadContextual(name) {
      const next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    }

    eatContextual(name) {
      return this.isContextual(name) && this.eat(types.name);
    }

    expectContextual(name, message) {
      if (!this.eatContextual(name)) this.unexpected(null, message);
    }

    canInsertSemicolon() {
      return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();
    }

    hasPrecedingLineBreak() {
      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    }

    isLineTerminator() {
      return this.eat(types.semi) || this.canInsertSemicolon();
    }

    semicolon() {
      if (!this.isLineTerminator()) this.unexpected(null, types.semi);
    }

    expect(type, pos) {
      this.eat(type) || this.unexpected(pos, type);
    }

    assertNoSpace(message = "Unexpected space.") {
      if (this.state.start > this.state.lastTokEnd) {
        this.raise(this.state.lastTokEnd, message);
      }
    }

    unexpected(pos, messageOrType = "Unexpected token") {
      if (typeof messageOrType !== "string") {
        messageOrType = `Unexpected token, expected "${messageOrType.label}"`;
      }

      throw this.raise(pos != null ? pos : this.state.start, messageOrType);
    }

    expectPlugin(name, pos) {
      if (!this.hasPlugin(name)) {
        throw this.raiseWithData(pos != null ? pos : this.state.start, {
          missingPlugin: [name]
        }, `This experimental syntax requires enabling the parser plugin: '${name}'`);
      }

      return true;
    }

    expectOnePlugin(names, pos) {
      if (!names.some(n => this.hasPlugin(n))) {
        throw this.raiseWithData(pos != null ? pos : this.state.start, {
          missingPlugin: names
        }, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(", ")}'`);
      }
    }

    checkYieldAwaitInDefaultParams() {
      if (this.state.yieldPos !== -1 && (this.state.awaitPos === -1 || this.state.yieldPos < this.state.awaitPos)) {
        this.raise(this.state.yieldPos, ErrorMessages.YieldBindingIdentifier);
      }

      if (this.state.awaitPos !== -1) {
        this.raise(this.state.awaitPos, ErrorMessages.AwaitBindingIdentifier);
      }
    }

    tryParse(fn, oldState = this.state.clone()) {
      const abortSignal = {
        node: null
      };

      try {
        const node = fn((node = null) => {
          abortSignal.node = node;
          throw abortSignal;
        });

        if (this.state.errors.length > oldState.errors.length) {
          const failState = this.state;
          this.state = oldState;
          return {
            node,
            error: failState.errors[oldState.errors.length],
            thrown: false,
            aborted: false,
            failState
          };
        }

        return {
          node,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (error) {
        const failState = this.state;
        this.state = oldState;

        if (error instanceof SyntaxError) {
          return {
            node: null,
            error,
            thrown: true,
            aborted: false,
            failState
          };
        }

        if (error === abortSignal) {
          return {
            node: abortSignal.node,
            error: null,
            thrown: false,
            aborted: true,
            failState
          };
        }

        throw error;
      }
    }

    checkExpressionErrors(refExpressionErrors, andThrow) {
      if (!refExpressionErrors) return false;
      const {
        shorthandAssign,
        doubleProto
      } = refExpressionErrors;
      if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;

      if (shorthandAssign >= 0) {
        this.unexpected(shorthandAssign);
      }

      if (doubleProto >= 0) {
        this.raise(doubleProto, ErrorMessages.DuplicateProto);
      }
    }

    isLiteralPropertyName() {
      return this.match(types.name) || !!this.state.type.keyword || this.match(types.string) || this.match(types.num) || this.match(types.bigint) || this.match(types.decimal);
    }

  }
  class ExpressionErrors {
    constructor() {
      this.shorthandAssign = -1;
      this.doubleProto = -1;
    }

  }

  class Node {
    constructor(parser, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      this.loc = new SourceLocation(loc);
      if (parser == null ? void 0 : parser.options.ranges) this.range = [pos, 0];
      if (parser == null ? void 0 : parser.filename) this.loc.filename = parser.filename;
    }

    __clone() {
      const newNode = new Node();
      const keys = Object.keys(this);

      for (let i = 0, length = keys.length; i < length; i++) {
        const key = keys[i];

        if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
          newNode[key] = this[key];
        }
      }

      return newNode;
    }

  }

  class NodeUtils extends UtilParser {
    startNode() {
      return new Node(this, this.state.start, this.state.startLoc);
    }

    startNodeAt(pos, loc) {
      return new Node(this, pos, loc);
    }

    startNodeAtNode(type) {
      return this.startNodeAt(type.start, type.loc.start);
    }

    finishNode(node, type) {
      return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
    }

    finishNodeAt(node, type, pos, loc) {

      node.type = type;
      node.end = pos;
      node.loc.end = loc;
      if (this.options.ranges) node.range[1] = pos;
      this.processComment(node);
      return node;
    }

    resetStartLocation(node, start, startLoc) {
      node.start = start;
      node.loc.start = startLoc;
      if (this.options.ranges) node.range[0] = start;
    }

    resetEndLocation(node, end = this.state.lastTokEnd, endLoc = this.state.lastTokEndLoc) {
      node.end = end;
      node.loc.end = endLoc;
      if (this.options.ranges) node.range[1] = end;
    }

    resetStartLocationFromNode(node, locationNode) {
      this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
    }

  }

  const unwrapParenthesizedExpression = node => {
    return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
  };

  class LValParser extends NodeUtils {
    toAssignable(node) {
      var _node$extra, _node$extra3;

      let parenthesized = undefined;

      if (node.type === "ParenthesizedExpression" || ((_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized)) {
        parenthesized = unwrapParenthesizedExpression(node);

        if (parenthesized.type !== "Identifier" && parenthesized.type !== "MemberExpression") {
          this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
        }
      }

      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
          break;

        case "ObjectExpression":
          node.type = "ObjectPattern";

          for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
            var _node$extra2;

            const prop = node.properties[i];
            const isLast = i === last;
            this.toAssignableObjectExpressionProp(prop, isLast);

            if (isLast && prop.type === "RestElement" && ((_node$extra2 = node.extra) == null ? void 0 : _node$extra2.trailingComma)) {
              this.raiseRestNotLast(node.extra.trailingComma);
            }
          }

          break;

        case "ObjectProperty":
          this.toAssignable(node.value);
          break;

        case "SpreadElement":
          {
            this.checkToRestConversion(node);
            node.type = "RestElement";
            const arg = node.argument;
            this.toAssignable(arg);
            break;
          }

        case "ArrayExpression":
          node.type = "ArrayPattern";
          this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma);
          break;

        case "AssignmentExpression":
          if (node.operator !== "=") {
            this.raise(node.left.end, ErrorMessages.MissingEqInAssignment);
          }

          node.type = "AssignmentPattern";
          delete node.operator;
          this.toAssignable(node.left);
          break;

        case "ParenthesizedExpression":
          this.toAssignable(parenthesized);
          break;
      }

      return node;
    }

    toAssignableObjectExpressionProp(prop, isLast) {
      if (prop.type === "ObjectMethod") {
        const error = prop.kind === "get" || prop.kind === "set" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod;
        this.raise(prop.key.start, error);
      } else if (prop.type === "SpreadElement" && !isLast) {
        this.raiseRestNotLast(prop.start);
      } else {
        this.toAssignable(prop);
      }
    }

    toAssignableList(exprList, trailingCommaPos) {
      let end = exprList.length;

      if (end) {
        const last = exprList[end - 1];

        if ((last == null ? void 0 : last.type) === "RestElement") {
          --end;
        } else if ((last == null ? void 0 : last.type) === "SpreadElement") {
          last.type = "RestElement";
          const arg = last.argument;
          this.toAssignable(arg);

          if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
            this.unexpected(arg.start);
          }

          if (trailingCommaPos) {
            this.raiseTrailingCommaAfterRest(trailingCommaPos);
          }

          --end;
        }
      }

      for (let i = 0; i < end; i++) {
        const elt = exprList[i];

        if (elt) {
          this.toAssignable(elt);

          if (elt.type === "RestElement") {
            this.raiseRestNotLast(elt.start);
          }
        }
      }

      return exprList;
    }

    toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    }

    toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);

      for (let _i = 0; _i < exprList.length; _i++) {
        const expr = exprList[_i];

        if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
          this.toReferencedListDeep(expr.elements);
        }
      }
    }

    parseSpread(refExpressionErrors, refNeedsArrowPos) {
      const node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined, refNeedsArrowPos);
      return this.finishNode(node, "SpreadElement");
    }

    parseRestBinding() {
      const node = this.startNode();
      this.next();
      node.argument = this.parseBindingAtom();
      return this.finishNode(node, "RestElement");
    }

    parseBindingAtom() {
      switch (this.state.type) {
        case types.bracketL:
          {
            const node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types.bracketR, 93, true);
            return this.finishNode(node, "ArrayPattern");
          }

        case types.braceL:
          return this.parseObjectLike(types.braceR, true);
      }

      return this.parseIdentifier();
    }

    parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
      const elts = [];
      let first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
        }

        if (allowEmpty && this.match(types.comma)) {
          elts.push(null);
        } else if (this.eat(close)) {
          break;
        } else if (this.match(types.ellipsis)) {
          elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
          this.checkCommaAfterRest(closeCharCode);
          this.expect(close);
          break;
        } else {
          const decorators = [];

          if (this.match(types.at) && this.hasPlugin("decorators")) {
            this.raise(this.state.start, ErrorMessages.UnsupportedParameterDecorator);
          }

          while (this.match(types.at)) {
            decorators.push(this.parseDecorator());
          }

          elts.push(this.parseAssignableListItem(allowModifiers, decorators));
        }
      }

      return elts;
    }

    parseAssignableListItem(allowModifiers, decorators) {
      const left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left);
      const elt = this.parseMaybeDefault(left.start, left.loc.start, left);

      if (decorators.length) {
        left.decorators = decorators;
      }

      return elt;
    }

    parseAssignableListItemTypes(param) {
      return param;
    }

    parseMaybeDefault(startPos, startLoc, left) {
      var _startLoc, _startPos, _left;

      startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
      startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
      left = (_left = left) != null ? _left : this.parseBindingAtom();
      if (!this.eat(types.eq)) return left;
      const node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssignAllowIn();
      return this.finishNode(node, "AssignmentPattern");
    }

    checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription, disallowLetBinding, strictModeChanged = false) {
      switch (expr.type) {
        case "Identifier":
          if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(expr.name, this.inModule) : isStrictBindOnlyReservedWord(expr.name))) {
            this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, expr.name);
          }

          if (checkClashes) {
            const key = `_${expr.name}`;

            if (checkClashes[key]) {
              this.raise(expr.start, ErrorMessages.ParamDupe);
            } else {
              checkClashes[key] = true;
            }
          }

          if (disallowLetBinding && expr.name === "let") {
            this.raise(expr.start, ErrorMessages.LetInLexicalBinding);
          }

          if (!(bindingType & BIND_NONE)) {
            this.scope.declareName(expr.name, bindingType, expr.start);
          }

          break;

        case "MemberExpression":
          if (bindingType !== BIND_NONE) {
            this.raise(expr.start, ErrorMessages.InvalidPropertyBindingPattern);
          }

          break;

        case "ObjectPattern":
          for (let _i2 = 0, _expr$properties = expr.properties; _i2 < _expr$properties.length; _i2++) {
            let prop = _expr$properties[_i2];
            if (prop.type === "ObjectProperty") prop = prop.value;else if (prop.type === "ObjectMethod") continue;
            this.checkLVal(prop, bindingType, checkClashes, "object destructuring pattern", disallowLetBinding);
          }

          break;

        case "ArrayPattern":
          for (let _i3 = 0, _expr$elements = expr.elements; _i3 < _expr$elements.length; _i3++) {
            const elem = _expr$elements[_i3];

            if (elem) {
              this.checkLVal(elem, bindingType, checkClashes, "array destructuring pattern", disallowLetBinding);
            }
          }

          break;

        case "AssignmentPattern":
          this.checkLVal(expr.left, bindingType, checkClashes, "assignment pattern");
          break;

        case "RestElement":
          this.checkLVal(expr.argument, bindingType, checkClashes, "rest element");
          break;

        case "ParenthesizedExpression":
          this.checkLVal(expr.expression, bindingType, checkClashes, "parenthesized expression");
          break;

        default:
          {
            this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, contextDescription);
          }
      }
    }

    checkToRestConversion(node) {
      if (node.argument.type !== "Identifier" && node.argument.type !== "MemberExpression") {
        this.raise(node.argument.start, ErrorMessages.InvalidRestAssignmentPattern);
      }
    }

    checkCommaAfterRest(close) {
      if (this.match(types.comma)) {
        if (this.lookaheadCharCode() === close) {
          this.raiseTrailingCommaAfterRest(this.state.start);
        } else {
          this.raiseRestNotLast(this.state.start);
        }
      }
    }

    raiseRestNotLast(pos) {
      throw this.raise(pos, ErrorMessages.ElementAfterRest);
    }

    raiseTrailingCommaAfterRest(pos) {
      this.raise(pos, ErrorMessages.RestTrailingComma);
    }

  }

  class ExpressionParser extends LValParser {
    checkProto(prop, isRecord, protoRef, refExpressionErrors) {
      if (prop.type === "SpreadElement" || prop.type === "ObjectMethod" || prop.computed || prop.shorthand) {
        return;
      }

      const key = prop.key;
      const name = key.type === "Identifier" ? key.name : key.value;

      if (name === "__proto__") {
        if (isRecord) {
          this.raise(key.start, ErrorMessages.RecordNoProto);
          return;
        }

        if (protoRef.used) {
          if (refExpressionErrors) {
            if (refExpressionErrors.doubleProto === -1) {
              refExpressionErrors.doubleProto = key.start;
            }
          } else {
            this.raise(key.start, ErrorMessages.DuplicateProto);
          }
        }

        protoRef.used = true;
      }
    }

    shouldExitDescending(expr, potentialArrowAt) {
      return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
    }

    getExpression() {
      let paramFlags = PARAM;

      if (this.hasPlugin("topLevelAwait") && this.inModule) {
        paramFlags |= PARAM_AWAIT;
      }

      this.scope.enter(SCOPE_PROGRAM);
      this.prodParam.enter(paramFlags);
      this.nextToken();
      const expr = this.parseExpression();

      if (!this.match(types.eof)) {
        this.unexpected();
      }

      expr.comments = this.state.comments;
      expr.errors = this.state.errors;
      return expr;
    }

    parseExpression(disallowIn, refExpressionErrors) {
      if (disallowIn) {
        return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }

      return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
    }

    parseExpressionBase(refExpressionErrors) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const expr = this.parseMaybeAssign(refExpressionErrors);

      if (this.match(types.comma)) {
        const node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];

        while (this.eat(types.comma)) {
          node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
        }

        this.toReferencedList(node.expressions);
        return this.finishNode(node, "SequenceExpression");
      }

      return expr;
    }

    parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
      return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos));
    }

    parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
      return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos));
    }

    parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;

      if (this.isContextual("yield")) {
        if (this.prodParam.hasYield) {
          let left = this.parseYield();

          if (afterLeftParse) {
            left = afterLeftParse.call(this, left, startPos, startLoc);
          }

          return left;
        } else {
          this.state.exprAllowed = false;
        }
      }

      let ownExpressionErrors;

      if (refExpressionErrors) {
        ownExpressionErrors = false;
      } else {
        refExpressionErrors = new ExpressionErrors();
        ownExpressionErrors = true;
      }

      if (this.match(types.parenL) || this.match(types.name)) {
        this.state.potentialArrowAt = this.state.start;
      }

      let left = this.parseMaybeConditional(refExpressionErrors, refNeedsArrowPos);

      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }

      if (this.state.type.isAssign) {
        const node = this.startNodeAt(startPos, startLoc);
        const operator = this.state.value;
        node.operator = operator;

        if (this.match(types.eq)) {
          node.left = this.toAssignable(left);
          refExpressionErrors.doubleProto = -1;
        } else {
          node.left = left;
        }

        if (refExpressionErrors.shorthandAssign >= node.left.start) {
          refExpressionErrors.shorthandAssign = -1;
        }

        this.checkLVal(left, undefined, undefined, "assignment expression");
        this.next();
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentExpression");
      } else if (ownExpressionErrors) {
        this.checkExpressionErrors(refExpressionErrors, true);
      }

      return left;
    }

    parseMaybeConditional(refExpressionErrors, refNeedsArrowPos) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseExprOps(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseConditional(expr, startPos, startLoc, refNeedsArrowPos);
    }

    parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {
      if (this.eat(types.question)) {
        const node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssignAllowIn();
        this.expect(types.colon);
        node.alternate = this.parseMaybeAssign();
        return this.finishNode(node, "ConditionalExpression");
      }

      return expr;
    }

    parseExprOps(refExpressionErrors) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseMaybeUnary(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseExprOp(expr, startPos, startLoc, -1);
    }

    parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
      let prec = this.state.type.binop;

      if (prec != null && (this.prodParam.hasIn || !this.match(types._in))) {
        if (prec > minPrec) {
          const op = this.state.type;

          if (op === types.pipeline) {
            this.expectPlugin("pipelineOperator");

            if (this.state.inFSharpPipelineDirectBody) {
              return left;
            }

            this.state.inPipeline = true;
            this.checkPipelineAtInfixOperator(left, leftStartPos);
          }

          const node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.left = left;
          node.operator = this.state.value;

          if (op === types.exponent && left.type === "UnaryExpression" && (this.options.createParenthesizedExpressions || !(left.extra && left.extra.parenthesized))) {
            this.raise(left.argument.start, ErrorMessages.UnexpectedTokenUnaryExponentiation);
          }

          const logical = op === types.logicalOR || op === types.logicalAND;
          const coalesce = op === types.nullishCoalescing;

          if (coalesce) {
            prec = types.logicalAND.binop;
          }

          this.next();

          if (op === types.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal") {
            if (this.match(types.name) && this.state.value === "await" && this.prodParam.hasAwait) {
              throw this.raise(this.state.start, ErrorMessages.UnexpectedAwaitAfterPipelineBody);
            }
          }

          node.right = this.parseExprOpRightExpr(op, prec);
          this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
          const nextOp = this.state.type;

          if (coalesce && (nextOp === types.logicalOR || nextOp === types.logicalAND) || logical && nextOp === types.nullishCoalescing) {
            throw this.raise(this.state.start, ErrorMessages.MixingCoalesceWithLogical);
          }

          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
        }
      }

      return left;
    }

    parseExprOpRightExpr(op, prec) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;

      switch (op) {
        case types.pipeline:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "smart":
              return this.withTopicPermittingContext(() => {
                return this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);
              });

            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => {
                return this.parseFSharpPipelineBody(prec);
              });
          }

        default:
          return this.parseExprOpBaseRightExpr(op, prec);
      }
    }

    parseExprOpBaseRightExpr(op, prec) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec);
    }

    parseMaybeUnary(refExpressionErrors) {
      if (this.isContextual("await") && this.isAwaitAllowed()) {
        return this.parseAwait();
      }

      const update = this.match(types.incDec);
      const node = this.startNode();

      if (this.state.type.prefix) {
        node.operator = this.state.value;
        node.prefix = true;

        if (this.match(types._throw)) {
          this.expectPlugin("throwExpressions");
        }

        const isDelete = this.match(types._delete);
        this.next();
        node.argument = this.parseMaybeUnary();
        this.checkExpressionErrors(refExpressionErrors, true);

        if (this.state.strict && isDelete) {
          const arg = node.argument;

          if (arg.type === "Identifier") {
            this.raise(node.start, ErrorMessages.StrictDelete);
          } else if ((arg.type === "MemberExpression" || arg.type === "OptionalMemberExpression") && arg.property.type === "PrivateName") {
            this.raise(node.start, ErrorMessages.DeletePrivateField);
          }
        }

        if (!update) {
          return this.finishNode(node, "UnaryExpression");
        }
      }

      return this.parseUpdate(node, update, refExpressionErrors);
    }

    parseUpdate(node, update, refExpressionErrors) {
      if (update) {
        this.checkLVal(node.argument, undefined, undefined, "prefix operation");
        return this.finishNode(node, "UpdateExpression");
      }

      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let expr = this.parseExprSubscripts(refExpressionErrors);
      if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;

      while (this.state.type.postfix && !this.canInsertSemicolon()) {
        const node = this.startNodeAt(startPos, startLoc);
        node.operator = this.state.value;
        node.prefix = false;
        node.argument = expr;
        this.checkLVal(expr, undefined, undefined, "postfix operation");
        this.next();
        expr = this.finishNode(node, "UpdateExpression");
      }

      return expr;
    }

    parseExprSubscripts(refExpressionErrors) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseExprAtom(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseSubscripts(expr, startPos, startLoc);
    }

    parseSubscripts(base, startPos, startLoc, noCalls) {
      const state = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsyncArrow(base),
        stop: false
      };

      do {
        const oldMaybeInAsyncArrowHead = this.state.maybeInAsyncArrowHead;

        if (state.maybeAsyncArrow) {
          this.state.maybeInAsyncArrowHead = true;
        }

        base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
        state.maybeAsyncArrow = false;
        this.state.maybeInAsyncArrowHead = oldMaybeInAsyncArrowHead;
      } while (!state.stop);

      return base;
    }

    parseSubscript(base, startPos, startLoc, noCalls, state) {
      if (!noCalls && this.eat(types.doubleColon)) {
        return this.parseBind(base, startPos, startLoc, noCalls, state);
      } else if (this.match(types.backQuote)) {
        return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
      }

      let optional = false;

      if (this.match(types.questionDot)) {
        state.optionalChainMember = optional = true;

        if (noCalls && this.lookaheadCharCode() === 40) {
          state.stop = true;
          return base;
        }

        this.next();
      }

      if (!noCalls && this.match(types.parenL)) {
        return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);
      } else if (optional || this.match(types.bracketL) || this.eat(types.dot)) {
        return this.parseMember(base, startPos, startLoc, state, optional);
      } else {
        state.stop = true;
        return base;
      }
    }

    parseMember(base, startPos, startLoc, state, optional) {
      const node = this.startNodeAt(startPos, startLoc);
      const computed = this.eat(types.bracketL);
      node.object = base;
      node.computed = computed;
      const property = computed ? this.parseExpression() : this.parseMaybePrivateName(true);

      if (property.type === "PrivateName") {
        if (node.object.type === "Super") {
          this.raise(startPos, ErrorMessages.SuperPrivateField);
        }

        this.classScope.usePrivateName(property.id.name, property.start);
      }

      node.property = property;

      if (computed) {
        this.expect(types.bracketR);
      }

      if (state.optionalChainMember) {
        node.optional = optional;
        return this.finishNode(node, "OptionalMemberExpression");
      } else {
        return this.finishNode(node, "MemberExpression");
      }
    }

    parseBind(base, startPos, startLoc, noCalls, state) {
      const node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.callee = this.parseNoCallExpr();
      state.stop = true;
      return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
    }

    parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      const oldYieldPos = this.state.yieldPos;
      const oldAwaitPos = this.state.awaitPos;
      this.state.maybeInArrowParameters = true;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      this.next();
      let node = this.startNodeAt(startPos, startLoc);
      node.callee = base;

      if (state.optionalChainMember) {
        node.optional = optional;
      }

      if (optional) {
        node.arguments = this.parseCallExpressionArguments(types.parenR, false);
      } else {
        node.arguments = this.parseCallExpressionArguments(types.parenR, state.maybeAsyncArrow, base.type === "Import", base.type !== "Super", node);
      }

      this.finishCallExpression(node, state.optionalChainMember);

      if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
        state.stop = true;
        node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);
        this.checkYieldAwaitInDefaultParams();
        this.state.yieldPos = oldYieldPos;
        this.state.awaitPos = oldAwaitPos;
      } else {
        this.toReferencedListDeep(node.arguments);
        if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;

        if (!this.isAwaitAllowed() && !oldMaybeInArrowParameters || oldAwaitPos !== -1) {
          this.state.awaitPos = oldAwaitPos;
        }
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node;
    }

    parseTaggedTemplateExpression(base, startPos, startLoc, state) {
      const node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate(true);

      if (state.optionalChainMember) {
        this.raise(startPos, ErrorMessages.OptionalChainingNoTemplate);
      }

      return this.finishNode(node, "TaggedTemplateExpression");
    }

    atPossibleAsyncArrow(base) {
      return base.type === "Identifier" && base.name === "async" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
    }

    finishCallExpression(node, optional) {
      if (node.callee.type === "Import") {
        if (node.arguments.length === 2) {
          this.expectPlugin("moduleAttributes");
        }

        if (node.arguments.length === 0 || node.arguments.length > 2) {
          this.raise(node.start, ErrorMessages.ImportCallArity, this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
        } else {
          for (let _i = 0, _node$arguments = node.arguments; _i < _node$arguments.length; _i++) {
            const arg = _node$arguments[_i];

            if (arg.type === "SpreadElement") {
              this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);
            }
          }
        }
      }

      return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
    }

    parseCallExpressionArguments(close, possibleAsyncArrow, dynamicImport, allowPlaceholder, nodeForExtra) {
      const elts = [];
      let innerParenStart;
      let first = true;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(close)) {
            if (dynamicImport && !this.hasPlugin("moduleAttributes")) {
              this.raise(this.state.lastTokStart, ErrorMessages.ImportCallArgumentTrailingComma);
            }

            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }

            this.next();
            break;
          }
        }

        if (this.match(types.parenL) && !innerParenStart) {
          innerParenStart = this.state.start;
        }

        elts.push(this.parseExprListItem(false, possibleAsyncArrow ? new ExpressionErrors() : undefined, possibleAsyncArrow ? {
          start: 0
        } : undefined, allowPlaceholder));
      }

      if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {
        this.unexpected();
      }

      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return elts;
    }

    shouldParseAsyncArrow() {
      return this.match(types.arrow) && !this.canInsertSemicolon();
    }

    parseAsyncArrowFromCallExpression(node, call) {
      var _call$extra;

      this.expect(types.arrow);
      this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);
      return node;
    }

    parseNoCallExpr() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    }

    parseExprAtom(refExpressionErrors) {
      if (this.state.type === types.slash) this.readRegexp();
      const canBeArrow = this.state.potentialArrowAt === this.state.start;
      let node;

      switch (this.state.type) {
        case types._super:
          return this.parseSuper();

        case types._import:
          node = this.startNode();
          this.next();

          if (this.match(types.dot)) {
            return this.parseImportMetaProperty(node);
          }

          if (!this.match(types.parenL)) {
            this.raise(this.state.lastTokStart, ErrorMessages.UnsupportedImport);
          }

          return this.finishNode(node, "Import");

        case types._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");

        case types.name:
          {
            const containsEsc = this.state.containsEsc;
            const id = this.parseIdentifier();

            if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
              if (this.match(types._function)) {
                const last = this.state.context.length - 1;

                if (this.state.context[last] !== types$1.functionStatement) {
                  throw new Error("Internal error");
                }

                this.state.context[last] = types$1.functionExpression;
                this.next();
                return this.parseFunction(this.startNodeAtNode(id), undefined, true);
              } else if (this.match(types.name)) {
                return this.parseAsyncArrowUnaryFunction(id);
              }
            }

            if (canBeArrow && this.match(types.arrow) && !this.canInsertSemicolon()) {
              this.next();
              return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
            }

            return id;
          }

        case types._do:
          {
            return this.parseDo();
          }

        case types.regexp:
          {
            const value = this.state.value;
            node = this.parseLiteral(value.value, "RegExpLiteral");
            node.pattern = value.pattern;
            node.flags = value.flags;
            return node;
          }

        case types.num:
          return this.parseLiteral(this.state.value, "NumericLiteral");

        case types.bigint:
          return this.parseLiteral(this.state.value, "BigIntLiteral");

        case types.decimal:
          return this.parseLiteral(this.state.value, "DecimalLiteral");

        case types.string:
          return this.parseLiteral(this.state.value, "StringLiteral");

        case types._null:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "NullLiteral");

        case types._true:
        case types._false:
          return this.parseBooleanLiteral();

        case types.parenL:
          return this.parseParenAndDistinguishExpression(canBeArrow);

        case types.bracketBarL:
        case types.bracketHashL:
          {
            return this.parseArrayLike(this.state.type === types.bracketBarL ? types.bracketBarR : types.bracketR, false, true, refExpressionErrors);
          }

        case types.bracketL:
          {
            return this.parseArrayLike(types.bracketR, true, false, refExpressionErrors);
          }

        case types.braceBarL:
        case types.braceHashL:
          {
            return this.parseObjectLike(this.state.type === types.braceBarL ? types.braceBarR : types.braceR, false, true, refExpressionErrors);
          }

        case types.braceL:
          {
            return this.parseObjectLike(types.braceR, false, false, refExpressionErrors);
          }

        case types._function:
          return this.parseFunctionOrFunctionSent();

        case types.at:
          this.parseDecorators();

        case types._class:
          node = this.startNode();
          this.takeDecorators(node);
          return this.parseClass(node, false);

        case types._new:
          return this.parseNewOrNewTarget();

        case types.backQuote:
          return this.parseTemplate(false);

        case types.doubleColon:
          {
            node = this.startNode();
            this.next();
            node.object = null;
            const callee = node.callee = this.parseNoCallExpr();

            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(callee.start, ErrorMessages.UnsupportedBind);
            }
          }

        case types.hash:
          {
            if (this.state.inPipeline) {
              node = this.startNode();

              if (this.getPluginOption("pipelineOperator", "proposal") !== "smart") {
                this.raise(node.start, ErrorMessages.PrimaryTopicRequiresSmartPipeline);
              }

              this.next();

              if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {
                this.raise(node.start, ErrorMessages.PrimaryTopicNotAllowed);
              }

              this.registerTopicReference();
              return this.finishNode(node, "PipelinePrimaryTopicReference");
            }

            const nextCh = this.input.codePointAt(this.state.end);

            if (isIdentifierStart(nextCh) || nextCh === 92) {
              const start = this.state.start;
              node = this.parseMaybePrivateName(true);

              if (this.match(types._in)) {
                this.expectPlugin("privateIn");
                this.classScope.usePrivateName(node.id.name, node.start);
              } else if (this.hasPlugin("privateIn")) {
                this.raise(this.state.start, ErrorMessages.PrivateInExpectedIn, node.id.name);
              } else {
                throw this.unexpected(start);
              }

              return node;
            }
          }

        case types.relational:
          {
            if (this.state.value === "<") {
              const lookaheadCh = this.input.codePointAt(this.nextTokenStart());

              if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
                  this.expectOnePlugin(["jsx", "flow", "typescript"]);
                }
            }
          }

        default:
          throw this.unexpected();
      }
    }

    parseAsyncArrowUnaryFunction(id) {
      const node = this.startNodeAtNode(id);
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      const oldMaybeInAsyncArrowHead = this.state.maybeInAsyncArrowHead;
      const oldYieldPos = this.state.yieldPos;
      const oldAwaitPos = this.state.awaitPos;
      this.state.maybeInArrowParameters = true;
      this.state.maybeInAsyncArrowHead = true;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      const params = [this.parseIdentifier()];

      if (this.hasPrecedingLineBreak()) {
        this.raise(this.state.pos, ErrorMessages.LineTerminatorBeforeArrow);
      }

      this.expect(types.arrow);
      this.checkYieldAwaitInDefaultParams();
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.maybeInAsyncArrowHead = oldMaybeInAsyncArrowHead;
      this.state.yieldPos = oldYieldPos;
      this.state.awaitPos = oldAwaitPos;
      this.parseArrowExpression(node, params, true);
      return node;
    }

    parseDo() {
      this.expectPlugin("doExpressions");
      const node = this.startNode();
      this.next();
      const oldLabels = this.state.labels;
      this.state.labels = [];
      node.body = this.parseBlock();
      this.state.labels = oldLabels;
      return this.finishNode(node, "DoExpression");
    }

    parseSuper() {
      const node = this.startNode();
      this.next();

      if (this.match(types.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, ErrorMessages.SuperNotAllowed);
      } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, ErrorMessages.UnexpectedSuper);
      }

      if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {
        this.raise(node.start, ErrorMessages.UnsupportedSuper);
      }

      return this.finishNode(node, "Super");
    }

    parseBooleanLiteral() {
      const node = this.startNode();
      node.value = this.match(types._true);
      this.next();
      return this.finishNode(node, "BooleanLiteral");
    }

    parseMaybePrivateName(isPrivateNameAllowed) {
      const isPrivate = this.match(types.hash);

      if (isPrivate) {
        this.expectOnePlugin(["classPrivateProperties", "classPrivateMethods"]);

        if (!isPrivateNameAllowed) {
          this.raise(this.state.pos, ErrorMessages.UnexpectedPrivateField);
        }

        const node = this.startNode();
        this.next();
        this.assertNoSpace("Unexpected space between # and identifier");
        node.id = this.parseIdentifier(true);
        return this.finishNode(node, "PrivateName");
      } else {
        return this.parseIdentifier(true);
      }
    }

    parseFunctionOrFunctionSent() {
      const node = this.startNode();
      this.next();

      if (this.prodParam.hasYield && this.match(types.dot)) {
        const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
        this.next();
        return this.parseMetaProperty(node, meta, "sent");
      }

      return this.parseFunction(node);
    }

    parseMetaProperty(node, meta, propertyName) {
      node.meta = meta;

      if (meta.name === "function" && propertyName === "sent") {
        if (this.isContextual(propertyName)) {
          this.expectPlugin("functionSent");
        } else if (!this.hasPlugin("functionSent")) {
          this.unexpected();
        }
      }

      const containsEsc = this.state.containsEsc;
      node.property = this.parseIdentifier(true);

      if (node.property.name !== propertyName || containsEsc) {
        this.raise(node.property.start, ErrorMessages.UnsupportedMetaProperty, meta.name, propertyName);
      }

      return this.finishNode(node, "MetaProperty");
    }

    parseImportMetaProperty(node) {
      const id = this.createIdentifier(this.startNodeAtNode(node), "import");
      this.next();

      if (this.isContextual("meta")) {
        if (!this.inModule) {
          this.raiseWithData(id.start, {
            code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
          }, ErrorMessages.ImportMetaOutsideModule);
        }

        this.sawUnambiguousESM = true;
      }

      return this.parseMetaProperty(node, id, "meta");
    }

    parseLiteral(value, type, startPos, startLoc) {
      startPos = startPos || this.state.start;
      startLoc = startLoc || this.state.startLoc;
      const node = this.startNodeAt(startPos, startLoc);
      this.addExtra(node, "rawValue", value);
      this.addExtra(node, "raw", this.input.slice(startPos, this.state.end));
      node.value = value;
      this.next();
      return this.finishNode(node, type);
    }

    parseParenAndDistinguishExpression(canBeArrow) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let val;
      this.next();
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      const oldYieldPos = this.state.yieldPos;
      const oldAwaitPos = this.state.awaitPos;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      this.state.inFSharpPipelineDirectBody = false;
      const innerStartPos = this.state.start;
      const innerStartLoc = this.state.startLoc;
      const exprList = [];
      const refExpressionErrors = new ExpressionErrors();
      const refNeedsArrowPos = {
        start: 0
      };
      let first = true;
      let spreadStart;
      let optionalCommaStart;

      while (!this.match(types.parenR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma, refNeedsArrowPos.start || null);

          if (this.match(types.parenR)) {
            optionalCommaStart = this.state.start;
            break;
          }
        }

        if (this.match(types.ellipsis)) {
          const spreadNodeStartPos = this.state.start;
          const spreadNodeStartLoc = this.state.startLoc;
          spreadStart = this.state.start;
          exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
          this.checkCommaAfterRest(41);
          break;
        } else {
          exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem, refNeedsArrowPos));
        }
      }

      const innerEndPos = this.state.lastTokEnd;
      const innerEndLoc = this.state.lastTokEndLoc;
      this.expect(types.parenR);
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let arrowNode = this.startNodeAt(startPos, startLoc);

      if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
        if (!this.isAwaitAllowed() && !this.state.maybeInAsyncArrowHead) {
          this.state.awaitPos = oldAwaitPos;
        }

        this.checkYieldAwaitInDefaultParams();
        this.state.yieldPos = oldYieldPos;
        this.state.awaitPos = oldAwaitPos;

        for (let _i2 = 0; _i2 < exprList.length; _i2++) {
          const param = exprList[_i2];

          if (param.extra && param.extra.parenthesized) {
            this.unexpected(param.extra.parenStart);
          }
        }

        this.parseArrowExpression(arrowNode, exprList, false);
        return arrowNode;
      }

      if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;
      if (oldAwaitPos !== -1) this.state.awaitPos = oldAwaitPos;

      if (!exprList.length) {
        this.unexpected(this.state.lastTokStart);
      }

      if (optionalCommaStart) this.unexpected(optionalCommaStart);
      if (spreadStart) this.unexpected(spreadStart);
      this.checkExpressionErrors(refExpressionErrors, true);
      if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);
      this.toReferencedListDeep(exprList, true);

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }

      if (!this.options.createParenthesizedExpressions) {
        this.addExtra(val, "parenthesized", true);
        this.addExtra(val, "parenStart", startPos);
        return val;
      }

      const parenExpression = this.startNodeAt(startPos, startLoc);
      parenExpression.expression = val;
      this.finishNode(parenExpression, "ParenthesizedExpression");
      return parenExpression;
    }

    shouldParseArrow() {
      return !this.canInsertSemicolon();
    }

    parseArrow(node) {
      if (this.eat(types.arrow)) {
        return node;
      }
    }

    parseParenItem(node, startPos, startLoc) {
      return node;
    }

    parseNewOrNewTarget() {
      const node = this.startNode();
      this.next();

      if (this.match(types.dot)) {
        const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
        this.next();
        const metaProp = this.parseMetaProperty(node, meta, "target");

        if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
          let error = ErrorMessages.UnexpectedNewTarget;

          if (this.hasPlugin("classProperties")) {
            error += " or class properties";
          }

          this.raise(metaProp.start, error);
        }

        return metaProp;
      }

      return this.parseNew(node);
    }

    parseNew(node) {
      node.callee = this.parseNoCallExpr();

      if (node.callee.type === "Import") {
        this.raise(node.callee.start, ErrorMessages.ImportCallNotNewExpression);
      } else if (node.callee.type === "OptionalMemberExpression" || node.callee.type === "OptionalCallExpression") {
        this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew);
      } else if (this.eat(types.questionDot)) {
        this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew);
      }

      this.parseNewArguments(node);
      return this.finishNode(node, "NewExpression");
    }

    parseNewArguments(node) {
      if (this.eat(types.parenL)) {
        const args = this.parseExprList(types.parenR);
        this.toReferencedList(args);
        node.arguments = args;
      } else {
        node.arguments = [];
      }
    }

    parseTemplateElement(isTagged) {
      const elem = this.startNode();

      if (this.state.value === null) {
        if (!isTagged) {
          this.raise(this.state.start + 1, ErrorMessages.InvalidEscapeSequenceTemplate);
        }
      }

      elem.value = {
        raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
        cooked: this.state.value
      };
      this.next();
      elem.tail = this.match(types.backQuote);
      return this.finishNode(elem, "TemplateElement");
    }

    parseTemplate(isTagged) {
      const node = this.startNode();
      this.next();
      node.expressions = [];
      let curElt = this.parseTemplateElement(isTagged);
      node.quasis = [curElt];

      while (!curElt.tail) {
        this.expect(types.dollarBraceL);
        node.expressions.push(this.parseExpression());
        this.expect(types.braceR);
        node.quasis.push(curElt = this.parseTemplateElement(isTagged));
      }

      this.next();
      return this.finishNode(node, "TemplateLiteral");
    }

    parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
      if (isRecord) {
        this.expectPlugin("recordAndTuple");
      }

      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const propHash = Object.create(null);
      let first = true;
      const node = this.startNode();
      node.properties = [];
      this.next();

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(close)) {
            this.addExtra(node, "trailingComma", this.state.lastTokStart);
            this.next();
            break;
          }
        }

        const prop = this.parsePropertyDefinition(isPattern, refExpressionErrors);

        if (!isPattern) {
          this.checkProto(prop, isRecord, propHash, refExpressionErrors);
        }

        if (isRecord && prop.type !== "ObjectProperty" && prop.type !== "SpreadElement") {
          this.raise(prop.start, ErrorMessages.InvalidRecordProperty);
        }

        if (prop.shorthand) {
          this.addExtra(prop, "shorthand", true);
        }

        node.properties.push(prop);
      }

      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let type = "ObjectExpression";

      if (isPattern) {
        type = "ObjectPattern";
      } else if (isRecord) {
        type = "RecordExpression";
      }

      return this.finishNode(node, type);
    }

    maybeAsyncOrAccessorProp(prop) {
      return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(types.bracketL) || this.match(types.star));
    }

    parsePropertyDefinition(isPattern, refExpressionErrors) {
      let decorators = [];

      if (this.match(types.at)) {
        if (this.hasPlugin("decorators")) {
          this.raise(this.state.start, ErrorMessages.UnsupportedPropertyDecorator);
        }

        while (this.match(types.at)) {
          decorators.push(this.parseDecorator());
        }
      }

      const prop = this.startNode();
      let isGenerator = false;
      let isAsync = false;
      let isAccessor = false;
      let startPos;
      let startLoc;

      if (this.match(types.ellipsis)) {
        if (decorators.length) this.unexpected();

        if (isPattern) {
          this.next();
          prop.argument = this.parseIdentifier();
          this.checkCommaAfterRest(125);
          return this.finishNode(prop, "RestElement");
        }

        return this.parseSpread();
      }

      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }

      prop.method = false;

      if (isPattern || refExpressionErrors) {
        startPos = this.state.start;
        startLoc = this.state.startLoc;
      }

      if (!isPattern) {
        isGenerator = this.eat(types.star);
      }

      const containsEsc = this.state.containsEsc;
      const key = this.parsePropertyName(prop, false);

      if (!isPattern && !isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
        const keyName = key.name;

        if (keyName === "async" && !this.hasPrecedingLineBreak()) {
          isAsync = true;
          isGenerator = this.eat(types.star);
          this.parsePropertyName(prop, false);
        }

        if (keyName === "get" || keyName === "set") {
          isAccessor = true;
          prop.kind = keyName;

          if (this.match(types.star)) {
            isGenerator = true;
            this.raise(this.state.pos, ErrorMessages.AccessorIsGenerator, keyName);
            this.next();
          }

          this.parsePropertyName(prop, false);
        }
      }

      this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      return prop;
    }

    getGetterSetterExpectedParamCount(method) {
      return method.kind === "get" ? 0 : 1;
    }

    checkGetterSetterParams(method) {
      const paramCount = this.getGetterSetterExpectedParamCount(method);
      const start = method.start;

      if (method.params.length !== paramCount) {
        if (method.kind === "get") {
          this.raise(start, ErrorMessages.BadGetterArity);
        } else {
          this.raise(start, ErrorMessages.BadSetterArity);
        }
      }

      if (method.kind === "set" && method.params[method.params.length - 1].type === "RestElement") {
        this.raise(start, ErrorMessages.BadSetterRestParameter);
      }
    }

    parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      if (isAccessor) {
        this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
        this.checkGetterSetterParams(prop);
        return prop;
      }

      if (isAsync || isGenerator || this.match(types.parenL)) {
        if (isPattern) this.unexpected();
        prop.kind = "method";
        prop.method = true;
        return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
      }
    }

    parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
      prop.shorthand = false;

      if (this.eat(types.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
        return this.finishNode(prop, "ObjectProperty");
      }

      if (!prop.computed && prop.key.type === "Identifier") {
        this.checkReservedWord(prop.key.name, prop.key.start, true, false);

        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
        } else if (this.match(types.eq) && refExpressionErrors) {
          if (refExpressionErrors.shorthandAssign === -1) {
            refExpressionErrors.shorthandAssign = this.state.start;
          }

          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
        } else {
          prop.value = prop.key.__clone();
        }

        prop.shorthand = true;
        return this.finishNode(prop, "ObjectProperty");
      }
    }

    parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
      if (!node) this.unexpected();
      return node;
    }

    parsePropertyName(prop, isPrivateNameAllowed) {
      if (this.eat(types.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssignAllowIn();
        this.expect(types.bracketR);
      } else {
        const oldInPropertyName = this.state.inPropertyName;
        this.state.inPropertyName = true;
        prop.key = this.match(types.num) || this.match(types.string) || this.match(types.bigint) || this.match(types.decimal) ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);

        if (prop.key.type !== "PrivateName") {
          prop.computed = false;
        }

        this.state.inPropertyName = oldInPropertyName;
      }

      return prop.key;
    }

    initFunction(node, isAsync) {
      node.id = null;
      node.generator = false;
      node.async = !!isAsync;
    }

    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
      const oldYieldPos = this.state.yieldPos;
      const oldAwaitPos = this.state.awaitPos;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      this.initFunction(node, isAsync);
      node.generator = !!isGenerator;
      const allowModifiers = isConstructor;
      this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      this.prodParam.enter(functionFlags(isAsync, node.generator));
      this.parseFunctionParams(node, allowModifiers);
      this.parseFunctionBodyAndFinish(node, type, true);
      this.prodParam.exit();
      this.scope.exit();
      this.state.yieldPos = oldYieldPos;
      this.state.awaitPos = oldAwaitPos;
      return node;
    }

    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      if (isTuple) {
        this.expectPlugin("recordAndTuple");
      }

      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const node = this.startNode();
      this.next();
      node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);

      if (canBePattern && !this.state.maybeInArrowParameters) {
        this.toReferencedList(node.elements);
      }

      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
    }

    parseArrowExpression(node, params, isAsync, trailingCommaPos) {
      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
      let flags = functionFlags(isAsync, false);

      if (!this.match(types.bracketL) && this.prodParam.hasIn) {
        flags |= PARAM_IN;
      }

      this.prodParam.enter(flags);
      this.initFunction(node, isAsync);
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      const oldYieldPos = this.state.yieldPos;
      const oldAwaitPos = this.state.awaitPos;

      if (params) {
        this.state.maybeInArrowParameters = true;
        this.setArrowFunctionParameters(node, params, trailingCommaPos);
      }

      this.state.maybeInArrowParameters = false;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      this.parseFunctionBody(node, true);
      this.prodParam.exit();
      this.scope.exit();
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.yieldPos = oldYieldPos;
      this.state.awaitPos = oldAwaitPos;
      return this.finishNode(node, "ArrowFunctionExpression");
    }

    setArrowFunctionParameters(node, params, trailingCommaPos) {
      node.params = this.toAssignableList(params, trailingCommaPos);
    }

    parseFunctionBodyAndFinish(node, type, isMethod = false) {
      this.parseFunctionBody(node, false, isMethod);
      this.finishNode(node, type);
    }

    parseFunctionBody(node, allowExpression, isMethod = false) {
      const isExpression = allowExpression && !this.match(types.braceL);
      const oldInParameters = this.state.inParameters;
      this.state.inParameters = false;

      if (isExpression) {
        node.body = this.parseMaybeAssign();
        this.checkParams(node, false, allowExpression, false);
      } else {
        const oldStrict = this.state.strict;
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
        node.body = this.parseBlock(true, false, hasStrictModeDirective => {
          const nonSimple = !this.isSimpleParamList(node.params);

          if (hasStrictModeDirective && nonSimple) {
            const errorPos = (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.end : node.start;
            this.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);
          }

          const strictModeChanged = !oldStrict && this.state.strict;
          this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);

          if (this.state.strict && node.id) {
            this.checkLVal(node.id, BIND_OUTSIDE, undefined, "function name", undefined, strictModeChanged);
          }
        });
        this.prodParam.exit();
        this.state.labels = oldLabels;
      }

      this.state.inParameters = oldInParameters;
    }

    isSimpleParamList(params) {
      for (let i = 0, len = params.length; i < len; i++) {
        if (params[i].type !== "Identifier") return false;
      }

      return true;
    }

    checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
      const nameHash = Object.create(null);

      for (let i = 0; i < node.params.length; i++) {
        this.checkLVal(node.params[i], BIND_VAR, allowDuplicates ? null : nameHash, "function parameter list", undefined, strictModeChanged);
      }
    }

    parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
      const elts = [];
      let first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(close)) {
            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }

            this.next();
            break;
          }
        }

        elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
      }

      return elts;
    }

    parseExprListItem(allowEmpty, refExpressionErrors, refNeedsArrowPos, allowPlaceholder) {
      let elt;

      if (this.match(types.comma)) {
        if (!allowEmpty) {
          this.raise(this.state.pos, ErrorMessages.UnexpectedToken, ",");
        }

        elt = null;
      } else if (this.match(types.ellipsis)) {
        const spreadNodeStartPos = this.state.start;
        const spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(this.parseSpread(refExpressionErrors, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);
      } else if (this.match(types.question)) {
        this.expectPlugin("partialApplication");

        if (!allowPlaceholder) {
          this.raise(this.state.start, ErrorMessages.UnexpectedArgumentPlaceholder);
        }

        const node = this.startNode();
        this.next();
        elt = this.finishNode(node, "ArgumentPlaceholder");
      } else {
        elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem, refNeedsArrowPos);
      }

      return elt;
    }

    parseIdentifier(liberal) {
      const node = this.startNode();
      const name = this.parseIdentifierName(node.start, liberal);
      return this.createIdentifier(node, name);
    }

    createIdentifier(node, name) {
      node.name = name;
      node.loc.identifierName = name;
      return this.finishNode(node, "Identifier");
    }

    parseIdentifierName(pos, liberal) {
      let name;
      const {
        start,
        type
      } = this.state;

      if (type === types.name) {
        name = this.state.value;
      } else if (type.keyword) {
        name = type.keyword;
        const curContext = this.curContext();

        if ((type === types._class || type === types._function) && (curContext === types$1.functionStatement || curContext === types$1.functionExpression)) {
          this.state.context.pop();
        }
      } else {
        throw this.unexpected();
      }

      if (liberal) {
        this.state.type = types.name;
      } else {
        this.checkReservedWord(name, start, !!type.keyword, false);
      }

      this.next();
      return name;
    }

    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (this.prodParam.hasYield && word === "yield") {
        this.raise(startLoc, ErrorMessages.YieldBindingIdentifier);
        return;
      }

      if (word === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(startLoc, ErrorMessages.AwaitBindingIdentifier);
          return;
        }

        if (this.state.awaitPos === -1 && (this.state.maybeInAsyncArrowHead || this.isAwaitAllowed())) {
          this.state.awaitPos = this.state.start;
        }
      }

      if (this.scope.inClass && !this.scope.inNonArrowFunction && word === "arguments") {
        this.raise(startLoc, ErrorMessages.ArgumentsDisallowedInInitializer);
        return;
      }

      if (checkKeywords && isKeyword(word)) {
        this.raise(startLoc, ErrorMessages.UnexpectedKeyword, word);
        return;
      }

      const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;

      if (reservedTest(word, this.inModule)) {
        if (!this.prodParam.hasAwait && word === "await") {
          this.raise(startLoc, ErrorMessages.AwaitNotInAsyncFunction);
        } else {
          this.raise(startLoc, ErrorMessages.UnexpectedReservedWord, word);
        }
      }
    }

    isAwaitAllowed() {
      if (this.scope.inFunction) return this.prodParam.hasAwait;
      if (this.options.allowAwaitOutsideFunction) return true;

      if (this.hasPlugin("topLevelAwait")) {
        return this.inModule && this.prodParam.hasAwait;
      }

      return false;
    }

    parseAwait() {
      const node = this.startNode();
      this.next();

      if (this.state.inParameters) {
        this.raise(node.start, ErrorMessages.AwaitExpressionFormalParameter);
      } else if (this.state.awaitPos === -1) {
        this.state.awaitPos = node.start;
      }

      if (this.eat(types.star)) {
        this.raise(node.start, ErrorMessages.ObsoleteAwaitStar);
      }

      if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
        if (this.hasPrecedingLineBreak() || this.match(types.plusMin) || this.match(types.parenL) || this.match(types.bracketL) || this.match(types.backQuote) || this.match(types.regexp) || this.match(types.slash) || this.hasPlugin("v8intrinsic") && this.match(types.modulo)) {
          this.ambiguousScriptDifferentAst = true;
        } else {
          this.sawUnambiguousESM = true;
        }
      }

      if (!this.state.soloAwait) {
        node.argument = this.parseMaybeUnary();
      }

      return this.finishNode(node, "AwaitExpression");
    }

    parseYield() {
      const node = this.startNode();

      if (this.state.inParameters) {
        this.raise(node.start, ErrorMessages.YieldInParameter);
      } else if (this.state.yieldPos === -1) {
        this.state.yieldPos = node.start;
      }

      this.next();

      if (this.match(types.semi) || !this.match(types.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak()) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(types.star);
        node.argument = this.parseMaybeAssign();
      }

      return this.finishNode(node, "YieldExpression");
    }

    checkPipelineAtInfixOperator(left, leftStartPos) {
      if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
        if (left.type === "SequenceExpression") {
          this.raise(leftStartPos, ErrorMessages.PipelineHeadSequenceExpression);
        }
      }
    }

    parseSmartPipelineBody(childExpression, startPos, startLoc) {
      this.checkSmartPipelineBodyEarlyErrors(childExpression, startPos);
      return this.parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc);
    }

    checkSmartPipelineBodyEarlyErrors(childExpression, startPos) {
      if (this.match(types.arrow)) {
        throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);
      } else if (childExpression.type === "SequenceExpression") {
        this.raise(startPos, ErrorMessages.PipelineBodySequenceExpression);
      }
    }

    parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc) {
      const bodyNode = this.startNodeAt(startPos, startLoc);
      const isSimpleReference = this.isSimpleReference(childExpression);

      if (isSimpleReference) {
        bodyNode.callee = childExpression;
      } else {
        if (!this.topicReferenceWasUsedInCurrentTopicContext()) {
          this.raise(startPos, ErrorMessages.PipelineTopicUnused);
        }

        bodyNode.expression = childExpression;
      }

      return this.finishNode(bodyNode, isSimpleReference ? "PipelineBareFunction" : "PipelineTopicExpression");
    }

    isSimpleReference(expression) {
      switch (expression.type) {
        case "MemberExpression":
          return !expression.computed && this.isSimpleReference(expression.object);

        case "Identifier":
          return true;

        default:
          return false;
      }
    }

    withTopicPermittingContext(callback) {
      const outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }

    withTopicForbiddingContext(callback) {
      const outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }

    withSoloAwaitPermittingContext(callback) {
      const outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = true;

      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    }

    allowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      const prodParamToSet = PARAM_IN & ~flags;

      if (prodParamToSet) {
        this.prodParam.enter(flags | PARAM_IN);

        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }

      return callback();
    }

    disallowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      const prodParamToClear = PARAM_IN & flags;

      if (prodParamToClear) {
        this.prodParam.enter(flags & ~PARAM_IN);

        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }

      return callback();
    }

    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }

    primaryTopicReferenceIsAllowedInCurrentTopicContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }

    topicReferenceWasUsedInCurrentTopicContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }

    parseFSharpPipelineBody(prec) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      const ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return ret;
    }

  }

  const loopLabel = {
    kind: "loop"
  },
        switchLabel = {
    kind: "switch"
  };
  const FUNC_NO_FLAGS = 0b000,
        FUNC_STATEMENT = 0b001,
        FUNC_HANGING_STATEMENT = 0b010,
        FUNC_NULLABLE_ID = 0b100;
  class StatementParser extends ExpressionParser {
    parseTopLevel(file, program) {
      program.sourceType = this.options.sourceType;
      program.interpreter = this.parseInterpreterDirective();
      this.parseBlockBody(program, true, true, types.eof);

      if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
        for (let _i = 0, _Array$from = Array.from(this.scope.undefinedExports); _i < _Array$from.length; _i++) {
          const [name] = _Array$from[_i];
          const pos = this.scope.undefinedExports.get(name);
          this.raise(pos, ErrorMessages.ModuleExportUndefined, name);
        }
      }

      file.program = this.finishNode(program, "Program");
      file.comments = this.state.comments;
      if (this.options.tokens) file.tokens = this.tokens;
      return this.finishNode(file, "File");
    }

    stmtToDirective(stmt) {
      const expr = stmt.expression;
      const directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
      const directive = this.startNodeAt(stmt.start, stmt.loc.start);
      const raw = this.input.slice(expr.start, expr.end);
      const val = directiveLiteral.value = raw.slice(1, -1);
      this.addExtra(directiveLiteral, "raw", raw);
      this.addExtra(directiveLiteral, "rawValue", val);
      directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);
      return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
    }

    parseInterpreterDirective() {
      if (!this.match(types.interpreterDirective)) {
        return null;
      }

      const node = this.startNode();
      node.value = this.state.value;
      this.next();
      return this.finishNode(node, "InterpreterDirective");
    }

    isLet(context) {
      if (!this.isContextual("let")) {
        return false;
      }

      const next = this.nextTokenStart();
      const nextCh = this.input.charCodeAt(next);
      if (nextCh === 91) return true;
      if (context) return false;
      if (nextCh === 123) return true;

      if (isIdentifierStart(nextCh)) {
        let pos = next + 1;

        while (isIdentifierChar(this.input.charCodeAt(pos))) {
          ++pos;
        }

        const ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) return true;
      }

      return false;
    }

    parseStatement(context, topLevel) {
      if (this.match(types.at)) {
        this.parseDecorators(true);
      }

      return this.parseStatementContent(context, topLevel);
    }

    parseStatementContent(context, topLevel) {
      let starttype = this.state.type;
      const node = this.startNode();
      let kind;

      if (this.isLet(context)) {
        starttype = types._var;
        kind = "let";
      }

      switch (starttype) {
        case types._break:
        case types._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);

        case types._debugger:
          return this.parseDebuggerStatement(node);

        case types._do:
          return this.parseDoStatement(node);

        case types._for:
          return this.parseForStatement(node);

        case types._function:
          if (this.lookaheadCharCode() === 46) break;

          if (context) {
            if (this.state.strict) {
              this.raise(this.state.start, ErrorMessages.StrictFunction);
            } else if (context !== "if" && context !== "label") {
              this.raise(this.state.start, ErrorMessages.SloppyFunction);
            }
          }

          return this.parseFunctionStatement(node, false, !context);

        case types._class:
          if (context) this.unexpected();
          return this.parseClass(node, true);

        case types._if:
          return this.parseIfStatement(node);

        case types._return:
          return this.parseReturnStatement(node);

        case types._switch:
          return this.parseSwitchStatement(node);

        case types._throw:
          return this.parseThrowStatement(node);

        case types._try:
          return this.parseTryStatement(node);

        case types._const:
        case types._var:
          kind = kind || this.state.value;

          if (context && kind !== "var") {
            this.raise(this.state.start, ErrorMessages.UnexpectedLexicalDeclaration);
          }

          return this.parseVarStatement(node, kind);

        case types._while:
          return this.parseWhileStatement(node);

        case types._with:
          return this.parseWithStatement(node);

        case types.braceL:
          return this.parseBlock();

        case types.semi:
          return this.parseEmptyStatement(node);

        case types._import:
          {
            const nextTokenCharCode = this.lookaheadCharCode();

            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                break;
              }
          }

        case types._export:
          {
            if (!this.options.allowImportExportEverywhere && !topLevel) {
              this.raise(this.state.start, ErrorMessages.UnexpectedImportExport);
            }

            this.next();
            let result;

            if (starttype === types._import) {
              result = this.parseImport(node);

              if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                this.sawUnambiguousESM = true;
              }
            } else {
              result = this.parseExport(node);

              if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                this.sawUnambiguousESM = true;
              }
            }

            this.assertModuleNodeAllowed(node);
            return result;
          }

        default:
          {
            if (this.isAsyncFunction()) {
              if (context) {
                this.raise(this.state.start, ErrorMessages.AsyncFunctionInSingleStatementContext);
              }

              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
          }
      }

      const maybeName = this.state.value;
      const expr = this.parseExpression();

      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
    }

    assertModuleNodeAllowed(node) {
      if (!this.options.allowImportExportEverywhere && !this.inModule) {
        this.raiseWithData(node.start, {
          code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
        }, ErrorMessages.ImportOutsideModule);
      }
    }

    takeDecorators(node) {
      const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (decorators.length) {
        node.decorators = decorators;
        this.resetStartLocationFromNode(node, decorators[0]);
        this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
      }
    }

    canHaveLeadingDecorator() {
      return this.match(types._class);
    }

    parseDecorators(allowExport) {
      const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      while (this.match(types.at)) {
        const decorator = this.parseDecorator();
        currentContextDecorators.push(decorator);
      }

      if (this.match(types._export)) {
        if (!allowExport) {
          this.unexpected();
        }

        if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, ErrorMessages.DecoratorExportClass);
        }
      } else if (!this.canHaveLeadingDecorator()) {
        throw this.raise(this.state.start, ErrorMessages.UnexpectedLeadingDecorator);
      }
    }

    parseDecorator() {
      this.expectOnePlugin(["decorators-legacy", "decorators"]);
      const node = this.startNode();
      this.next();

      if (this.hasPlugin("decorators")) {
        this.state.decoratorStack.push([]);
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let expr;

        if (this.eat(types.parenL)) {
          expr = this.parseExpression();
          this.expect(types.parenR);
        } else {
          expr = this.parseIdentifier(false);

          while (this.eat(types.dot)) {
            const node = this.startNodeAt(startPos, startLoc);
            node.object = expr;
            node.property = this.parseIdentifier(true);
            node.computed = false;
            expr = this.finishNode(node, "MemberExpression");
          }
        }

        node.expression = this.parseMaybeDecoratorArguments(expr);
        this.state.decoratorStack.pop();
      } else {
        node.expression = this.parseExprSubscripts();
      }

      return this.finishNode(node, "Decorator");
    }

    parseMaybeDecoratorArguments(expr) {
      if (this.eat(types.parenL)) {
        const node = this.startNodeAtNode(expr);
        node.callee = expr;
        node.arguments = this.parseCallExpressionArguments(types.parenR, false);
        this.toReferencedList(node.arguments);
        return this.finishNode(node, "CallExpression");
      }

      return expr;
    }

    parseBreakContinueStatement(node, keyword) {
      const isBreak = keyword === "break";
      this.next();

      if (this.isLineTerminator()) {
        node.label = null;
      } else {
        node.label = this.parseIdentifier();
        this.semicolon();
      }

      this.verifyBreakContinue(node, keyword);
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    }

    verifyBreakContinue(node, keyword) {
      const isBreak = keyword === "break";
      let i;

      for (i = 0; i < this.state.labels.length; ++i) {
        const lab = this.state.labels[i];

        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
          if (node.label && isBreak) break;
        }
      }

      if (i === this.state.labels.length) {
        this.raise(node.start, ErrorMessages.IllegalBreakContinue, keyword);
      }
    }

    parseDebuggerStatement(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    }

    parseHeaderExpression() {
      this.expect(types.parenL);
      const val = this.parseExpression();
      this.expect(types.parenR);
      return val;
    }

    parseDoStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      node.body = this.withTopicForbiddingContext(() => this.parseStatement("do"));
      this.state.labels.pop();
      this.expect(types._while);
      node.test = this.parseHeaderExpression();
      this.eat(types.semi);
      return this.finishNode(node, "DoWhileStatement");
    }

    parseForStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      let awaitAt = -1;

      if (this.isAwaitAllowed() && this.eatContextual("await")) {
        awaitAt = this.state.lastTokStart;
      }

      this.scope.enter(SCOPE_OTHER);
      this.expect(types.parenL);

      if (this.match(types.semi)) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, null);
      }

      const isLet = this.isLet();

      if (this.match(types._var) || this.match(types._const) || isLet) {
        const init = this.startNode();
        const kind = isLet ? "let" : this.state.value;
        this.next();
        this.parseVar(init, true, kind);
        this.finishNode(init, "VariableDeclaration");

        if ((this.match(types._in) || this.isContextual("of")) && init.declarations.length === 1) {
          return this.parseForIn(node, init, awaitAt);
        }

        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, init);
      }

      const refExpressionErrors = new ExpressionErrors();
      const init = this.parseExpression(true, refExpressionErrors);

      if (this.match(types._in) || this.isContextual("of")) {
        this.toAssignable(init);
        const description = this.isContextual("of") ? "for-of statement" : "for-in statement";
        this.checkLVal(init, undefined, undefined, description);
        return this.parseForIn(node, init, awaitAt);
      } else {
        this.checkExpressionErrors(refExpressionErrors, true);
      }

      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, init);
    }

    parseFunctionStatement(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
    }

    parseIfStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement");
    }

    parseReturnStatement(node) {
      if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
        this.raise(this.state.start, ErrorMessages.IllegalReturn);
      }

      this.next();

      if (this.isLineTerminator()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }

      return this.finishNode(node, "ReturnStatement");
    }

    parseSwitchStatement(node) {
      this.next();
      node.discriminant = this.parseHeaderExpression();
      const cases = node.cases = [];
      this.expect(types.braceL);
      this.state.labels.push(switchLabel);
      this.scope.enter(SCOPE_OTHER);
      let cur;

      for (let sawDefault; !this.match(types.braceR);) {
        if (this.match(types._case) || this.match(types._default)) {
          const isCase = this.match(types._case);
          if (cur) this.finishNode(cur, "SwitchCase");
          cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();

          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raise(this.state.lastTokStart, ErrorMessages.MultipleDefaultsInSwitch);
            }

            sawDefault = true;
            cur.test = null;
          }

          this.expect(types.colon);
        } else {
          if (cur) {
            cur.consequent.push(this.parseStatement(null));
          } else {
            this.unexpected();
          }
        }
      }

      this.scope.exit();
      if (cur) this.finishNode(cur, "SwitchCase");
      this.next();
      this.state.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    }

    parseThrowStatement(node) {
      this.next();

      if (this.hasPrecedingLineBreak()) {
        this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow);
      }

      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    }

    parseCatchClauseParam() {
      const param = this.parseBindingAtom();
      const simple = param.type === "Identifier";
      this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(param, BIND_LEXICAL, null, "catch clause");
      return param;
    }

    parseTryStatement(node) {
      this.next();
      node.block = this.parseBlock();
      node.handler = null;

      if (this.match(types._catch)) {
        const clause = this.startNode();
        this.next();

        if (this.match(types.parenL)) {
          this.expect(types.parenL);
          clause.param = this.parseCatchClauseParam();
          this.expect(types.parenR);
        } else {
          clause.param = null;
          this.scope.enter(SCOPE_OTHER);
        }

        clause.body = this.withTopicForbiddingContext(() => this.parseBlock(false, false));
        this.scope.exit();
        node.handler = this.finishNode(clause, "CatchClause");
      }

      node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;

      if (!node.handler && !node.finalizer) {
        this.raise(node.start, ErrorMessages.NoCatchOrFinally);
      }

      return this.finishNode(node, "TryStatement");
    }

    parseVarStatement(node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    }

    parseWhileStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      this.state.labels.push(loopLabel);
      node.body = this.withTopicForbiddingContext(() => this.parseStatement("while"));
      this.state.labels.pop();
      return this.finishNode(node, "WhileStatement");
    }

    parseWithStatement(node) {
      if (this.state.strict) {
        this.raise(this.state.start, ErrorMessages.StrictWith);
      }

      this.next();
      node.object = this.parseHeaderExpression();
      node.body = this.withTopicForbiddingContext(() => this.parseStatement("with"));
      return this.finishNode(node, "WithStatement");
    }

    parseEmptyStatement(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    }

    parseLabeledStatement(node, maybeName, expr, context) {
      for (let _i2 = 0, _this$state$labels = this.state.labels; _i2 < _this$state$labels.length; _i2++) {
        const label = _this$state$labels[_i2];

        if (label.name === maybeName) {
          this.raise(expr.start, ErrorMessages.LabelRedeclaration, maybeName);
        }
      }

      const kind = this.state.type.isLoop ? "loop" : this.match(types._switch) ? "switch" : null;

      for (let i = this.state.labels.length - 1; i >= 0; i--) {
        const label = this.state.labels[i];

        if (label.statementStart === node.start) {
          label.statementStart = this.state.start;
          label.kind = kind;
        } else {
          break;
        }
      }

      this.state.labels.push({
        name: maybeName,
        kind: kind,
        statementStart: this.state.start
      });
      node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.state.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    }

    parseExpressionStatement(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    }

    parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
      const node = this.startNode();
      this.expect(types.braceL);

      if (createNewLexicalScope) {
        this.scope.enter(SCOPE_OTHER);
      }

      this.parseBlockBody(node, allowDirectives, false, types.braceR, afterBlockParse);

      if (createNewLexicalScope) {
        this.scope.exit();
      }

      return this.finishNode(node, "BlockStatement");
    }

    isValidDirective(stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    }

    parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
      const body = node.body = [];
      const directives = node.directives = [];
      this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);
    }

    parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
      const octalPositions = [];
      const oldStrict = this.state.strict;
      let hasStrictModeDirective = false;
      let parsedNonDirective = false;

      while (!this.match(end)) {
        if (!parsedNonDirective && this.state.octalPositions.length) {
          octalPositions.push(...this.state.octalPositions);
        }

        const stmt = this.parseStatement(null, topLevel);

        if (directives && !parsedNonDirective && this.isValidDirective(stmt)) {
          const directive = this.stmtToDirective(stmt);
          directives.push(directive);

          if (!hasStrictModeDirective && directive.value.value === "use strict") {
            hasStrictModeDirective = true;
            this.setStrict(true);
          }

          continue;
        }

        parsedNonDirective = true;
        body.push(stmt);
      }

      if (this.state.strict && octalPositions.length) {
        for (let _i3 = 0; _i3 < octalPositions.length; _i3++) {
          const pos = octalPositions[_i3];
          this.raise(pos, ErrorMessages.StrictOctalLiteral);
        }
      }

      if (afterBlockParse) {
        afterBlockParse.call(this, hasStrictModeDirective);
      }

      if (!oldStrict) {
        this.setStrict(false);
      }

      this.next();
    }

    parseFor(node, init) {
      node.init = init;
      this.expect(types.semi);
      node.test = this.match(types.semi) ? null : this.parseExpression();
      this.expect(types.semi);
      node.update = this.match(types.parenR) ? null : this.parseExpression();
      this.expect(types.parenR);
      node.body = this.withTopicForbiddingContext(() => this.parseStatement("for"));
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, "ForStatement");
    }

    parseForIn(node, init, awaitAt) {
      const isForIn = this.match(types._in);
      this.next();

      if (isForIn) {
        if (awaitAt > -1) this.unexpected(awaitAt);
      } else {
        node.await = awaitAt > -1;
      }

      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(init.start, ErrorMessages.ForInOfLoopInitializer, isForIn ? "for-in" : "for-of");
      } else if (init.type === "AssignmentPattern") {
        this.raise(init.start, ErrorMessages.InvalidLhs, "for-loop");
      }

      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
      this.expect(types.parenR);
      node.body = this.withTopicForbiddingContext(() => this.parseStatement("for"));
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    }

    parseVar(node, isFor, kind) {
      const declarations = node.declarations = [];
      const isTypescript = this.hasPlugin("typescript");
      node.kind = kind;

      for (;;) {
        const decl = this.startNode();
        this.parseVarId(decl, kind);

        if (this.eat(types.eq)) {
          decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
        } else {
          if (kind === "const" && !(this.match(types._in) || this.isContextual("of"))) {
            if (!isTypescript) {
              this.unexpected();
            }
          } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types._in) || this.isContextual("of")))) {
            this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Complex binding patterns");
          }

          decl.init = null;
        }

        declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types.comma)) break;
      }

      return node;
    }

    parseVarId(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, undefined, "variable declaration", kind !== "var");
    }

    parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {
      const isStatement = statement & FUNC_STATEMENT;
      const isHangingStatement = statement & FUNC_HANGING_STATEMENT;
      const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
      this.initFunction(node, isAsync);

      if (this.match(types.star) && isHangingStatement) {
        this.raise(this.state.start, ErrorMessages.GeneratorInSingleStatementContext);
      }

      node.generator = this.eat(types.star);

      if (isStatement) {
        node.id = this.parseFunctionId(requireId);
      }

      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      const oldYieldPos = this.state.yieldPos;
      const oldAwaitPos = this.state.awaitPos;
      this.state.maybeInArrowParameters = false;
      this.state.yieldPos = -1;
      this.state.awaitPos = -1;
      this.scope.enter(SCOPE_FUNCTION);
      this.prodParam.enter(functionFlags(isAsync, node.generator));

      if (!isStatement) {
        node.id = this.parseFunctionId();
      }

      this.parseFunctionParams(node);
      this.withTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
      });
      this.prodParam.exit();
      this.scope.exit();

      if (isStatement && !isHangingStatement) {
        this.registerFunctionStatementId(node);
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.yieldPos = oldYieldPos;
      this.state.awaitPos = oldAwaitPos;
      return node;
    }

    parseFunctionId(requireId) {
      return requireId || this.match(types.name) ? this.parseIdentifier() : null;
    }

    parseFunctionParams(node, allowModifiers) {
      const oldInParameters = this.state.inParameters;
      this.state.inParameters = true;
      this.expect(types.parenL);
      node.params = this.parseBindingList(types.parenR, 41, false, allowModifiers);
      this.state.inParameters = oldInParameters;
      this.checkYieldAwaitInDefaultParams();
    }

    registerFunctionStatementId(node) {
      if (!node.id) return;
      this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);
    }

    parseClass(node, isStatement, optionalId) {
      this.next();
      this.takeDecorators(node);
      const oldStrict = this.state.strict;
      this.state.strict = true;
      this.parseClassId(node, isStatement, optionalId);
      this.parseClassSuper(node);
      node.body = this.parseClassBody(!!node.superClass, oldStrict);
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    }

    isClassProperty() {
      return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);
    }

    isClassMethod() {
      return this.match(types.parenL);
    }

    isNonstaticConstructor(method) {
      return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
    }

    parseClassBody(constructorAllowsSuper, oldStrict) {
      this.classScope.enter();
      const state = {
        hadConstructor: false
      };
      let decorators = [];
      const classBody = this.startNode();
      classBody.body = [];
      this.expect(types.braceL);
      this.withTopicForbiddingContext(() => {
        while (!this.match(types.braceR)) {
          if (this.eat(types.semi)) {
            if (decorators.length > 0) {
              throw this.raise(this.state.lastTokEnd, ErrorMessages.DecoratorSemicolon);
            }

            continue;
          }

          if (this.match(types.at)) {
            decorators.push(this.parseDecorator());
            continue;
          }

          const member = this.startNode();

          if (decorators.length) {
            member.decorators = decorators;
            this.resetStartLocationFromNode(member, decorators[0]);
            decorators = [];
          }

          this.parseClassMember(classBody, member, state, constructorAllowsSuper);

          if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
            this.raise(member.start, ErrorMessages.DecoratorConstructor);
          }
        }
      });
      this.state.strict = oldStrict;
      this.next();

      if (decorators.length) {
        throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);
      }

      this.classScope.exit();
      return this.finishNode(classBody, "ClassBody");
    }

    parseClassMemberFromModifier(classBody, member) {
      const key = this.parseIdentifier(true);

      if (this.isClassMethod()) {
        const method = member;
        method.kind = "method";
        method.computed = false;
        method.key = key;
        method.static = false;
        this.pushClassMethod(classBody, method, false, false, false, false);
        return true;
      } else if (this.isClassProperty()) {
        const prop = member;
        prop.computed = false;
        prop.key = key;
        prop.static = false;
        classBody.body.push(this.parseClassProperty(prop));
        return true;
      }

      return false;
    }

    parseClassMember(classBody, member, state, constructorAllowsSuper) {
      const isStatic = this.isContextual("static");

      if (isStatic && this.parseClassMemberFromModifier(classBody, member)) {
        return;
      }

      this.parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper);
    }

    parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {
      const publicMethod = member;
      const privateMethod = member;
      const publicProp = member;
      const privateProp = member;
      const method = publicMethod;
      const publicMember = publicMethod;
      member.static = isStatic;

      if (this.eat(types.star)) {
        method.kind = "method";
        this.parseClassElementName(method);

        if (method.key.type === "PrivateName") {
          this.pushClassPrivateMethod(classBody, privateMethod, true, false);
          return;
        }

        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsGenerator);
        }

        this.pushClassMethod(classBody, publicMethod, true, false, false, false);
        return;
      }

      const containsEsc = this.state.containsEsc;
      const key = this.parseClassElementName(member);
      const isPrivate = key.type === "PrivateName";
      const isSimple = key.type === "Identifier";
      const maybeQuestionTokenStart = this.state.start;
      this.parsePostMemberNameModifiers(publicMember);

      if (this.isClassMethod()) {
        method.kind = "method";

        if (isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          return;
        }

        const isConstructor = this.isNonstaticConstructor(publicMethod);
        let allowsDirectSuper = false;

        if (isConstructor) {
          publicMethod.kind = "constructor";

          if (state.hadConstructor && !this.hasPlugin("typescript")) {
            this.raise(key.start, ErrorMessages.DuplicateConstructor);
          }

          state.hadConstructor = true;
          allowsDirectSuper = constructorAllowsSuper;
        }

        this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
      } else if (this.isClassProperty()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else if (isSimple && key.name === "async" && !containsEsc && !this.isLineTerminator()) {
        const isGenerator = this.eat(types.star);

        if (publicMember.optional) {
          this.unexpected(maybeQuestionTokenStart);
        }

        method.kind = "method";
        this.parseClassElementName(method);
        this.parsePostMemberNameModifiers(publicMember);

        if (method.key.type === "PrivateName") {
          this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAsync);
          }

          this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
        }
      } else if (isSimple && (key.name === "get" || key.name === "set") && !containsEsc && !(this.match(types.star) && this.isLineTerminator())) {
        method.kind = key.name;
        this.parseClassElementName(publicMethod);

        if (method.key.type === "PrivateName") {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAccessor);
          }

          this.pushClassMethod(classBody, publicMethod, false, false, false, false);
        }

        this.checkGetterSetterParams(publicMethod);
      } else if (this.isLineTerminator()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else {
        this.unexpected();
      }
    }

    parseClassElementName(member) {
      const key = this.parsePropertyName(member, true);

      if (!member.computed && member.static && (key.name === "prototype" || key.value === "prototype")) {
        this.raise(key.start, ErrorMessages.StaticPrototype);
      }

      if (key.type === "PrivateName" && key.id.name === "constructor") {
        this.raise(key.start, ErrorMessages.ConstructorClassPrivateField);
      }

      return key;
    }

    pushClassProperty(classBody, prop) {
      if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
        this.raise(prop.key.start, ErrorMessages.ConstructorClassField);
      }

      classBody.body.push(this.parseClassProperty(prop));
    }

    pushClassPrivateProperty(classBody, prop) {
      this.expectPlugin("classPrivateProperties", prop.key.start);
      const node = this.parseClassPrivateProperty(prop);
      classBody.body.push(node);
      this.classScope.declarePrivateName(node.key.id.name, CLASS_ELEMENT_OTHER, node.key.start);
    }

    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
    }

    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      this.expectPlugin("classPrivateMethods", method.key.start);
      const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
      classBody.body.push(node);
      const kind = node.kind === "get" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
      this.classScope.declarePrivateName(node.key.id.name, kind, node.key.start);
    }

    parsePostMemberNameModifiers(methodOrProp) {}

    parseClassPrivateProperty(node) {
      this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
      this.prodParam.enter(PARAM);
      node.value = this.eat(types.eq) ? this.parseMaybeAssignAllowIn() : null;
      this.semicolon();
      this.prodParam.exit();
      this.scope.exit();
      return this.finishNode(node, "ClassPrivateProperty");
    }

    parseClassProperty(node) {
      if (!node.typeAnnotation) {
        this.expectPlugin("classProperties");
      }

      this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
      this.prodParam.enter(PARAM);

      if (this.match(types.eq)) {
        this.expectPlugin("classProperties");
        this.next();
        node.value = this.parseMaybeAssignAllowIn();
      } else {
        node.value = null;
      }

      this.semicolon();
      this.prodParam.exit();
      this.scope.exit();
      return this.finishNode(node, "ClassProperty");
    }

    parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {
      if (this.match(types.name)) {
        node.id = this.parseIdentifier();

        if (isStatement) {
          this.checkLVal(node.id, bindingType, undefined, "class name");
        }
      } else {
        if (optionalId || !isStatement) {
          node.id = null;
        } else {
          this.unexpected(null, ErrorMessages.MissingClassName);
        }
      }
    }

    parseClassSuper(node) {
      node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
    }

    parseExport(node) {
      const hasDefault = this.maybeParseExportDefaultSpecifier(node);
      const parseAfterDefault = !hasDefault || this.eat(types.comma);
      const hasStar = parseAfterDefault && this.eatExportStar(node);
      const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
      const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types.comma));
      const isFromRequired = hasDefault || hasStar;

      if (hasStar && !hasNamespace) {
        if (hasDefault) this.unexpected();
        this.parseExportFrom(node, true);
        return this.finishNode(node, "ExportAllDeclaration");
      }

      const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);

      if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
        throw this.unexpected(null, types.braceL);
      }

      let hasDeclaration;

      if (isFromRequired || hasSpecifiers) {
        hasDeclaration = false;
        this.parseExportFrom(node, isFromRequired);
      } else {
        hasDeclaration = this.maybeParseExportDeclaration(node);
      }

      if (isFromRequired || hasSpecifiers || hasDeclaration) {
        this.checkExport(node, true, false, !!node.source);
        return this.finishNode(node, "ExportNamedDeclaration");
      }

      if (this.eat(types._default)) {
        node.declaration = this.parseExportDefaultExpression();
        this.checkExport(node, true, true);
        return this.finishNode(node, "ExportDefaultDeclaration");
      }

      throw this.unexpected(null, types.braceL);
    }

    eatExportStar(node) {
      return this.eat(types.star);
    }

    maybeParseExportDefaultSpecifier(node) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        const specifier = this.startNode();
        specifier.exported = this.parseIdentifier(true);
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return true;
      }

      return false;
    }

    maybeParseExportNamespaceSpecifier(node) {
      if (this.isContextual("as")) {
        if (!node.specifiers) node.specifiers = [];
        const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
        this.next();
        specifier.exported = this.parseIdentifier(true);
        node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
        return true;
      }

      return false;
    }

    maybeParseExportNamedSpecifiers(node) {
      if (this.match(types.braceL)) {
        if (!node.specifiers) node.specifiers = [];
        node.specifiers.push(...this.parseExportSpecifiers());
        node.source = null;
        node.declaration = null;
        return true;
      }

      return false;
    }

    maybeParseExportDeclaration(node) {
      if (this.shouldParseExportDeclaration()) {
        node.specifiers = [];
        node.source = null;
        node.declaration = this.parseExportDeclaration(node);
        return true;
      }

      return false;
    }

    isAsyncFunction() {
      if (!this.isContextual("async")) return false;
      const next = this.nextTokenStart();
      return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
    }

    parseExportDefaultExpression() {
      const expr = this.startNode();
      const isAsync = this.isAsyncFunction();

      if (this.match(types._function) || isAsync) {
        this.next();

        if (isAsync) {
          this.next();
        }

        return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
      } else if (this.match(types._class)) {
        return this.parseClass(expr, true, true);
      } else if (this.match(types.at)) {
        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport);
        }

        this.parseDecorators(false);
        return this.parseClass(expr, true, true);
      } else if (this.match(types._const) || this.match(types._var) || this.isLet()) {
        throw this.raise(this.state.start, ErrorMessages.UnsupportedDefaultExport);
      } else {
        const res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
      }
    }

    parseExportDeclaration(node) {
      return this.parseStatement(null);
    }

    isExportDefaultSpecifier() {
      if (this.match(types.name)) {
        const value = this.state.value;

        if (value === "async" && !this.state.containsEsc || value === "let") {
          return false;
        }

        if ((value === "type" || value === "interface") && !this.state.containsEsc) {
          const l = this.lookahead();

          if (l.type === types.name && l.value !== "from" || l.type === types.braceL) {
            this.expectOnePlugin(["flow", "typescript"]);
            return false;
          }
        }
      } else if (!this.match(types._default)) {
        return false;
      }

      const next = this.nextTokenStart();
      const hasFrom = this.isUnparsedContextual(next, "from");

      if (this.input.charCodeAt(next) === 44 || this.match(types.name) && hasFrom) {
        return true;
      }

      if (this.match(types._default) && hasFrom) {
        const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
        return nextAfterFrom === 34 || nextAfterFrom === 39;
      }

      return false;
    }

    parseExportFrom(node, expect) {
      if (this.eatContextual("from")) {
        node.source = this.parseImportSource();
        this.checkExport(node);
      } else {
        if (expect) {
          this.unexpected();
        } else {
          node.source = null;
        }
      }

      this.semicolon();
    }

    shouldParseExportDeclaration() {
      if (this.match(types.at)) {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);

        if (this.hasPlugin("decorators")) {
          if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
            this.unexpected(this.state.start, ErrorMessages.DecoratorBeforeExport);
          } else {
            return true;
          }
        }
      }

      return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
    }

    checkExport(node, checkNames, isDefault, isFrom) {
      if (checkNames) {
        if (isDefault) {
          this.checkDuplicateExports(node, "default");

          if (this.hasPlugin("exportDefaultFrom")) {
            var _declaration$extra;

            const declaration = node.declaration;

            if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) == null ? void 0 : _declaration$extra.parenthesized)) {
              this.raise(declaration.start, ErrorMessages.ExportDefaultFromAsIdentifier);
            }
          }
        } else if (node.specifiers && node.specifiers.length) {
          for (let _i4 = 0, _node$specifiers = node.specifiers; _i4 < _node$specifiers.length; _i4++) {
            const specifier = _node$specifiers[_i4];
            this.checkDuplicateExports(specifier, specifier.exported.name);

            if (!isFrom && specifier.local) {
              this.checkReservedWord(specifier.local.name, specifier.local.start, true, false);
              this.scope.checkLocalExport(specifier.local);
            }
          }
        } else if (node.declaration) {
          if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
            const id = node.declaration.id;
            if (!id) throw new Error("Assertion failure");
            this.checkDuplicateExports(node, id.name);
          } else if (node.declaration.type === "VariableDeclaration") {
            for (let _i5 = 0, _node$declaration$dec = node.declaration.declarations; _i5 < _node$declaration$dec.length; _i5++) {
              const declaration = _node$declaration$dec[_i5];
              this.checkDeclaration(declaration.id);
            }
          }
        }
      }

      const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (currentContextDecorators.length) {
        throw this.raise(node.start, ErrorMessages.UnsupportedDecoratorExport);
      }
    }

    checkDeclaration(node) {
      if (node.type === "Identifier") {
        this.checkDuplicateExports(node, node.name);
      } else if (node.type === "ObjectPattern") {
        for (let _i6 = 0, _node$properties = node.properties; _i6 < _node$properties.length; _i6++) {
          const prop = _node$properties[_i6];
          this.checkDeclaration(prop);
        }
      } else if (node.type === "ArrayPattern") {
        for (let _i7 = 0, _node$elements = node.elements; _i7 < _node$elements.length; _i7++) {
          const elem = _node$elements[_i7];

          if (elem) {
            this.checkDeclaration(elem);
          }
        }
      } else if (node.type === "ObjectProperty") {
        this.checkDeclaration(node.value);
      } else if (node.type === "RestElement") {
        this.checkDeclaration(node.argument);
      } else if (node.type === "AssignmentPattern") {
        this.checkDeclaration(node.left);
      }
    }

    checkDuplicateExports(node, name) {
      if (this.state.exportedIdentifiers.indexOf(name) > -1) {
        this.raise(node.start, name === "default" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, name);
      }

      this.state.exportedIdentifiers.push(name);
    }

    parseExportSpecifiers() {
      const nodes = [];
      let first = true;
      this.expect(types.braceL);

      while (!this.eat(types.braceR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
          if (this.eat(types.braceR)) break;
        }

        const node = this.startNode();
        node.local = this.parseIdentifier(true);
        node.exported = this.eatContextual("as") ? this.parseIdentifier(true) : node.local.__clone();
        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }

      return nodes;
    }

    parseImport(node) {
      node.specifiers = [];

      if (!this.match(types.string)) {
        const hasDefault = this.maybeParseDefaultImportSpecifier(node);
        const parseNext = !hasDefault || this.eat(types.comma);
        const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
        this.expectContextual("from");
      }

      node.source = this.parseImportSource();
      const attributes = this.maybeParseModuleAttributes();

      if (attributes) {
        node.attributes = attributes;
      }

      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    }

    parseImportSource() {
      if (!this.match(types.string)) this.unexpected();
      return this.parseExprAtom();
    }

    shouldParseDefaultImport(node) {
      return this.match(types.name);
    }

    parseImportSpecifierLocal(node, specifier, type, contextDescription) {
      specifier.local = this.parseIdentifier();
      this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);
      node.specifiers.push(this.finishNode(specifier, type));
    }

    maybeParseModuleAttributes() {
      if (this.match(types._with) && !this.hasPrecedingLineBreak()) {
        this.expectPlugin("moduleAttributes");
        this.next();
      } else {
        if (this.hasPlugin("moduleAttributes")) return [];
        return null;
      }

      const attrs = [];
      const attributes = new Set();

      do {
        const node = this.startNode();
        node.key = this.parseIdentifier(true);

        if (node.key.name !== "type") {
          this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, node.key.name);
        }

        if (attributes.has(node.key.name)) {
          this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, node.key.name);
        }

        attributes.add(node.key.name);
        this.expect(types.colon);

        if (!this.match(types.string)) {
          throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
        }

        node.value = this.parseLiteral(this.state.value, "StringLiteral");
        this.finishNode(node, "ImportAttribute");
        attrs.push(node);
      } while (this.eat(types.comma));

      return attrs;
    }

    maybeParseDefaultImportSpecifier(node) {
      if (this.shouldParseDefaultImport(node)) {
        this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
        return true;
      }

      return false;
    }

    maybeParseStarImportSpecifier(node) {
      if (this.match(types.star)) {
        const specifier = this.startNode();
        this.next();
        this.expectContextual("as");
        this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
        return true;
      }

      return false;
    }

    parseNamedImportSpecifiers(node) {
      let first = true;
      this.expect(types.braceL);

      while (!this.eat(types.braceR)) {
        if (first) {
          first = false;
        } else {
          if (this.eat(types.colon)) {
            throw this.raise(this.state.start, ErrorMessages.DestructureNamedImport);
          }

          this.expect(types.comma);
          if (this.eat(types.braceR)) break;
        }

        this.parseImportSpecifier(node);
      }
    }

    parseImportSpecifier(node) {
      const specifier = this.startNode();
      specifier.imported = this.parseIdentifier(true);

      if (this.eatContextual("as")) {
        specifier.local = this.parseIdentifier();
      } else {
        this.checkReservedWord(specifier.imported.name, specifier.start, true, true);
        specifier.local = specifier.imported.__clone();
      }

      this.checkLVal(specifier.local, BIND_LEXICAL, undefined, "import specifier");
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    }

  }

  class ClassScope {
    constructor() {
      this.privateNames = new Set();
      this.loneAccessors = new Map();
      this.undefinedPrivateNames = new Map();
    }

  }
  class ClassScopeHandler {
    constructor(raise) {
      this.stack = [];
      this.undefinedPrivateNames = new Map();
      this.raise = raise;
    }

    current() {
      return this.stack[this.stack.length - 1];
    }

    enter() {
      this.stack.push(new ClassScope());
    }

    exit() {
      const oldClassScope = this.stack.pop();
      const current = this.current();

      for (let _i = 0, _Array$from = Array.from(oldClassScope.undefinedPrivateNames); _i < _Array$from.length; _i++) {
        const [name, pos] = _Array$from[_i];

        if (current) {
          if (!current.undefinedPrivateNames.has(name)) {
            current.undefinedPrivateNames.set(name, pos);
          }
        } else {
          this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
        }
      }
    }

    declarePrivateName(name, elementType, pos) {
      const classScope = this.current();
      let redefined = classScope.privateNames.has(name);

      if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
        const accessor = redefined && classScope.loneAccessors.get(name);

        if (accessor) {
          const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
          const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
          const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
          const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
          redefined = oldKind === newKind || oldStatic !== newStatic;
          if (!redefined) classScope.loneAccessors.delete(name);
        } else if (!redefined) {
          classScope.loneAccessors.set(name, elementType);
        }
      }

      if (redefined) {
        this.raise(pos, ErrorMessages.PrivateNameRedeclaration, name);
      }

      classScope.privateNames.add(name);
      classScope.undefinedPrivateNames.delete(name);
    }

    usePrivateName(name, pos) {
      let classScope;

      for (let _i2 = 0, _this$stack = this.stack; _i2 < _this$stack.length; _i2++) {
        classScope = _this$stack[_i2];
        if (classScope.privateNames.has(name)) return;
      }

      if (classScope) {
        classScope.undefinedPrivateNames.set(name, pos);
      } else {
        this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
      }
    }

  }

  class Parser extends StatementParser {
    constructor(options, input) {
      options = getOptions(options);
      super(options, input);
      const ScopeHandler = this.getScopeHandler();
      this.options = options;
      this.inModule = this.options.sourceType === "module";
      this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);
      this.prodParam = new ProductionParameterHandler();
      this.classScope = new ClassScopeHandler(this.raise.bind(this));
      this.plugins = pluginsMap(this.options.plugins);
      this.filename = options.sourceFilename;
    }

    getScopeHandler() {
      return ScopeHandler;
    }

    parse() {
      let paramFlags = PARAM;

      if (this.hasPlugin("topLevelAwait") && this.inModule) {
        paramFlags |= PARAM_AWAIT;
      }

      this.scope.enter(SCOPE_PROGRAM);
      this.prodParam.enter(paramFlags);
      const file = this.startNode();
      const program = this.startNode();
      this.nextToken();
      file.errors = null;
      this.parseTopLevel(file, program);
      file.errors = this.state.errors;
      return file;
    }

  }

  function pluginsMap(plugins) {
    const pluginMap = new Map();

    for (let _i = 0; _i < plugins.length; _i++) {
      const plugin = plugins[_i];
      const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
      if (!pluginMap.has(name)) pluginMap.set(name, options || {});
    }

    return pluginMap;
  }

  function parse(input, options) {
    var _options;

    if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
      options = Object.assign({}, options);

      try {
        options.sourceType = "module";
        const parser = getParser(options, input);
        const ast = parser.parse();

        if (parser.sawUnambiguousESM) {
          return ast;
        }

        if (parser.ambiguousScriptDifferentAst) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused) {}
        } else {
          ast.program.sourceType = "script";
        }

        return ast;
      } catch (moduleError) {
        try {
          options.sourceType = "script";
          return getParser(options, input).parse();
        } catch (_unused2) {}

        throw moduleError;
      }
    } else {
      return getParser(options, input).parse();
    }
  }
  function parseExpression(input, options) {
    const parser = getParser(options, input);

    if (parser.options.strictMode) {
      parser.state.strict = true;
    }

    return parser.getExpression();
  }

  function getParser(options, input) {
    let cls = Parser;

    if (options == null ? void 0 : options.plugins) {
      validatePlugins(options.plugins);
      cls = getParserClass(options.plugins);
    }

    return new cls(options, input);
  }

  const parserClassCache = {};

  function getParserClass(pluginsFromOptions) {
    const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));
    const key = pluginList.join("/");
    let cls = parserClassCache[key];

    if (!cls) {
      cls = Parser;

      for (let _i = 0; _i < pluginList.length; _i++) {
        const plugin = pluginList[_i];
        cls = mixinPlugins[plugin](cls);
      }

      parserClassCache[key] = cls;
    }

    return cls;
  }

  exports.parse = parse;
  exports.parseExpression = parseExpression;
  exports.tokTypes = types;

  });

  class WalkerBase {constructor() { WalkerBase.prototype.__init.call(this);WalkerBase.prototype.__init2.call(this);WalkerBase.prototype.__init3.call(this);WalkerBase.prototype.__init4.call(this); }
  	 __init() {this.should_skip = false;}
  	 __init2() {this.should_remove = false;}
  	 __init3() {this.replacement = null;}

  	 __init4() {this.context = {
  		skip: () => (this.should_skip = true),
  		remove: () => (this.should_remove = true),
  		replace: (node) => (this.replacement = node)
  	};}

  	 replace(parent, prop, index, node) {
  		if (parent) {
  			if (index !== null) {
  				parent[prop][index] = node;
  			} else {
  				parent[prop] = node;
  			}
  		}
  	}

  	 remove(parent, prop, index) {
  		if (parent) {
  			if (index !== null) {
  				parent[prop].splice(index, 1);
  			} else {
  				delete parent[prop];
  			}
  		}
  	}
  }

  class SyncWalkerClass extends WalkerBase {
  	
  	

  	constructor(walker) {
  		super();
  		this.enter = walker.enter;
  		this.leave = walker.leave;
  	}

  	 visit(
  		node,
  		parent,
  		enter,
  		leave,
  		prop,
  		index
  	) {
  		if (node) {
  			if (enter) {
  				const _should_skip = this.should_skip;
  				const _should_remove = this.should_remove;
  				const _replacement = this.replacement;
  				this.should_skip = false;
  				this.should_remove = false;
  				this.replacement = null;

  				enter.call(this.context, node, parent, prop, index);

  				if (this.replacement) {
  					node = this.replacement;
  					this.replace(parent, prop, index, node);
  				}

  				if (this.should_remove) {
  					this.remove(parent, prop, index);
  				}

  				const skipped = this.should_skip;
  				const removed = this.should_remove;

  				this.should_skip = _should_skip;
  				this.should_remove = _should_remove;
  				this.replacement = _replacement;

  				if (skipped) return node;
  				if (removed) return null;
  			}

  			for (const key in node) {
  				const value = (node )[key];

  				if (typeof value !== "object") {
  					continue;
  				} else if (Array.isArray(value)) {
  					for (let i = 0; i < value.length; i += 1) {
  						if (value[i] !== null && typeof value[i].type === 'string') {
  							if (!this.visit(value[i], node, enter, leave, key, i)) {
  								// removed
  								i--;
  							}
  						}
  					}
  				} else if (value !== null && typeof value.type === "string") {
  					this.visit(value, node, enter, leave, key, null);
  				}
  			}

  			if (leave) {
  				const _replacement = this.replacement;
  				const _should_remove = this.should_remove;
  				this.replacement = null;
  				this.should_remove = false;

  				leave.call(this.context, node, parent, prop, index);

  				if (this.replacement) {
  					node = this.replacement;
  					this.replace(parent, prop, index, node);
  				}

  				if (this.should_remove) {
  					this.remove(parent, prop, index);
  				}

  				const removed = this.should_remove;

  				this.replacement = _replacement;
  				this.should_remove = _should_remove;

  				if (removed) return null;
  			}
  		}

  		return node;
  	}
  }

  function walk$1(ast, walker) {
  	const instance = new SyncWalkerClass(walker);
  	return instance.visit(ast, null, walker.enter, walker.leave);
  }

  const isLiteralWhitelisted = /*#__PURE__*/ makeMap('true,false,null,this');
  const transformExpression = (node, context) => {
      if (node.type === 5 /* INTERPOLATION */) {
          node.content = processExpression(node.content, context);
      }
      else if (node.type === 1 /* ELEMENT */) {
          // handle directives on element
          for (let i = 0; i < node.props.length; i++) {
              const dir = node.props[i];
              // do not process for v-on & v-for since they are special handled
              if (dir.type === 7 /* DIRECTIVE */ && dir.name !== 'for') {
                  const exp = dir.exp;
                  const arg = dir.arg;
                  // do not process exp if this is v-on:arg - we need special handling
                  // for wrapping inline statements.
                  if (exp &&
                      exp.type === 4 /* SIMPLE_EXPRESSION */ &&
                      !(dir.name === 'on' && arg)) {
                      dir.exp = processExpression(exp, context, 
                      // slot args must be processed as function params
                      dir.name === 'slot');
                  }
                  if (arg && arg.type === 4 /* SIMPLE_EXPRESSION */ && !arg.isStatic) {
                      dir.arg = processExpression(arg, context);
                  }
              }
          }
      }
  };
  // Important: since this function uses Node.js only dependencies, it should
  // always be used with a leading !false check so that it can be
  // tree-shaken from the browser build.
  function processExpression(node, context, 
  // some expressions like v-slot props & v-for aliases should be parsed as
  // function params
  asParams = false, 
  // v-on handler values may contain multiple statements
  asRawStatements = false) {
      if (!context.prefixIdentifiers || !node.content.trim()) {
          return node;
      }
      const { bindingMetadata } = context;
      const prefix = (raw) => {
          const source = hasOwn(bindingMetadata, raw)
              ? `$` + bindingMetadata[raw]
              : `_ctx`;
          return `${source}.${raw}`;
      };
      // fast path if expression is a simple identifier.
      const rawExp = node.content;
      // bail on parens to prevent any possible function invocations.
      const bailConstant = rawExp.indexOf(`(`) > -1;
      if (isSimpleIdentifier(rawExp)) {
          if (!asParams &&
              !context.identifiers[rawExp] &&
              !isGloballyWhitelisted(rawExp) &&
              !isLiteralWhitelisted(rawExp)) {
              node.content = prefix(rawExp);
          }
          else if (!context.identifiers[rawExp] && !bailConstant) {
              // mark node constant for hoisting unless it's referring a scope variable
              node.isConstant = true;
          }
          return node;
      }
      let ast;
      // exp needs to be parsed differently:
      // 1. Multiple inline statements (v-on, with presence of `;`): parse as raw
      //    exp, but make sure to pad with spaces for consistent ranges
      // 2. Expressions: wrap with parens (for e.g. object expressions)
      // 3. Function arguments (v-for, v-slot): place in a function argument position
      const source = asRawStatements
          ? ` ${rawExp} `
          : `(${rawExp})${asParams ? `=>{}` : ``}`;
      try {
          ast = lib.parse(source, {
              plugins: [...context.expressionPlugins, ...babelParserDefaultPlugins]
          }).program;
      }
      catch (e) {
          context.onError(createCompilerError(43 /* X_INVALID_EXPRESSION */, node.loc, undefined, e.message));
          return node;
      }
      const ids = [];
      const knownIds = Object.create(context.identifiers);
      const isDuplicate = (node) => ids.some(id => id.start === node.start);
      walk$1(ast, {
          enter(node, parent) {
              if (node.type === 'Identifier') {
                  if (!isDuplicate(node)) {
                      const needPrefix = shouldPrefix(node, parent);
                      if (!knownIds[node.name] && needPrefix) {
                          if (isPropertyShorthand(node, parent)) {
                              // property shorthand like { foo }, we need to add the key since we
                              // rewrite the value
                              node.prefix = `${node.name}: `;
                          }
                          node.name = prefix(node.name);
                          ids.push(node);
                      }
                      else if (!isStaticPropertyKey(node, parent)) {
                          // The identifier is considered constant unless it's pointing to a
                          // scope variable (a v-for alias, or a v-slot prop)
                          if (!(needPrefix && knownIds[node.name]) && !bailConstant) {
                              node.isConstant = true;
                          }
                          // also generate sub-expressions for other identifiers for better
                          // source map support. (except for property keys which are static)
                          ids.push(node);
                      }
                  }
              }
              else if (isFunction$1(node)) {
                  // walk function expressions and add its arguments to known identifiers
                  // so that we don't prefix them
                  node.params.forEach(p => walk$1(p, {
                      enter(child, parent) {
                          if (child.type === 'Identifier' &&
                              // do not record as scope variable if is a destructured key
                              !isStaticPropertyKey(child, parent) &&
                              // do not record if this is a default value
                              // assignment of a destructured variable
                              !(parent &&
                                  parent.type === 'AssignmentPattern' &&
                                  parent.right === child)) {
                              const { name } = child;
                              if (node.scopeIds && node.scopeIds.has(name)) {
                                  return;
                              }
                              if (name in knownIds) {
                                  knownIds[name]++;
                              }
                              else {
                                  knownIds[name] = 1;
                              }
                              (node.scopeIds || (node.scopeIds = new Set())).add(name);
                          }
                      }
                  }));
              }
          },
          leave(node) {
              if (node !== ast.body[0].expression && node.scopeIds) {
                  node.scopeIds.forEach((id) => {
                      knownIds[id]--;
                      if (knownIds[id] === 0) {
                          delete knownIds[id];
                      }
                  });
              }
          }
      });
      // We break up the compound expression into an array of strings and sub
      // expressions (for identifiers that have been prefixed). In codegen, if
      // an ExpressionNode has the `.children` property, it will be used instead of
      // `.content`.
      const children = [];
      ids.sort((a, b) => a.start - b.start);
      ids.forEach((id, i) => {
          // range is offset by -1 due to the wrapping parens when parsed
          const start = id.start - 1;
          const end = id.end - 1;
          const last = ids[i - 1];
          const leadingText = rawExp.slice(last ? last.end - 1 : 0, start);
          if (leadingText.length || id.prefix) {
              children.push(leadingText + (id.prefix || ``));
          }
          const source = rawExp.slice(start, end);
          children.push(createSimpleExpression(id.name, false, {
              source,
              start: advancePositionWithClone(node.loc.start, source, start),
              end: advancePositionWithClone(node.loc.start, source, end)
          }, id.isConstant /* isConstant */));
          if (i === ids.length - 1 && end < rawExp.length) {
              children.push(rawExp.slice(end));
          }
      });
      let ret;
      if (children.length) {
          ret = createCompoundExpression(children, node.loc);
      }
      else {
          ret = node;
          ret.isConstant = !bailConstant;
      }
      ret.identifiers = Object.keys(knownIds);
      return ret;
  }
  const isFunction$1 = (node) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
  };
  const isStaticProperty = (node) => node &&
      (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&
      !node.computed;
  const isPropertyShorthand = (node, parent) => {
      return (isStaticProperty(parent) &&
          parent.value === node &&
          parent.key.type === 'Identifier' &&
          parent.key.name === node.name &&
          parent.key.start === node.start);
  };
  const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
  function shouldPrefix(identifier, parent) {
      if (!(isFunction$1(parent) &&
          // not id of a FunctionDeclaration
          (parent.id === identifier ||
              // not a params of a function
              parent.params.includes(identifier))) &&
          // not a key of Property
          !isStaticPropertyKey(identifier, parent) &&
          // not a property of a MemberExpression
          !((parent.type === 'MemberExpression' ||
              parent.type === 'OptionalMemberExpression') &&
              parent.property === identifier &&
              !parent.computed) &&
          // not in an Array destructure pattern
          !(parent.type === 'ArrayPattern') &&
          // skip whitelisted globals
          !isGloballyWhitelisted(identifier.name) &&
          // special case for webpack compilation
          identifier.name !== `require` &&
          // is a special keyword but parsed as identifier
          identifier.name !== `arguments`) {
          return true;
      }
  }

  const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
      return processIf(node, dir, context, (ifNode, branch, isRoot) => {
          // #1587: We need to dynamically increment the key based on the current
          // node's sibling nodes, since chained v-if/else branches are
          // rendered at the same depth
          const siblings = context.parent.children;
          let i = siblings.indexOf(ifNode);
          let key = 0;
          while (i-- >= 0) {
              const sibling = siblings[i];
              if (sibling && sibling.type === 9 /* IF */) {
                  key += sibling.branches.length;
              }
          }
          // Exit callback. Complete the codegenNode when all children have been
          // transformed.
          return () => {
              if (isRoot) {
                  ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
              }
              else {
                  // attach this branch's codegen node to the v-if root.
                  let parentCondition = ifNode.codegenNode;
                  while (parentCondition.alternate.type ===
                      19 /* JS_CONDITIONAL_EXPRESSION */) {
                      parentCondition = parentCondition.alternate;
                  }
                  parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
              }
          };
      });
  });
  // target-agnostic transform used for both Client and SSR
  function processIf(node, dir, context, processCodegen) {
      if (dir.name !== 'else' &&
          (!dir.exp || !dir.exp.content.trim())) {
          const loc = dir.exp ? dir.exp.loc : node.loc;
          context.onError(createCompilerError(27 /* X_V_IF_NO_EXPRESSION */, dir.loc));
          dir.exp = createSimpleExpression(`true`, false, loc);
      }
      if ( context.prefixIdentifiers && dir.exp) {
          // dir.exp can only be simple expression because vIf transform is applied
          // before expression transform.
          dir.exp = processExpression(dir.exp, context);
      }
      if (dir.name === 'if') {
          const branch = createIfBranch(node, dir);
          const ifNode = {
              type: 9 /* IF */,
              loc: node.loc,
              branches: [branch]
          };
          context.replaceNode(ifNode);
          if (processCodegen) {
              return processCodegen(ifNode, branch, true);
          }
      }
      else {
          // locate the adjacent v-if
          const siblings = context.parent.children;
          const comments = [];
          let i = siblings.indexOf(node);
          while (i-- >= -1) {
              const sibling = siblings[i];
              if ( sibling && sibling.type === 3 /* COMMENT */) {
                  context.removeNode(sibling);
                  comments.unshift(sibling);
                  continue;
              }
              if (sibling && sibling.type === 9 /* IF */) {
                  // move the node to the if node's branches
                  context.removeNode();
                  const branch = createIfBranch(node, dir);
                  if ( comments.length) {
                      branch.children = [...comments, ...branch.children];
                  }
                  // check if user is forcing same key on different branches
                  {
                      const key = branch.userKey;
                      if (key) {
                          sibling.branches.forEach(({ userKey }) => {
                              if (isSameKey(userKey, key)) {
                                  context.onError(createCompilerError(28 /* X_V_IF_SAME_KEY */, branch.userKey.loc));
                              }
                          });
                      }
                  }
                  sibling.branches.push(branch);
                  const onExit = processCodegen && processCodegen(sibling, branch, false);
                  // since the branch was removed, it will not be traversed.
                  // make sure to traverse here.
                  traverseNode(branch, context);
                  // call on exit
                  if (onExit)
                      onExit();
                  // make sure to reset currentNode after traversal to indicate this
                  // node has been removed.
                  context.currentNode = null;
              }
              else {
                  context.onError(createCompilerError(29 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));
              }
              break;
          }
      }
  }
  function createIfBranch(node, dir) {
      return {
          type: 10 /* IF_BRANCH */,
          loc: node.loc,
          condition: dir.name === 'else' ? undefined : dir.exp,
          children: node.tagType === 3 /* TEMPLATE */ && !findDir(node, 'for')
              ? node.children
              : [node],
          userKey: findProp(node, `key`)
      };
  }
  function createCodegenNodeForBranch(branch, keyIndex, context) {
      if (branch.condition) {
          return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), 
          // make sure to pass in asBlock: true so that the comment node call
          // closes the current block.
          createCallExpression(context.helper(CREATE_COMMENT), [
               '"v-if"' ,
              'true'
          ]));
      }
      else {
          return createChildrenCodegenNode(branch, keyIndex, context);
      }
  }
  function createChildrenCodegenNode(branch, keyIndex, context) {
      const { helper } = context;
      const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, true));
      const { children } = branch;
      const firstChild = children[0];
      const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* ELEMENT */;
      if (needFragmentWrapper) {
          if (children.length === 1 && firstChild.type === 11 /* FOR */) {
              // optimize away nested fragments when child is a ForNode
              const vnodeCall = firstChild.codegenNode;
              injectProp(vnodeCall, keyProperty, context);
              return vnodeCall;
          }
          else {
              return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, `${64 /* STABLE_FRAGMENT */} /* ${PatchFlagNames[64 /* STABLE_FRAGMENT */]} */`, undefined, undefined, true, false, branch.loc);
          }
      }
      else {
          const vnodeCall = firstChild
              .codegenNode;
          // Change createVNode to createBlock.
          if (vnodeCall.type === 13 /* VNODE_CALL */) {
              vnodeCall.isBlock = true;
              helper(OPEN_BLOCK);
              helper(CREATE_BLOCK);
          }
          // inject branch key
          injectProp(vnodeCall, keyProperty, context);
          return vnodeCall;
      }
  }
  function isSameKey(a, b) {
      if (!a || a.type !== b.type) {
          return false;
      }
      if (a.type === 6 /* ATTRIBUTE */) {
          if (a.value.content !== b.value.content) {
              return false;
          }
      }
      else {
          // directive
          const exp = a.exp;
          const branchExp = b.exp;
          if (exp.type !== branchExp.type) {
              return false;
          }
          if (exp.type !== 4 /* SIMPLE_EXPRESSION */ ||
              (exp.isStatic !== branchExp.isStatic ||
                  exp.content !== branchExp.content)) {
              return false;
          }
      }
      return true;
  }

  const transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {
      const { helper } = context;
      return processFor(node, dir, context, forNode => {
          // create the loop render function expression now, and add the
          // iterator on exit after all children have been traversed
          const renderExp = createCallExpression(helper(RENDER_LIST), [
              forNode.source
          ]);
          const keyProp = findProp(node, `key`);
          const keyProperty = keyProp
              ? createObjectProperty(`key`, keyProp.type === 6 /* ATTRIBUTE */
                  ? createSimpleExpression(keyProp.value.content, true)
                  : keyProp.exp)
              : null;
          if ( context.prefixIdentifiers && keyProperty) {
              // #2085 process :key expression needs to be processed in order for it
              // to behave consistently for <template v-for> and <div v-for>.
              // In the case of `<template v-for>`, the node is discarded and never
              // traversed so its key expression won't be processed by the normal
              // transforms.
              keyProperty.value = processExpression(keyProperty.value, context);
          }
          const isStableFragment = forNode.source.type === 4 /* SIMPLE_EXPRESSION */ &&
              forNode.source.isConstant;
          const fragmentFlag = isStableFragment
              ? 64 /* STABLE_FRAGMENT */
              : keyProp
                  ? 128 /* KEYED_FRAGMENT */
                  : 256 /* UNKEYED_FRAGMENT */;
          forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, `${fragmentFlag} /* ${PatchFlagNames[fragmentFlag]} */`, undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, node.loc);
          return () => {
              // finish the codegen now that all children have been traversed
              let childBlock;
              const isTemplate = isTemplateNode(node);
              const { children } = forNode;
              // check <template v-for> key placement
              if ( isTemplate) {
                  node.children.some(c => {
                      if (c.type === 1 /* ELEMENT */) {
                          const key = findProp(c, 'key');
                          if (key) {
                              context.onError(createCompilerError(32 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */, key.loc));
                              return true;
                          }
                      }
                  });
              }
              const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* ELEMENT */;
              const slotOutlet = isSlotOutlet(node)
                  ? node
                  : isTemplate &&
                      node.children.length === 1 &&
                      isSlotOutlet(node.children[0])
                      ? node.children[0] // api-extractor somehow fails to infer this
                      : null;
              if (slotOutlet) {
                  // <slot v-for="..."> or <template v-for="..."><slot/></template>
                  childBlock = slotOutlet.codegenNode;
                  if (isTemplate && keyProperty) {
                      // <template v-for="..." :key="..."><slot/></template>
                      // we need to inject the key to the renderSlot() call.
                      // the props for renderSlot is passed as the 3rd argument.
                      injectProp(childBlock, keyProperty, context);
                  }
              }
              else if (needFragmentWrapper) {
                  // <template v-for="..."> with text or multi-elements
                  // should generate a fragment block for each loop
                  childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, `${64 /* STABLE_FRAGMENT */} /* ${PatchFlagNames[64 /* STABLE_FRAGMENT */]} */`, undefined, undefined, true);
              }
              else {
                  // Normal element v-for. Directly use the child's codegenNode
                  // but mark it as a block.
                  childBlock = children[0]
                      .codegenNode;
                  if (isTemplate && keyProperty) {
                      injectProp(childBlock, keyProperty, context);
                  }
                  childBlock.isBlock = !isStableFragment;
                  if (childBlock.isBlock) {
                      helper(OPEN_BLOCK);
                      helper(CREATE_BLOCK);
                  }
              }
              renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));
          };
      });
  });
  // target-agnostic transform used for both Client and SSR
  function processFor(node, dir, context, processCodegen) {
      if (!dir.exp) {
          context.onError(createCompilerError(30 /* X_V_FOR_NO_EXPRESSION */, dir.loc));
          return;
      }
      const parseResult = parseForExpression(
      // can only be simple expression because vFor transform is applied
      // before expression transform.
      dir.exp, context);
      if (!parseResult) {
          context.onError(createCompilerError(31 /* X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));
          return;
      }
      const { addIdentifiers, removeIdentifiers, scopes } = context;
      const { source, value, key, index } = parseResult;
      const forNode = {
          type: 11 /* FOR */,
          loc: dir.loc,
          source,
          valueAlias: value,
          keyAlias: key,
          objectIndexAlias: index,
          parseResult,
          children: isTemplateNode(node) ? node.children : [node]
      };
      context.replaceNode(forNode);
      // bookkeeping
      scopes.vFor++;
      if ( context.prefixIdentifiers) {
          // scope management
          // inject identifiers to context
          value && addIdentifiers(value);
          key && addIdentifiers(key);
          index && addIdentifiers(index);
      }
      const onExit = processCodegen && processCodegen(forNode);
      return () => {
          scopes.vFor--;
          if ( context.prefixIdentifiers) {
              value && removeIdentifiers(value);
              key && removeIdentifiers(key);
              index && removeIdentifiers(index);
          }
          if (onExit)
              onExit();
      };
  }
  const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
  // This regex doesn't cover the case if key or index aliases have destructuring,
  // but those do not make sense in the first place, so this works in practice.
  const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  const stripParensRE = /^\(|\)$/g;
  function parseForExpression(input, context) {
      const loc = input.loc;
      const exp = input.content;
      const inMatch = exp.match(forAliasRE);
      if (!inMatch)
          return;
      const [, LHS, RHS] = inMatch;
      const result = {
          source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
          value: undefined,
          key: undefined,
          index: undefined
      };
      if ( context.prefixIdentifiers) {
          result.source = processExpression(result.source, context);
      }
      let valueContent = LHS.trim()
          .replace(stripParensRE, '')
          .trim();
      const trimmedOffset = LHS.indexOf(valueContent);
      const iteratorMatch = valueContent.match(forIteratorRE);
      if (iteratorMatch) {
          valueContent = valueContent.replace(forIteratorRE, '').trim();
          const keyContent = iteratorMatch[1].trim();
          let keyOffset;
          if (keyContent) {
              keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
              result.key = createAliasExpression(loc, keyContent, keyOffset);
              if ( context.prefixIdentifiers) {
                  result.key = processExpression(result.key, context, true);
              }
          }
          if (iteratorMatch[2]) {
              const indexContent = iteratorMatch[2].trim();
              if (indexContent) {
                  result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key
                      ? keyOffset + keyContent.length
                      : trimmedOffset + valueContent.length));
                  if ( context.prefixIdentifiers) {
                      result.index = processExpression(result.index, context, true);
                  }
              }
          }
      }
      if (valueContent) {
          result.value = createAliasExpression(loc, valueContent, trimmedOffset);
          if ( context.prefixIdentifiers) {
              result.value = processExpression(result.value, context, true);
          }
      }
      return result;
  }
  function createAliasExpression(range, content, offset) {
      return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
  }
  function createForLoopParams({ value, key, index }) {
      const params = [];
      if (value) {
          params.push(value);
      }
      if (key) {
          if (!value) {
              params.push(createSimpleExpression(`_`, false));
          }
          params.push(key);
      }
      if (index) {
          if (!key) {
              if (!value) {
                  params.push(createSimpleExpression(`_`, false));
              }
              params.push(createSimpleExpression(`__`, false));
          }
          params.push(index);
      }
      return params;
  }

  const defaultFallback = createSimpleExpression(`undefined`, false);
  // A NodeTransform that:
  // 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
  //    by transformExpression. This is only applied in non-browser builds with
  //    { prefixIdentifiers: true }.
  // 2. Track v-slot depths so that we know a slot is inside another slot.
  //    Note the exit callback is executed before buildSlots() on the same node,
  //    so only nested slots see positive numbers.
  const trackSlotScopes = (node, context) => {
      if (node.type === 1 /* ELEMENT */ &&
          (node.tagType === 1 /* COMPONENT */ ||
              node.tagType === 3 /* TEMPLATE */)) {
          // We are only checking non-empty v-slot here
          // since we only care about slots that introduce scope variables.
          const vSlot = findDir(node, 'slot');
          if (vSlot) {
              const slotProps = vSlot.exp;
              if ( context.prefixIdentifiers) {
                  slotProps && context.addIdentifiers(slotProps);
              }
              context.scopes.vSlot++;
              return () => {
                  if ( context.prefixIdentifiers) {
                      slotProps && context.removeIdentifiers(slotProps);
                  }
                  context.scopes.vSlot--;
              };
          }
      }
  };
  // A NodeTransform that tracks scope identifiers for scoped slots with v-for.
  // This transform is only applied in non-browser builds with { prefixIdentifiers: true }
  const trackVForSlotScopes = (node, context) => {
      let vFor;
      if (isTemplateNode(node) &&
          node.props.some(isVSlot) &&
          (vFor = findDir(node, 'for'))) {
          const result = (vFor.parseResult = parseForExpression(vFor.exp, context));
          if (result) {
              const { value, key, index } = result;
              const { addIdentifiers, removeIdentifiers } = context;
              value && addIdentifiers(value);
              key && addIdentifiers(key);
              index && addIdentifiers(index);
              return () => {
                  value && removeIdentifiers(value);
                  key && removeIdentifiers(key);
                  index && removeIdentifiers(index);
              };
          }
      }
  };
  const buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);
  // Instead of being a DirectiveTransform, v-slot processing is called during
  // transformElement to build the slots object for a component.
  function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
      context.helper(WITH_CTX);
      const { children, loc } = node;
      const slotsProperties = [];
      const dynamicSlots = [];
      const buildDefaultSlotProperty = (props, children) => createObjectProperty(`default`, buildSlotFn(props, children, loc));
      // If the slot is inside a v-for or another v-slot, force it to be dynamic
      // since it likely uses a scope variable.
      let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
      // with `prefixIdentifiers: true`, this can be further optimized to make
      // it dynamic only when the slot actually uses the scope variables.
      if ( !context.ssr && context.prefixIdentifiers) {
          hasDynamicSlots = hasScopeRef(node, context.identifiers);
      }
      // 1. Check for slot with slotProps on component itself.
      //    <Comp v-slot="{ prop }"/>
      const onComponentSlot = findDir(node, 'slot', true);
      if (onComponentSlot) {
          const { arg, exp } = onComponentSlot;
          if (arg && !isStaticExp(arg)) {
              hasDynamicSlots = true;
          }
          slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));
      }
      // 2. Iterate through children and check for template slots
      //    <template v-slot:foo="{ prop }">
      let hasTemplateSlots = false;
      let hasNamedDefaultSlot = false;
      const implicitDefaultChildren = [];
      const seenSlotNames = new Set();
      for (let i = 0; i < children.length; i++) {
          const slotElement = children[i];
          let slotDir;
          if (!isTemplateNode(slotElement) ||
              !(slotDir = findDir(slotElement, 'slot', true))) {
              // not a <template v-slot>, skip.
              if (slotElement.type !== 3 /* COMMENT */) {
                  implicitDefaultChildren.push(slotElement);
              }
              continue;
          }
          if (onComponentSlot) {
              // already has on-component slot - this is incorrect usage.
              context.onError(createCompilerError(36 /* X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));
              break;
          }
          hasTemplateSlots = true;
          const { children: slotChildren, loc: slotLoc } = slotElement;
          const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
          // check if name is dynamic.
          let staticSlotName;
          if (isStaticExp(slotName)) {
              staticSlotName = slotName ? slotName.content : `default`;
          }
          else {
              hasDynamicSlots = true;
          }
          const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
          // check if this slot is conditional (v-if/v-for)
          let vIf;
          let vElse;
          let vFor;
          if ((vIf = findDir(slotElement, 'if'))) {
              hasDynamicSlots = true;
              dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
          }
          else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {
              // find adjacent v-if
              let j = i;
              let prev;
              while (j--) {
                  prev = children[j];
                  if (prev.type !== 3 /* COMMENT */) {
                      break;
                  }
              }
              if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
                  // remove node
                  children.splice(i, 1);
                  i--;
                  // attach this slot to previous conditional
                  let conditional = dynamicSlots[dynamicSlots.length - 1];
                  while (conditional.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
                      conditional = conditional.alternate;
                  }
                  conditional.alternate = vElse.exp
                      ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback)
                      : buildDynamicSlot(slotName, slotFunction);
              }
              else {
                  context.onError(createCompilerError(29 /* X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));
              }
          }
          else if ((vFor = findDir(slotElement, 'for'))) {
              hasDynamicSlots = true;
              const parseResult = vFor.parseResult ||
                  parseForExpression(vFor.exp, context);
              if (parseResult) {
                  // Render the dynamic slots as an array and add it to the createSlot()
                  // args. The runtime knows how to handle it appropriately.
                  dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
                      parseResult.source,
                      createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)
                  ]));
              }
              else {
                  context.onError(createCompilerError(31 /* X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));
              }
          }
          else {
              // check duplicate static names
              if (staticSlotName) {
                  if (seenSlotNames.has(staticSlotName)) {
                      context.onError(createCompilerError(37 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));
                      continue;
                  }
                  seenSlotNames.add(staticSlotName);
                  if (staticSlotName === 'default') {
                      hasNamedDefaultSlot = true;
                  }
              }
              slotsProperties.push(createObjectProperty(slotName, slotFunction));
          }
      }
      if (!onComponentSlot) {
          if (!hasTemplateSlots) {
              // implicit default slot (on component)
              slotsProperties.push(buildDefaultSlotProperty(undefined, children));
          }
          else if (implicitDefaultChildren.length) {
              // implicit default slot (mixed with named slots)
              if (hasNamedDefaultSlot) {
                  context.onError(createCompilerError(38 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));
              }
              else {
                  slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));
              }
          }
      }
      const slotFlag = hasDynamicSlots
          ? 2 /* DYNAMIC */
          : hasForwardedSlots(node.children)
              ? 3 /* FORWARDED */
              : 1 /* STABLE */;
      let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, 
      // 2 = compiled but dynamic = can skip normalization, but must run diff
      // 1 = compiled and static = can skip normalization AND diff as optimized
      createSimpleExpression('' + slotFlag, false))), loc);
      if (dynamicSlots.length) {
          slots = createCallExpression(context.helper(CREATE_SLOTS), [
              slots,
              createArrayExpression(dynamicSlots)
          ]);
      }
      return {
          slots,
          hasDynamicSlots
      };
  }
  function buildDynamicSlot(name, fn) {
      return createObjectExpression([
          createObjectProperty(`name`, name),
          createObjectProperty(`fn`, fn)
      ]);
  }
  function hasForwardedSlots(children) {
      for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.type === 1 /* ELEMENT */) {
              if (child.tagType === 2 /* SLOT */ ||
                  (child.tagType === 0 /* ELEMENT */ &&
                      hasForwardedSlots(child.children))) {
                  return true;
              }
          }
      }
      return false;
  }

  // some directive transforms (e.g. v-model) may return a symbol for runtime
  // import, which should be used instead of a resolveDirective call.
  const directiveImportMap = new WeakMap();
  // generate a JavaScript AST for this element's codegen
  const transformElement = (node, context) => {
      if (!(node.type === 1 /* ELEMENT */ &&
          (node.tagType === 0 /* ELEMENT */ ||
              node.tagType === 1 /* COMPONENT */))) {
          return;
      }
      // perform the work on exit, after all child expressions have been
      // processed and merged.
      return function postTransformElement() {
          const { tag, props } = node;
          const isComponent = node.tagType === 1 /* COMPONENT */;
          // The goal of the transform is to create a codegenNode implementing the
          // VNodeCall interface.
          const vnodeTag = isComponent
              ? resolveComponentType(node, context)
              : `"${tag}"`;
          const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
          let vnodeProps;
          let vnodeChildren;
          let vnodePatchFlag;
          let patchFlag = 0;
          let vnodeDynamicProps;
          let dynamicPropNames;
          let vnodeDirectives;
          let shouldUseBlock = 
          // dynamic component may resolve to plain elements
          isDynamicComponent ||
              vnodeTag === TELEPORT ||
              vnodeTag === SUSPENSE ||
              (!isComponent &&
                  // <svg> and <foreignObject> must be forced into blocks so that block
                  // updates inside get proper isSVG flag at runtime. (#639, #643)
                  // This is technically web-specific, but splitting the logic out of core
                  // leads to too much unnecessary complexity.
                  (tag === 'svg' ||
                      tag === 'foreignObject' ||
                      // #938: elements with dynamic keys should be forced into blocks
                      findProp(node, 'key', true)));
          // props
          if (props.length > 0) {
              const propsBuildResult = buildProps(node, context);
              vnodeProps = propsBuildResult.props;
              patchFlag = propsBuildResult.patchFlag;
              dynamicPropNames = propsBuildResult.dynamicPropNames;
              const directives = propsBuildResult.directives;
              vnodeDirectives =
                  directives && directives.length
                      ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))
                      : undefined;
          }
          // children
          if (node.children.length > 0) {
              if (vnodeTag === KEEP_ALIVE) {
                  // Although a built-in component, we compile KeepAlive with raw children
                  // instead of slot functions so that it can be used inside Transition
                  // or other Transition-wrapping HOCs.
                  // To ensure correct updates with block optimizations, we need to:
                  // 1. Force keep-alive into a block. This avoids its children being
                  //    collected by a parent block.
                  shouldUseBlock = true;
                  // 2. Force keep-alive to always be updated, since it uses raw children.
                  patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                  if ( node.children.length > 1) {
                      context.onError(createCompilerError(44 /* X_KEEP_ALIVE_INVALID_CHILDREN */, {
                          start: node.children[0].loc.start,
                          end: node.children[node.children.length - 1].loc.end,
                          source: ''
                      }));
                  }
              }
              const shouldBuildAsSlots = isComponent &&
                  // Teleport is not a real component and has dedicated runtime handling
                  vnodeTag !== TELEPORT &&
                  // explained above.
                  vnodeTag !== KEEP_ALIVE;
              if (shouldBuildAsSlots) {
                  const { slots, hasDynamicSlots } = buildSlots(node, context);
                  vnodeChildren = slots;
                  if (hasDynamicSlots) {
                      patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                  }
              }
              else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
                  const child = node.children[0];
                  const type = child.type;
                  // check for dynamic text children
                  const hasDynamicTextChild = type === 5 /* INTERPOLATION */ ||
                      type === 8 /* COMPOUND_EXPRESSION */;
                  if (hasDynamicTextChild && !getStaticType(child)) {
                      patchFlag |= 1 /* TEXT */;
                  }
                  // pass directly if the only child is a text node
                  // (plain / interpolation / expression)
                  if (hasDynamicTextChild || type === 2 /* TEXT */) {
                      vnodeChildren = child;
                  }
                  else {
                      vnodeChildren = node.children;
                  }
              }
              else {
                  vnodeChildren = node.children;
              }
          }
          // patchFlag & dynamicPropNames
          if (patchFlag !== 0) {
              {
                  if (patchFlag < 0) {
                      // special flags (negative and mutually exclusive)
                      vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
                  }
                  else {
                      // bitwise flags
                      const flagNames = Object.keys(PatchFlagNames)
                          .map(Number)
                          .filter(n => n > 0 && patchFlag & n)
                          .map(n => PatchFlagNames[n])
                          .join(`, `);
                      vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
                  }
              }
              if (dynamicPropNames && dynamicPropNames.length) {
                  vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
              }
          }
          node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, node.loc);
      };
  };
  function resolveComponentType(node, context, ssr = false) {
      const { tag } = node;
      // 1. dynamic component
      const isProp = node.tag === 'component' ? findProp(node, 'is') : findDir(node, 'is');
      if (isProp) {
          const exp = isProp.type === 6 /* ATTRIBUTE */
              ? isProp.value && createSimpleExpression(isProp.value.content, true)
              : isProp.exp;
          if (exp) {
              return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
                  exp
              ]);
          }
      }
      // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)
      const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
      if (builtIn) {
          // built-ins are simply fallthroughs / have special handling during ssr
          // no we don't need to import their runtime equivalents
          if (!ssr)
              context.helper(builtIn);
          return builtIn;
      }
      // 3. user component (from setup bindings)
      if (context.bindingMetadata[tag] === 'setup') {
          return `$setup[${JSON.stringify(tag)}]`;
      }
      // 4. user component (resolve)
      context.helper(RESOLVE_COMPONENT);
      context.components.add(tag);
      return toValidAssetId(tag, `component`);
  }
  function buildProps(node, context, props = node.props, ssr = false) {
      const { tag, loc: elementLoc } = node;
      const isComponent = node.tagType === 1 /* COMPONENT */;
      let properties = [];
      const mergeArgs = [];
      const runtimeDirectives = [];
      // patchFlag analysis
      let patchFlag = 0;
      let hasRef = false;
      let hasClassBinding = false;
      let hasStyleBinding = false;
      let hasHydrationEventBinding = false;
      let hasDynamicKeys = false;
      let hasVnodeHook = false;
      const dynamicPropNames = [];
      const analyzePatchFlag = ({ key, value }) => {
          if (isStaticExp(key)) {
              const name = key.content;
              const isEventHandler = isOn(name);
              if (!isComponent &&
                  isEventHandler &&
                  // omit the flag for click handlers because hydration gives click
                  // dedicated fast path.
                  name.toLowerCase() !== 'onclick' &&
                  // omit v-model handlers
                  name !== 'onUpdate:modelValue' &&
                  // omit onVnodeXXX hooks
                  !isReservedProp(name)) {
                  hasHydrationEventBinding = true;
              }
              if (isEventHandler && isReservedProp(name)) {
                  hasVnodeHook = true;
              }
              if (value.type === 20 /* JS_CACHE_EXPRESSION */ ||
                  ((value.type === 4 /* SIMPLE_EXPRESSION */ ||
                      value.type === 8 /* COMPOUND_EXPRESSION */) &&
                      getStaticType(value) > 0)) {
                  // skip if the prop is a cached handler or has constant value
                  return;
              }
              if (name === 'ref') {
                  hasRef = true;
              }
              else if (name === 'class' && !isComponent) {
                  hasClassBinding = true;
              }
              else if (name === 'style' && !isComponent) {
                  hasStyleBinding = true;
              }
              else if (name !== 'key' && !dynamicPropNames.includes(name)) {
                  dynamicPropNames.push(name);
              }
          }
          else {
              hasDynamicKeys = true;
          }
      };
      for (let i = 0; i < props.length; i++) {
          // static attribute
          const prop = props[i];
          if (prop.type === 6 /* ATTRIBUTE */) {
              const { loc, name, value } = prop;
              if (name === 'ref') {
                  hasRef = true;
              }
              // skip :is on <component>
              if (name === 'is' && tag === 'component') {
                  continue;
              }
              properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', true, value ? value.loc : loc)));
          }
          else {
              // directives
              const { name, arg, exp, loc } = prop;
              const isBind = name === 'bind';
              const isOn = name === 'on';
              // skip v-slot - it is handled by its dedicated transform.
              if (name === 'slot') {
                  if (!isComponent) {
                      context.onError(createCompilerError(39 /* X_V_SLOT_MISPLACED */, loc));
                  }
                  continue;
              }
              // skip v-once - it is handled by its dedicated transform.
              if (name === 'once') {
                  continue;
              }
              // skip v-is and :is on <component>
              if (name === 'is' ||
                  (isBind && tag === 'component' && isBindKey(arg, 'is'))) {
                  continue;
              }
              // skip v-on in SSR compilation
              if (isOn && ssr) {
                  continue;
              }
              // special case for v-bind and v-on with no argument
              if (!arg && (isBind || isOn)) {
                  hasDynamicKeys = true;
                  if (exp) {
                      if (properties.length) {
                          mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
                          properties = [];
                      }
                      if (isBind) {
                          mergeArgs.push(exp);
                      }
                      else {
                          // v-on="obj" -> toHandlers(obj)
                          mergeArgs.push({
                              type: 14 /* JS_CALL_EXPRESSION */,
                              loc,
                              callee: context.helper(TO_HANDLERS),
                              arguments: [exp]
                          });
                      }
                  }
                  else {
                      context.onError(createCompilerError(isBind
                          ? 33 /* X_V_BIND_NO_EXPRESSION */
                          : 34 /* X_V_ON_NO_EXPRESSION */, loc));
                  }
                  continue;
              }
              const directiveTransform = context.directiveTransforms[name];
              if (directiveTransform) {
                  // has built-in directive transform.
                  const { props, needRuntime } = directiveTransform(prop, node, context);
                  !ssr && props.forEach(analyzePatchFlag);
                  properties.push(...props);
                  if (needRuntime) {
                      runtimeDirectives.push(prop);
                      if (isSymbol(needRuntime)) {
                          directiveImportMap.set(prop, needRuntime);
                      }
                  }
              }
              else {
                  // no built-in transform, this is a user custom directive.
                  runtimeDirectives.push(prop);
              }
          }
      }
      let propsExpression = undefined;
      // has v-bind="object" or v-on="object", wrap with mergeProps
      if (mergeArgs.length) {
          if (properties.length) {
              mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
          }
          if (mergeArgs.length > 1) {
              propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
          }
          else {
              // single v-bind with nothing else - no need for a mergeProps call
              propsExpression = mergeArgs[0];
          }
      }
      else if (properties.length) {
          propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
      }
      // patchFlag analysis
      if (hasDynamicKeys) {
          patchFlag |= 16 /* FULL_PROPS */;
      }
      else {
          if (hasClassBinding) {
              patchFlag |= 2 /* CLASS */;
          }
          if (hasStyleBinding) {
              patchFlag |= 4 /* STYLE */;
          }
          if (dynamicPropNames.length) {
              patchFlag |= 8 /* PROPS */;
          }
          if (hasHydrationEventBinding) {
              patchFlag |= 32 /* HYDRATE_EVENTS */;
          }
      }
      if ((patchFlag === 0 || patchFlag === 32 /* HYDRATE_EVENTS */) &&
          (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
          patchFlag |= 512 /* NEED_PATCH */;
      }
      return {
          props: propsExpression,
          directives: runtimeDirectives,
          patchFlag,
          dynamicPropNames
      };
  }
  // Dedupe props in an object literal.
  // Literal duplicated attributes would have been warned during the parse phase,
  // however, it's possible to encounter duplicated `onXXX` handlers with different
  // modifiers. We also need to merge static and dynamic class / style attributes.
  // - onXXX handlers / style: merge into array
  // - class: merge into single expression with concatenation
  function dedupeProperties(properties) {
      const knownProps = new Map();
      const deduped = [];
      for (let i = 0; i < properties.length; i++) {
          const prop = properties[i];
          // dynamic keys are always allowed
          if (prop.key.type === 8 /* COMPOUND_EXPRESSION */ || !prop.key.isStatic) {
              deduped.push(prop);
              continue;
          }
          const name = prop.key.content;
          const existing = knownProps.get(name);
          if (existing) {
              if (name === 'style' || name === 'class' || name.startsWith('on')) {
                  mergeAsArray(existing, prop);
              }
              // unexpected duplicate, should have emitted error during parse
          }
          else {
              knownProps.set(name, prop);
              deduped.push(prop);
          }
      }
      return deduped;
  }
  function mergeAsArray(existing, incoming) {
      if (existing.value.type === 17 /* JS_ARRAY_EXPRESSION */) {
          existing.value.elements.push(incoming.value);
      }
      else {
          existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
      }
  }
  function buildDirectiveArgs(dir, context) {
      const dirArgs = [];
      const runtime = directiveImportMap.get(dir);
      if (runtime) {
          dirArgs.push(context.helperString(runtime));
      }
      else {
          // inject statement for resolving directive
          context.helper(RESOLVE_DIRECTIVE);
          context.directives.add(dir.name);
          dirArgs.push(toValidAssetId(dir.name, `directive`));
      }
      const { loc } = dir;
      if (dir.exp)
          dirArgs.push(dir.exp);
      if (dir.arg) {
          if (!dir.exp) {
              dirArgs.push(`void 0`);
          }
          dirArgs.push(dir.arg);
      }
      if (Object.keys(dir.modifiers).length) {
          if (!dir.arg) {
              if (!dir.exp) {
                  dirArgs.push(`void 0`);
              }
              dirArgs.push(`void 0`);
          }
          const trueExpression = createSimpleExpression(`true`, false, loc);
          dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));
      }
      return createArrayExpression(dirArgs, dir.loc);
  }
  function stringifyDynamicPropNames(props) {
      let propsNamesString = `[`;
      for (let i = 0, l = props.length; i < l; i++) {
          propsNamesString += JSON.stringify(props[i]);
          if (i < l - 1)
              propsNamesString += ', ';
      }
      return propsNamesString + `]`;
  }

  const transformSlotOutlet = (node, context) => {
      if (isSlotOutlet(node)) {
          const { children, loc } = node;
          const { slotName, slotProps } = processSlotOutlet(node, context);
          const slotArgs = [
              context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
              slotName
          ];
          if (slotProps) {
              slotArgs.push(slotProps);
          }
          if (children.length) {
              if (!slotProps) {
                  slotArgs.push(`{}`);
              }
              slotArgs.push(createFunctionExpression([], children, false, false, loc));
          }
          node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
      }
  };
  function processSlotOutlet(node, context) {
      let slotName = `"default"`;
      let slotProps = undefined;
      // check for <slot name="xxx" OR :name="xxx" />
      const name = findProp(node, 'name');
      if (name) {
          if (name.type === 6 /* ATTRIBUTE */ && name.value) {
              // static name
              slotName = JSON.stringify(name.value.content);
          }
          else if (name.type === 7 /* DIRECTIVE */ && name.exp) {
              // dynamic name
              slotName = name.exp;
          }
      }
      const propsWithoutName = name
          ? node.props.filter(p => p !== name)
          : node.props;
      if (propsWithoutName.length > 0) {
          const { props, directives } = buildProps(node, context, propsWithoutName);
          slotProps = props;
          if (directives.length) {
              context.onError(createCompilerError(35 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));
          }
      }
      return {
          slotName,
          slotProps
      };
  }

  const fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^\s*function(?:\s+[\w$]+)?\s*\(/;
  const transformOn = (dir, node, context, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
          context.onError(createCompilerError(34 /* X_V_ON_NO_EXPRESSION */, loc));
      }
      let eventName;
      if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
          if (arg.isStatic) {
              const rawName = arg.content;
              // for @vnode-xxx event listeners, auto convert it to camelCase
              const normalizedName = rawName.startsWith(`vnode`)
                  ? capitalize(camelize(rawName))
                  : capitalize(rawName);
              eventName = createSimpleExpression(`on${normalizedName}`, true, arg.loc);
          }
          else {
              eventName = createCompoundExpression([
                  `"on" + ${context.helperString(CAPITALIZE)}(`,
                  arg,
                  `)`
              ]);
          }
      }
      else {
          // already a compound expression.
          eventName = arg;
          eventName.children.unshift(`"on" + ${context.helperString(CAPITALIZE)}(`);
          eventName.children.push(`)`);
      }
      // handler processing
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
          exp = undefined;
      }
      let isCacheable = context.cacheHandlers && !exp;
      if (exp) {
          const isMemberExp = isMemberExpression(exp.content);
          const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
          const hasMultipleStatements = exp.content.includes(`;`);
          // process the expression since it's been skipped
          if ( context.prefixIdentifiers) {
              isInlineStatement && context.addIdentifiers(`$event`);
              exp = processExpression(exp, context, false, hasMultipleStatements);
              isInlineStatement && context.removeIdentifiers(`$event`);
              // with scope analysis, the function is hoistable if it has no reference
              // to scope variables.
              isCacheable =
                  context.cacheHandlers &&
                      // #1541 bail if this is a member exp handler passed to a component -
                      // we need to use the original function to preserve arity,
                      // e.g. <transition> relies on checking cb.length to determine
                      // transition end handling. Inline function is ok since its arity
                      // is preserved even when cached.
                      !(isMemberExp && node.tagType === 1 /* COMPONENT */) &&
                      // bail if the function references closure variables (v-for, v-slot)
                      // it must be passed fresh to avoid stale values.
                      !hasScopeRef(exp, context.identifiers);
              // If the expression is optimizable and is a member expression pointing
              // to a function, turn it into invocation (and wrap in an arrow function
              // below) so that it always accesses the latest value when called - thus
              // avoiding the need to be patched.
              if (isCacheable && isMemberExp) {
                  if (exp.type === 4 /* SIMPLE_EXPRESSION */) {
                      exp.content += `(...args)`;
                  }
                  else {
                      exp.children.push(`(...args)`);
                  }
              }
          }
          if (isInlineStatement || (isCacheable && isMemberExp)) {
              // wrap inline statement in a function expression
              exp = createCompoundExpression([
                  `${isInlineStatement ? `$event` : `(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
                  exp,
                  hasMultipleStatements ? `}` : `)`
              ]);
          }
      }
      let ret = {
          props: [
              createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
          ]
      };
      // apply extended compiler augmentor
      if (augmentor) {
          ret = augmentor(ret);
      }
      if (isCacheable) {
          // cache handlers so that it's always the same handler being passed down.
          // this avoids unnecessary re-renders when users use inline handlers on
          // components.
          ret.props[0].value = context.cache(ret.props[0].value);
      }
      return ret;
  };

  // v-bind without arg is handled directly in ./transformElements.ts due to it affecting
  // codegen for the entire props object. This transform here is only for v-bind
  // *with* args.
  const transformBind = (dir, node, context) => {
      const { exp, modifiers, loc } = dir;
      const arg = dir.arg;
      // .prop is no longer necessary due to new patch behavior
      // .sync is replaced by v-model:arg
      if (modifiers.includes('camel')) {
          if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
              if (arg.isStatic) {
                  arg.content = camelize(arg.content);
              }
              else {
                  arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
              }
          }
          else {
              arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
              arg.children.push(`)`);
          }
      }
      if (!exp ||
          (exp.type === 4 /* SIMPLE_EXPRESSION */ && !exp.content.trim())) {
          context.onError(createCompilerError(33 /* X_V_BIND_NO_EXPRESSION */, loc));
          return {
              props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]
          };
      }
      return {
          props: [createObjectProperty(arg, exp)]
      };
  };

  // Merge adjacent text nodes and expressions into a single expression
  // e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.
  const transformText = (node, context) => {
      if (node.type === 0 /* ROOT */ ||
          node.type === 1 /* ELEMENT */ ||
          node.type === 11 /* FOR */ ||
          node.type === 10 /* IF_BRANCH */) {
          // perform the transform on node exit so that all expressions have already
          // been processed.
          return () => {
              const children = node.children;
              let currentContainer = undefined;
              let hasText = false;
              for (let i = 0; i < children.length; i++) {
                  const child = children[i];
                  if (isText(child)) {
                      hasText = true;
                      for (let j = i + 1; j < children.length; j++) {
                          const next = children[j];
                          if (isText(next)) {
                              if (!currentContainer) {
                                  currentContainer = children[i] = {
                                      type: 8 /* COMPOUND_EXPRESSION */,
                                      loc: child.loc,
                                      children: [child]
                                  };
                              }
                              // merge adjacent text node into current
                              currentContainer.children.push(` + `, next);
                              children.splice(j, 1);
                              j--;
                          }
                          else {
                              currentContainer = undefined;
                              break;
                          }
                      }
                  }
              }
              if (!hasText ||
                  // if this is a plain element with a single text child, leave it
                  // as-is since the runtime has dedicated fast path for this by directly
                  // setting textContent of the element.
                  // for component root it's always normalized anyway.
                  (children.length === 1 &&
                      (node.type === 0 /* ROOT */ ||
                          (node.type === 1 /* ELEMENT */ &&
                              node.tagType === 0 /* ELEMENT */)))) {
                  return;
              }
              // pre-convert text nodes into createTextVNode(text) calls to avoid
              // runtime normalization.
              for (let i = 0; i < children.length; i++) {
                  const child = children[i];
                  if (isText(child) || child.type === 8 /* COMPOUND_EXPRESSION */) {
                      const callArgs = [];
                      // createTextVNode defaults to single whitespace, so if it is a
                      // single space the code could be an empty call to save bytes.
                      if (child.type !== 2 /* TEXT */ || child.content !== ' ') {
                          callArgs.push(child);
                      }
                      // mark dynamic text with flag so it gets patched inside a block
                      if (!context.ssr && child.type !== 2 /* TEXT */) {
                          callArgs.push(`${1 /* TEXT */} /* ${PatchFlagNames[1 /* TEXT */]} */`);
                      }
                      children[i] = {
                          type: 12 /* TEXT_CALL */,
                          content: child,
                          loc: child.loc,
                          codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
                      };
                  }
              }
          };
      }
  };

  const seen = new WeakSet();
  const transformOnce = (node, context) => {
      if (node.type === 1 /* ELEMENT */ && findDir(node, 'once', true)) {
          if (seen.has(node)) {
              return;
          }
          seen.add(node);
          context.helper(SET_BLOCK_TRACKING);
          return () => {
              const cur = context.currentNode;
              if (cur.codegenNode) {
                  cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);
              }
          };
      }
  };

  const transformModel = (dir, node, context) => {
      const { exp, arg } = dir;
      if (!exp) {
          context.onError(createCompilerError(40 /* X_V_MODEL_NO_EXPRESSION */, dir.loc));
          return createTransformProps();
      }
      const expString = exp.type === 4 /* SIMPLE_EXPRESSION */ ? exp.content : exp.loc.source;
      if (!isMemberExpression(expString)) {
          context.onError(createCompilerError(41 /* X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));
          return createTransformProps();
      }
      if (
          context.prefixIdentifiers &&
          isSimpleIdentifier(expString) &&
          context.identifiers[expString]) {
          context.onError(createCompilerError(42 /* X_V_MODEL_ON_SCOPE_VARIABLE */, exp.loc));
          return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression('modelValue', true);
      const eventName = arg
          ? isStaticExp(arg)
              ? `onUpdate:${arg.content}`
              : createCompoundExpression(['"onUpdate:" + ', arg])
          : `onUpdate:modelValue`;
      const props = [
          // modelValue: foo
          createObjectProperty(propName, dir.exp),
          // "onUpdate:modelValue": $event => (foo = $event)
          createObjectProperty(eventName, createCompoundExpression([`$event => (`, exp, ` = $event)`]))
      ];
      // cache v-model handler if applicable (when it doesn't refer any scope vars)
      if (
          context.prefixIdentifiers &&
          context.cacheHandlers &&
          !hasScopeRef(exp, context.identifiers)) {
          props[1].value = context.cache(props[1].value);
      }
      // modelModifiers: { foo: true, "bar-baz": true }
      if (dir.modifiers.length && node.tagType === 1 /* COMPONENT */) {
          const modifiers = dir.modifiers
              .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)
              .join(`, `);
          const modifiersKey = arg
              ? isStaticExp(arg)
                  ? `${arg.content}Modifiers`
                  : createCompoundExpression([arg, ' + "Modifiers"'])
              : `modelModifiers`;
          props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, true)));
      }
      return createTransformProps(props);
  };
  function createTransformProps(props = []) {
      return { props };
  }

  function getBaseTransformPreset(prefixIdentifiers) {
      return [
          [
              transformOnce,
              transformIf,
              transformFor,
              ...( prefixIdentifiers
                  ? [
                      // order is important
                      trackVForSlotScopes,
                      transformExpression
                  ]
                  :  []),
              transformSlotOutlet,
              transformElement,
              trackSlotScopes,
              transformText
          ],
          {
              on: transformOn,
              bind: transformBind,
              model: transformModel
          }
      ];
  }
  // we name it `baseCompile` so that higher order compilers like
  // @vue/compiler-dom can export `compile` while re-exporting everything else.
  function baseCompile(template, options = {}) {
      const onError = options.onError || defaultOnError;
      const isModuleMode = options.mode === 'module';
      const prefixIdentifiers =  (options.prefixIdentifiers === true || isModuleMode);
      if (!prefixIdentifiers && options.cacheHandlers) {
          onError(createCompilerError(47 /* X_CACHE_HANDLER_NOT_SUPPORTED */));
      }
      if (options.scopeId && !isModuleMode) {
          onError(createCompilerError(48 /* X_SCOPE_ID_NOT_SUPPORTED */));
      }
      const ast = isString(template) ? baseParse(template, options) : template;
      const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(prefixIdentifiers);
      transform(ast, extend({}, options, {
          prefixIdentifiers,
          nodeTransforms: [
              ...nodeTransforms,
              ...(options.nodeTransforms || []) // user transforms
          ],
          directiveTransforms: extend({}, directiveTransforms, options.directiveTransforms || {} // user transforms
          )
      }));
      return generate(ast, extend({}, options, {
          prefixIdentifiers
      }));
  }

  const noopDirectiveTransform = () => ({ props: [] });

  const V_MODEL_RADIO = Symbol( `vModelRadio` );
  const V_MODEL_CHECKBOX = Symbol( `vModelCheckbox` );
  const V_MODEL_TEXT = Symbol( `vModelText` );
  const V_MODEL_SELECT = Symbol( `vModelSelect` );
  const V_MODEL_DYNAMIC = Symbol( `vModelDynamic` );
  const V_ON_WITH_MODIFIERS = Symbol( `vOnModifiersGuard` );
  const V_ON_WITH_KEYS = Symbol( `vOnKeysGuard` );
  const V_SHOW = Symbol( `vShow` );
  const TRANSITION = Symbol( `Transition` );
  const TRANSITION_GROUP = Symbol( `TransitionGroup` );
  registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`
  });

  var namedCharacterReferences = {
  	GT: ">",
  	gt: ">",
  	LT: "<",
  	lt: "<",
  	"ac;": "∾",
  	"af;": "⁡",
  	AMP: "&",
  	amp: "&",
  	"ap;": "≈",
  	"DD;": "ⅅ",
  	"dd;": "ⅆ",
  	deg: "°",
  	"ee;": "ⅇ",
  	"eg;": "⪚",
  	"el;": "⪙",
  	ETH: "Ð",
  	eth: "ð",
  	"gE;": "≧",
  	"ge;": "≥",
  	"Gg;": "⋙",
  	"gg;": "≫",
  	"gl;": "≷",
  	"GT;": ">",
  	"Gt;": "≫",
  	"gt;": ">",
  	"ic;": "⁣",
  	"ii;": "ⅈ",
  	"Im;": "ℑ",
  	"in;": "∈",
  	"it;": "⁢",
  	"lE;": "≦",
  	"le;": "≤",
  	"lg;": "≶",
  	"Ll;": "⋘",
  	"ll;": "≪",
  	"LT;": "<",
  	"Lt;": "≪",
  	"lt;": "<",
  	"mp;": "∓",
  	"Mu;": "Μ",
  	"mu;": "μ",
  	"ne;": "≠",
  	"ni;": "∋",
  	not: "¬",
  	"Nu;": "Ν",
  	"nu;": "ν",
  	"Or;": "⩔",
  	"or;": "∨",
  	"oS;": "Ⓢ",
  	"Pi;": "Π",
  	"pi;": "π",
  	"pm;": "±",
  	"Pr;": "⪻",
  	"pr;": "≺",
  	"Re;": "ℜ",
  	REG: "®",
  	reg: "®",
  	"rx;": "℞",
  	"Sc;": "⪼",
  	"sc;": "≻",
  	shy: "­",
  	uml: "¨",
  	"wp;": "℘",
  	"wr;": "≀",
  	"Xi;": "Ξ",
  	"xi;": "ξ",
  	yen: "¥",
  	"acd;": "∿",
  	"acE;": "∾̳",
  	"Acy;": "А",
  	"acy;": "а",
  	"Afr;": "𝔄",
  	"afr;": "𝔞",
  	"AMP;": "&",
  	"amp;": "&",
  	"And;": "⩓",
  	"and;": "∧",
  	"ang;": "∠",
  	"apE;": "⩰",
  	"ape;": "≊",
  	"ast;": "*",
  	Auml: "Ä",
  	auml: "ä",
  	"Bcy;": "Б",
  	"bcy;": "б",
  	"Bfr;": "𝔅",
  	"bfr;": "𝔟",
  	"bne;": "=⃥",
  	"bot;": "⊥",
  	"Cap;": "⋒",
  	"cap;": "∩",
  	cent: "¢",
  	"Cfr;": "ℭ",
  	"cfr;": "𝔠",
  	"Chi;": "Χ",
  	"chi;": "χ",
  	"cir;": "○",
  	COPY: "©",
  	copy: "©",
  	"Cup;": "⋓",
  	"cup;": "∪",
  	"Dcy;": "Д",
  	"dcy;": "д",
  	"deg;": "°",
  	"Del;": "∇",
  	"Dfr;": "𝔇",
  	"dfr;": "𝔡",
  	"die;": "¨",
  	"div;": "÷",
  	"Dot;": "¨",
  	"dot;": "˙",
  	"Ecy;": "Э",
  	"ecy;": "э",
  	"Efr;": "𝔈",
  	"efr;": "𝔢",
  	"egs;": "⪖",
  	"ell;": "ℓ",
  	"els;": "⪕",
  	"ENG;": "Ŋ",
  	"eng;": "ŋ",
  	"Eta;": "Η",
  	"eta;": "η",
  	"ETH;": "Ð",
  	"eth;": "ð",
  	Euml: "Ë",
  	euml: "ë",
  	"Fcy;": "Ф",
  	"fcy;": "ф",
  	"Ffr;": "𝔉",
  	"ffr;": "𝔣",
  	"gap;": "⪆",
  	"Gcy;": "Г",
  	"gcy;": "г",
  	"gEl;": "⪌",
  	"gel;": "⋛",
  	"geq;": "≥",
  	"ges;": "⩾",
  	"Gfr;": "𝔊",
  	"gfr;": "𝔤",
  	"ggg;": "⋙",
  	"gla;": "⪥",
  	"glE;": "⪒",
  	"glj;": "⪤",
  	"gnE;": "≩",
  	"gne;": "⪈",
  	"Hat;": "^",
  	"Hfr;": "ℌ",
  	"hfr;": "𝔥",
  	"Icy;": "И",
  	"icy;": "и",
  	"iff;": "⇔",
  	"Ifr;": "ℑ",
  	"ifr;": "𝔦",
  	"Int;": "∬",
  	"int;": "∫",
  	Iuml: "Ï",
  	iuml: "ï",
  	"Jcy;": "Й",
  	"jcy;": "й",
  	"Jfr;": "𝔍",
  	"jfr;": "𝔧",
  	"Kcy;": "К",
  	"kcy;": "к",
  	"Kfr;": "𝔎",
  	"kfr;": "𝔨",
  	"lap;": "⪅",
  	"lat;": "⪫",
  	"Lcy;": "Л",
  	"lcy;": "л",
  	"lEg;": "⪋",
  	"leg;": "⋚",
  	"leq;": "≤",
  	"les;": "⩽",
  	"Lfr;": "𝔏",
  	"lfr;": "𝔩",
  	"lgE;": "⪑",
  	"lnE;": "≨",
  	"lne;": "⪇",
  	"loz;": "◊",
  	"lrm;": "‎",
  	"Lsh;": "↰",
  	"lsh;": "↰",
  	macr: "¯",
  	"Map;": "⤅",
  	"map;": "↦",
  	"Mcy;": "М",
  	"mcy;": "м",
  	"Mfr;": "𝔐",
  	"mfr;": "𝔪",
  	"mho;": "℧",
  	"mid;": "∣",
  	"nap;": "≉",
  	nbsp: " ",
  	"Ncy;": "Н",
  	"ncy;": "н",
  	"Nfr;": "𝔑",
  	"nfr;": "𝔫",
  	"ngE;": "≧̸",
  	"nge;": "≱",
  	"nGg;": "⋙̸",
  	"nGt;": "≫⃒",
  	"ngt;": "≯",
  	"nis;": "⋼",
  	"niv;": "∋",
  	"nlE;": "≦̸",
  	"nle;": "≰",
  	"nLl;": "⋘̸",
  	"nLt;": "≪⃒",
  	"nlt;": "≮",
  	"Not;": "⫬",
  	"not;": "¬",
  	"npr;": "⊀",
  	"nsc;": "⊁",
  	"num;": "#",
  	"Ocy;": "О",
  	"ocy;": "о",
  	"Ofr;": "𝔒",
  	"ofr;": "𝔬",
  	"ogt;": "⧁",
  	"ohm;": "Ω",
  	"olt;": "⧀",
  	"ord;": "⩝",
  	ordf: "ª",
  	ordm: "º",
  	"orv;": "⩛",
  	Ouml: "Ö",
  	ouml: "ö",
  	"par;": "∥",
  	para: "¶",
  	"Pcy;": "П",
  	"pcy;": "п",
  	"Pfr;": "𝔓",
  	"pfr;": "𝔭",
  	"Phi;": "Φ",
  	"phi;": "φ",
  	"piv;": "ϖ",
  	"prE;": "⪳",
  	"pre;": "⪯",
  	"Psi;": "Ψ",
  	"psi;": "ψ",
  	"Qfr;": "𝔔",
  	"qfr;": "𝔮",
  	QUOT: "\"",
  	quot: "\"",
  	"Rcy;": "Р",
  	"rcy;": "р",
  	"REG;": "®",
  	"reg;": "®",
  	"Rfr;": "ℜ",
  	"rfr;": "𝔯",
  	"Rho;": "Ρ",
  	"rho;": "ρ",
  	"rlm;": "‏",
  	"Rsh;": "↱",
  	"rsh;": "↱",
  	"scE;": "⪴",
  	"sce;": "⪰",
  	"Scy;": "С",
  	"scy;": "с",
  	sect: "§",
  	"Sfr;": "𝔖",
  	"sfr;": "𝔰",
  	"shy;": "­",
  	"sim;": "∼",
  	"smt;": "⪪",
  	"sol;": "/",
  	"squ;": "□",
  	"Sub;": "⋐",
  	"sub;": "⊂",
  	"Sum;": "∑",
  	"sum;": "∑",
  	"Sup;": "⋑",
  	"sup;": "⊃",
  	sup1: "¹",
  	sup2: "²",
  	sup3: "³",
  	"Tab;": "\t",
  	"Tau;": "Τ",
  	"tau;": "τ",
  	"Tcy;": "Т",
  	"tcy;": "т",
  	"Tfr;": "𝔗",
  	"tfr;": "𝔱",
  	"top;": "⊤",
  	"Ucy;": "У",
  	"ucy;": "у",
  	"Ufr;": "𝔘",
  	"ufr;": "𝔲",
  	"uml;": "¨",
  	Uuml: "Ü",
  	uuml: "ü",
  	"Vcy;": "В",
  	"vcy;": "в",
  	"Vee;": "⋁",
  	"vee;": "∨",
  	"Vfr;": "𝔙",
  	"vfr;": "𝔳",
  	"Wfr;": "𝔚",
  	"wfr;": "𝔴",
  	"Xfr;": "𝔛",
  	"xfr;": "𝔵",
  	"Ycy;": "Ы",
  	"ycy;": "ы",
  	"yen;": "¥",
  	"Yfr;": "𝔜",
  	"yfr;": "𝔶",
  	yuml: "ÿ",
  	"Zcy;": "З",
  	"zcy;": "з",
  	"Zfr;": "ℨ",
  	"zfr;": "𝔷",
  	"zwj;": "‍",
  	Acirc: "Â",
  	acirc: "â",
  	acute: "´",
  	AElig: "Æ",
  	aelig: "æ",
  	"andd;": "⩜",
  	"andv;": "⩚",
  	"ange;": "⦤",
  	"Aopf;": "𝔸",
  	"aopf;": "𝕒",
  	"apid;": "≋",
  	"apos;": "'",
  	Aring: "Å",
  	aring: "å",
  	"Ascr;": "𝒜",
  	"ascr;": "𝒶",
  	"Auml;": "Ä",
  	"auml;": "ä",
  	"Barv;": "⫧",
  	"bbrk;": "⎵",
  	"Beta;": "Β",
  	"beta;": "β",
  	"beth;": "ℶ",
  	"bNot;": "⫭",
  	"bnot;": "⌐",
  	"Bopf;": "𝔹",
  	"bopf;": "𝕓",
  	"boxH;": "═",
  	"boxh;": "─",
  	"boxV;": "║",
  	"boxv;": "│",
  	"Bscr;": "ℬ",
  	"bscr;": "𝒷",
  	"bsim;": "∽",
  	"bsol;": "\\",
  	"bull;": "•",
  	"bump;": "≎",
  	"caps;": "∩︀",
  	"Cdot;": "Ċ",
  	"cdot;": "ċ",
  	cedil: "¸",
  	"cent;": "¢",
  	"CHcy;": "Ч",
  	"chcy;": "ч",
  	"circ;": "ˆ",
  	"cirE;": "⧃",
  	"cire;": "≗",
  	"comp;": "∁",
  	"cong;": "≅",
  	"Copf;": "ℂ",
  	"copf;": "𝕔",
  	"COPY;": "©",
  	"copy;": "©",
  	"Cscr;": "𝒞",
  	"cscr;": "𝒸",
  	"csub;": "⫏",
  	"csup;": "⫐",
  	"cups;": "∪︀",
  	"Darr;": "↡",
  	"dArr;": "⇓",
  	"darr;": "↓",
  	"dash;": "‐",
  	"dHar;": "⥥",
  	"diam;": "⋄",
  	"DJcy;": "Ђ",
  	"djcy;": "ђ",
  	"Dopf;": "𝔻",
  	"dopf;": "𝕕",
  	"Dscr;": "𝒟",
  	"dscr;": "𝒹",
  	"DScy;": "Ѕ",
  	"dscy;": "ѕ",
  	"dsol;": "⧶",
  	"dtri;": "▿",
  	"DZcy;": "Џ",
  	"dzcy;": "џ",
  	"ecir;": "≖",
  	Ecirc: "Ê",
  	ecirc: "ê",
  	"Edot;": "Ė",
  	"eDot;": "≑",
  	"edot;": "ė",
  	"emsp;": " ",
  	"ensp;": " ",
  	"Eopf;": "𝔼",
  	"eopf;": "𝕖",
  	"epar;": "⋕",
  	"epsi;": "ε",
  	"Escr;": "ℰ",
  	"escr;": "ℯ",
  	"Esim;": "⩳",
  	"esim;": "≂",
  	"Euml;": "Ë",
  	"euml;": "ë",
  	"euro;": "€",
  	"excl;": "!",
  	"flat;": "♭",
  	"fnof;": "ƒ",
  	"Fopf;": "𝔽",
  	"fopf;": "𝕗",
  	"fork;": "⋔",
  	"Fscr;": "ℱ",
  	"fscr;": "𝒻",
  	"Gdot;": "Ġ",
  	"gdot;": "ġ",
  	"geqq;": "≧",
  	"gesl;": "⋛︀",
  	"GJcy;": "Ѓ",
  	"gjcy;": "ѓ",
  	"gnap;": "⪊",
  	"gneq;": "⪈",
  	"Gopf;": "𝔾",
  	"gopf;": "𝕘",
  	"Gscr;": "𝒢",
  	"gscr;": "ℊ",
  	"gsim;": "≳",
  	"gtcc;": "⪧",
  	"gvnE;": "≩︀",
  	"half;": "½",
  	"hArr;": "⇔",
  	"harr;": "↔",
  	"hbar;": "ℏ",
  	"Hopf;": "ℍ",
  	"hopf;": "𝕙",
  	"Hscr;": "ℋ",
  	"hscr;": "𝒽",
  	Icirc: "Î",
  	icirc: "î",
  	"Idot;": "İ",
  	"IEcy;": "Е",
  	"iecy;": "е",
  	iexcl: "¡",
  	"imof;": "⊷",
  	"IOcy;": "Ё",
  	"iocy;": "ё",
  	"Iopf;": "𝕀",
  	"iopf;": "𝕚",
  	"Iota;": "Ι",
  	"iota;": "ι",
  	"Iscr;": "ℐ",
  	"iscr;": "𝒾",
  	"isin;": "∈",
  	"Iuml;": "Ï",
  	"iuml;": "ï",
  	"Jopf;": "𝕁",
  	"jopf;": "𝕛",
  	"Jscr;": "𝒥",
  	"jscr;": "𝒿",
  	"KHcy;": "Х",
  	"khcy;": "х",
  	"KJcy;": "Ќ",
  	"kjcy;": "ќ",
  	"Kopf;": "𝕂",
  	"kopf;": "𝕜",
  	"Kscr;": "𝒦",
  	"kscr;": "𝓀",
  	"Lang;": "⟪",
  	"lang;": "⟨",
  	laquo: "«",
  	"Larr;": "↞",
  	"lArr;": "⇐",
  	"larr;": "←",
  	"late;": "⪭",
  	"lcub;": "{",
  	"ldca;": "⤶",
  	"ldsh;": "↲",
  	"leqq;": "≦",
  	"lesg;": "⋚︀",
  	"lHar;": "⥢",
  	"LJcy;": "Љ",
  	"ljcy;": "љ",
  	"lnap;": "⪉",
  	"lneq;": "⪇",
  	"Lopf;": "𝕃",
  	"lopf;": "𝕝",
  	"lozf;": "⧫",
  	"lpar;": "(",
  	"Lscr;": "ℒ",
  	"lscr;": "𝓁",
  	"lsim;": "≲",
  	"lsqb;": "[",
  	"ltcc;": "⪦",
  	"ltri;": "◃",
  	"lvnE;": "≨︀",
  	"macr;": "¯",
  	"male;": "♂",
  	"malt;": "✠",
  	micro: "µ",
  	"mlcp;": "⫛",
  	"mldr;": "…",
  	"Mopf;": "𝕄",
  	"mopf;": "𝕞",
  	"Mscr;": "ℳ",
  	"mscr;": "𝓂",
  	"nang;": "∠⃒",
  	"napE;": "⩰̸",
  	"nbsp;": " ",
  	"ncap;": "⩃",
  	"ncup;": "⩂",
  	"ngeq;": "≱",
  	"nges;": "⩾̸",
  	"ngtr;": "≯",
  	"nGtv;": "≫̸",
  	"nisd;": "⋺",
  	"NJcy;": "Њ",
  	"njcy;": "њ",
  	"nldr;": "‥",
  	"nleq;": "≰",
  	"nles;": "⩽̸",
  	"nLtv;": "≪̸",
  	"nmid;": "∤",
  	"Nopf;": "ℕ",
  	"nopf;": "𝕟",
  	"npar;": "∦",
  	"npre;": "⪯̸",
  	"nsce;": "⪰̸",
  	"Nscr;": "𝒩",
  	"nscr;": "𝓃",
  	"nsim;": "≁",
  	"nsub;": "⊄",
  	"nsup;": "⊅",
  	"ntgl;": "≹",
  	"ntlg;": "≸",
  	"nvap;": "≍⃒",
  	"nvge;": "≥⃒",
  	"nvgt;": ">⃒",
  	"nvle;": "≤⃒",
  	"nvlt;": "<⃒",
  	"oast;": "⊛",
  	"ocir;": "⊚",
  	Ocirc: "Ô",
  	ocirc: "ô",
  	"odiv;": "⨸",
  	"odot;": "⊙",
  	"ogon;": "˛",
  	"oint;": "∮",
  	"omid;": "⦶",
  	"Oopf;": "𝕆",
  	"oopf;": "𝕠",
  	"opar;": "⦷",
  	"ordf;": "ª",
  	"ordm;": "º",
  	"oror;": "⩖",
  	"Oscr;": "𝒪",
  	"oscr;": "ℴ",
  	"osol;": "⊘",
  	"Ouml;": "Ö",
  	"ouml;": "ö",
  	"para;": "¶",
  	"part;": "∂",
  	"perp;": "⊥",
  	"phiv;": "ϕ",
  	"plus;": "+",
  	"Popf;": "ℙ",
  	"popf;": "𝕡",
  	pound: "£",
  	"prap;": "⪷",
  	"prec;": "≺",
  	"prnE;": "⪵",
  	"prod;": "∏",
  	"prop;": "∝",
  	"Pscr;": "𝒫",
  	"pscr;": "𝓅",
  	"qint;": "⨌",
  	"Qopf;": "ℚ",
  	"qopf;": "𝕢",
  	"Qscr;": "𝒬",
  	"qscr;": "𝓆",
  	"QUOT;": "\"",
  	"quot;": "\"",
  	"race;": "∽̱",
  	"Rang;": "⟫",
  	"rang;": "⟩",
  	raquo: "»",
  	"Rarr;": "↠",
  	"rArr;": "⇒",
  	"rarr;": "→",
  	"rcub;": "}",
  	"rdca;": "⤷",
  	"rdsh;": "↳",
  	"real;": "ℜ",
  	"rect;": "▭",
  	"rHar;": "⥤",
  	"rhov;": "ϱ",
  	"ring;": "˚",
  	"Ropf;": "ℝ",
  	"ropf;": "𝕣",
  	"rpar;": ")",
  	"Rscr;": "ℛ",
  	"rscr;": "𝓇",
  	"rsqb;": "]",
  	"rtri;": "▹",
  	"scap;": "⪸",
  	"scnE;": "⪶",
  	"sdot;": "⋅",
  	"sect;": "§",
  	"semi;": ";",
  	"sext;": "✶",
  	"SHcy;": "Ш",
  	"shcy;": "ш",
  	"sime;": "≃",
  	"simg;": "⪞",
  	"siml;": "⪝",
  	"smid;": "∣",
  	"smte;": "⪬",
  	"solb;": "⧄",
  	"Sopf;": "𝕊",
  	"sopf;": "𝕤",
  	"spar;": "∥",
  	"Sqrt;": "√",
  	"squf;": "▪",
  	"Sscr;": "𝒮",
  	"sscr;": "𝓈",
  	"Star;": "⋆",
  	"star;": "☆",
  	"subE;": "⫅",
  	"sube;": "⊆",
  	"succ;": "≻",
  	"sung;": "♪",
  	"sup1;": "¹",
  	"sup2;": "²",
  	"sup3;": "³",
  	"supE;": "⫆",
  	"supe;": "⊇",
  	szlig: "ß",
  	"tbrk;": "⎴",
  	"tdot;": "⃛",
  	THORN: "Þ",
  	thorn: "þ",
  	times: "×",
  	"tint;": "∭",
  	"toea;": "⤨",
  	"Topf;": "𝕋",
  	"topf;": "𝕥",
  	"tosa;": "⤩",
  	"trie;": "≜",
  	"Tscr;": "𝒯",
  	"tscr;": "𝓉",
  	"TScy;": "Ц",
  	"tscy;": "ц",
  	"Uarr;": "↟",
  	"uArr;": "⇑",
  	"uarr;": "↑",
  	Ucirc: "Û",
  	ucirc: "û",
  	"uHar;": "⥣",
  	"Uopf;": "𝕌",
  	"uopf;": "𝕦",
  	"Upsi;": "ϒ",
  	"upsi;": "υ",
  	"Uscr;": "𝒰",
  	"uscr;": "𝓊",
  	"utri;": "▵",
  	"Uuml;": "Ü",
  	"uuml;": "ü",
  	"vArr;": "⇕",
  	"varr;": "↕",
  	"Vbar;": "⫫",
  	"vBar;": "⫨",
  	"Vert;": "‖",
  	"vert;": "|",
  	"Vopf;": "𝕍",
  	"vopf;": "𝕧",
  	"Vscr;": "𝒱",
  	"vscr;": "𝓋",
  	"Wopf;": "𝕎",
  	"wopf;": "𝕨",
  	"Wscr;": "𝒲",
  	"wscr;": "𝓌",
  	"xcap;": "⋂",
  	"xcup;": "⋃",
  	"xmap;": "⟼",
  	"xnis;": "⋻",
  	"Xopf;": "𝕏",
  	"xopf;": "𝕩",
  	"Xscr;": "𝒳",
  	"xscr;": "𝓍",
  	"xvee;": "⋁",
  	"YAcy;": "Я",
  	"yacy;": "я",
  	"YIcy;": "Ї",
  	"yicy;": "ї",
  	"Yopf;": "𝕐",
  	"yopf;": "𝕪",
  	"Yscr;": "𝒴",
  	"yscr;": "𝓎",
  	"YUcy;": "Ю",
  	"yucy;": "ю",
  	"Yuml;": "Ÿ",
  	"yuml;": "ÿ",
  	"Zdot;": "Ż",
  	"zdot;": "ż",
  	"Zeta;": "Ζ",
  	"zeta;": "ζ",
  	"ZHcy;": "Ж",
  	"zhcy;": "ж",
  	"Zopf;": "ℤ",
  	"zopf;": "𝕫",
  	"Zscr;": "𝒵",
  	"zscr;": "𝓏",
  	"zwnj;": "‌",
  	Aacute: "Á",
  	aacute: "á",
  	"Acirc;": "Â",
  	"acirc;": "â",
  	"acute;": "´",
  	"AElig;": "Æ",
  	"aelig;": "æ",
  	Agrave: "À",
  	agrave: "à",
  	"aleph;": "ℵ",
  	"Alpha;": "Α",
  	"alpha;": "α",
  	"Amacr;": "Ā",
  	"amacr;": "ā",
  	"amalg;": "⨿",
  	"angle;": "∠",
  	"angrt;": "∟",
  	"angst;": "Å",
  	"Aogon;": "Ą",
  	"aogon;": "ą",
  	"Aring;": "Å",
  	"aring;": "å",
  	"asymp;": "≈",
  	Atilde: "Ã",
  	atilde: "ã",
  	"awint;": "⨑",
  	"bcong;": "≌",
  	"bdquo;": "„",
  	"bepsi;": "϶",
  	"blank;": "␣",
  	"blk12;": "▒",
  	"blk14;": "░",
  	"blk34;": "▓",
  	"block;": "█",
  	"boxDL;": "╗",
  	"boxDl;": "╖",
  	"boxdL;": "╕",
  	"boxdl;": "┐",
  	"boxDR;": "╔",
  	"boxDr;": "╓",
  	"boxdR;": "╒",
  	"boxdr;": "┌",
  	"boxHD;": "╦",
  	"boxHd;": "╤",
  	"boxhD;": "╥",
  	"boxhd;": "┬",
  	"boxHU;": "╩",
  	"boxHu;": "╧",
  	"boxhU;": "╨",
  	"boxhu;": "┴",
  	"boxUL;": "╝",
  	"boxUl;": "╜",
  	"boxuL;": "╛",
  	"boxul;": "┘",
  	"boxUR;": "╚",
  	"boxUr;": "╙",
  	"boxuR;": "╘",
  	"boxur;": "└",
  	"boxVH;": "╬",
  	"boxVh;": "╫",
  	"boxvH;": "╪",
  	"boxvh;": "┼",
  	"boxVL;": "╣",
  	"boxVl;": "╢",
  	"boxvL;": "╡",
  	"boxvl;": "┤",
  	"boxVR;": "╠",
  	"boxVr;": "╟",
  	"boxvR;": "╞",
  	"boxvr;": "├",
  	"Breve;": "˘",
  	"breve;": "˘",
  	brvbar: "¦",
  	"bsemi;": "⁏",
  	"bsime;": "⋍",
  	"bsolb;": "⧅",
  	"bumpE;": "⪮",
  	"bumpe;": "≏",
  	"caret;": "⁁",
  	"caron;": "ˇ",
  	"ccaps;": "⩍",
  	Ccedil: "Ç",
  	ccedil: "ç",
  	"Ccirc;": "Ĉ",
  	"ccirc;": "ĉ",
  	"ccups;": "⩌",
  	"cedil;": "¸",
  	"check;": "✓",
  	"clubs;": "♣",
  	"Colon;": "∷",
  	"colon;": ":",
  	"comma;": ",",
  	"crarr;": "↵",
  	"Cross;": "⨯",
  	"cross;": "✗",
  	"csube;": "⫑",
  	"csupe;": "⫒",
  	"ctdot;": "⋯",
  	"cuepr;": "⋞",
  	"cuesc;": "⋟",
  	"cupor;": "⩅",
  	curren: "¤",
  	"cuvee;": "⋎",
  	"cuwed;": "⋏",
  	"cwint;": "∱",
  	"Dashv;": "⫤",
  	"dashv;": "⊣",
  	"dblac;": "˝",
  	"ddarr;": "⇊",
  	"Delta;": "Δ",
  	"delta;": "δ",
  	"dharl;": "⇃",
  	"dharr;": "⇂",
  	"diams;": "♦",
  	"disin;": "⋲",
  	divide: "÷",
  	"doteq;": "≐",
  	"dtdot;": "⋱",
  	"dtrif;": "▾",
  	"duarr;": "⇵",
  	"duhar;": "⥯",
  	Eacute: "É",
  	eacute: "é",
  	"Ecirc;": "Ê",
  	"ecirc;": "ê",
  	"eDDot;": "⩷",
  	"efDot;": "≒",
  	Egrave: "È",
  	egrave: "è",
  	"Emacr;": "Ē",
  	"emacr;": "ē",
  	"empty;": "∅",
  	"Eogon;": "Ę",
  	"eogon;": "ę",
  	"eplus;": "⩱",
  	"epsiv;": "ϵ",
  	"eqsim;": "≂",
  	"Equal;": "⩵",
  	"equiv;": "≡",
  	"erarr;": "⥱",
  	"erDot;": "≓",
  	"esdot;": "≐",
  	"exist;": "∃",
  	"fflig;": "ﬀ",
  	"filig;": "ﬁ",
  	"fjlig;": "fj",
  	"fllig;": "ﬂ",
  	"fltns;": "▱",
  	"forkv;": "⫙",
  	frac12: "½",
  	frac14: "¼",
  	frac34: "¾",
  	"frasl;": "⁄",
  	"frown;": "⌢",
  	"Gamma;": "Γ",
  	"gamma;": "γ",
  	"Gcirc;": "Ĝ",
  	"gcirc;": "ĝ",
  	"gescc;": "⪩",
  	"gimel;": "ℷ",
  	"gneqq;": "≩",
  	"gnsim;": "⋧",
  	"grave;": "`",
  	"gsime;": "⪎",
  	"gsiml;": "⪐",
  	"gtcir;": "⩺",
  	"gtdot;": "⋗",
  	"Hacek;": "ˇ",
  	"harrw;": "↭",
  	"Hcirc;": "Ĥ",
  	"hcirc;": "ĥ",
  	"hoarr;": "⇿",
  	Iacute: "Í",
  	iacute: "í",
  	"Icirc;": "Î",
  	"icirc;": "î",
  	"iexcl;": "¡",
  	Igrave: "Ì",
  	igrave: "ì",
  	"iiint;": "∭",
  	"iiota;": "℩",
  	"IJlig;": "Ĳ",
  	"ijlig;": "ĳ",
  	"Imacr;": "Ī",
  	"imacr;": "ī",
  	"image;": "ℑ",
  	"imath;": "ı",
  	"imped;": "Ƶ",
  	"infin;": "∞",
  	"Iogon;": "Į",
  	"iogon;": "į",
  	"iprod;": "⨼",
  	iquest: "¿",
  	"isinE;": "⋹",
  	"isins;": "⋴",
  	"isinv;": "∈",
  	"Iukcy;": "І",
  	"iukcy;": "і",
  	"Jcirc;": "Ĵ",
  	"jcirc;": "ĵ",
  	"jmath;": "ȷ",
  	"Jukcy;": "Є",
  	"jukcy;": "є",
  	"Kappa;": "Κ",
  	"kappa;": "κ",
  	"lAarr;": "⇚",
  	"langd;": "⦑",
  	"laquo;": "«",
  	"larrb;": "⇤",
  	"lates;": "⪭︀",
  	"lBarr;": "⤎",
  	"lbarr;": "⤌",
  	"lbbrk;": "❲",
  	"lbrke;": "⦋",
  	"lceil;": "⌈",
  	"ldquo;": "“",
  	"lescc;": "⪨",
  	"lhard;": "↽",
  	"lharu;": "↼",
  	"lhblk;": "▄",
  	"llarr;": "⇇",
  	"lltri;": "◺",
  	"lneqq;": "≨",
  	"lnsim;": "⋦",
  	"loang;": "⟬",
  	"loarr;": "⇽",
  	"lobrk;": "⟦",
  	"lopar;": "⦅",
  	"lrarr;": "⇆",
  	"lrhar;": "⇋",
  	"lrtri;": "⊿",
  	"lsime;": "⪍",
  	"lsimg;": "⪏",
  	"lsquo;": "‘",
  	"ltcir;": "⩹",
  	"ltdot;": "⋖",
  	"ltrie;": "⊴",
  	"ltrif;": "◂",
  	"mdash;": "—",
  	"mDDot;": "∺",
  	"micro;": "µ",
  	middot: "·",
  	"minus;": "−",
  	"mumap;": "⊸",
  	"nabla;": "∇",
  	"napid;": "≋̸",
  	"napos;": "ŉ",
  	"natur;": "♮",
  	"nbump;": "≎̸",
  	"ncong;": "≇",
  	"ndash;": "–",
  	"neArr;": "⇗",
  	"nearr;": "↗",
  	"nedot;": "≐̸",
  	"nesim;": "≂̸",
  	"ngeqq;": "≧̸",
  	"ngsim;": "≵",
  	"nhArr;": "⇎",
  	"nharr;": "↮",
  	"nhpar;": "⫲",
  	"nlArr;": "⇍",
  	"nlarr;": "↚",
  	"nleqq;": "≦̸",
  	"nless;": "≮",
  	"nlsim;": "≴",
  	"nltri;": "⋪",
  	"notin;": "∉",
  	"notni;": "∌",
  	"npart;": "∂̸",
  	"nprec;": "⊀",
  	"nrArr;": "⇏",
  	"nrarr;": "↛",
  	"nrtri;": "⋫",
  	"nsime;": "≄",
  	"nsmid;": "∤",
  	"nspar;": "∦",
  	"nsubE;": "⫅̸",
  	"nsube;": "⊈",
  	"nsucc;": "⊁",
  	"nsupE;": "⫆̸",
  	"nsupe;": "⊉",
  	Ntilde: "Ñ",
  	ntilde: "ñ",
  	"numsp;": " ",
  	"nvsim;": "∼⃒",
  	"nwArr;": "⇖",
  	"nwarr;": "↖",
  	Oacute: "Ó",
  	oacute: "ó",
  	"Ocirc;": "Ô",
  	"ocirc;": "ô",
  	"odash;": "⊝",
  	"OElig;": "Œ",
  	"oelig;": "œ",
  	"ofcir;": "⦿",
  	Ograve: "Ò",
  	ograve: "ò",
  	"ohbar;": "⦵",
  	"olarr;": "↺",
  	"olcir;": "⦾",
  	"oline;": "‾",
  	"Omacr;": "Ō",
  	"omacr;": "ō",
  	"Omega;": "Ω",
  	"omega;": "ω",
  	"operp;": "⦹",
  	"oplus;": "⊕",
  	"orarr;": "↻",
  	"order;": "ℴ",
  	Oslash: "Ø",
  	oslash: "ø",
  	Otilde: "Õ",
  	otilde: "õ",
  	"ovbar;": "⌽",
  	"parsl;": "⫽",
  	"phone;": "☎",
  	"plusb;": "⊞",
  	"pluse;": "⩲",
  	plusmn: "±",
  	"pound;": "£",
  	"prcue;": "≼",
  	"Prime;": "″",
  	"prime;": "′",
  	"prnap;": "⪹",
  	"prsim;": "≾",
  	"quest;": "?",
  	"rAarr;": "⇛",
  	"radic;": "√",
  	"rangd;": "⦒",
  	"range;": "⦥",
  	"raquo;": "»",
  	"rarrb;": "⇥",
  	"rarrc;": "⤳",
  	"rarrw;": "↝",
  	"ratio;": "∶",
  	"RBarr;": "⤐",
  	"rBarr;": "⤏",
  	"rbarr;": "⤍",
  	"rbbrk;": "❳",
  	"rbrke;": "⦌",
  	"rceil;": "⌉",
  	"rdquo;": "”",
  	"reals;": "ℝ",
  	"rhard;": "⇁",
  	"rharu;": "⇀",
  	"rlarr;": "⇄",
  	"rlhar;": "⇌",
  	"rnmid;": "⫮",
  	"roang;": "⟭",
  	"roarr;": "⇾",
  	"robrk;": "⟧",
  	"ropar;": "⦆",
  	"rrarr;": "⇉",
  	"rsquo;": "’",
  	"rtrie;": "⊵",
  	"rtrif;": "▸",
  	"sbquo;": "‚",
  	"sccue;": "≽",
  	"Scirc;": "Ŝ",
  	"scirc;": "ŝ",
  	"scnap;": "⪺",
  	"scsim;": "≿",
  	"sdotb;": "⊡",
  	"sdote;": "⩦",
  	"seArr;": "⇘",
  	"searr;": "↘",
  	"setmn;": "∖",
  	"sharp;": "♯",
  	"Sigma;": "Σ",
  	"sigma;": "σ",
  	"simeq;": "≃",
  	"simgE;": "⪠",
  	"simlE;": "⪟",
  	"simne;": "≆",
  	"slarr;": "←",
  	"smile;": "⌣",
  	"smtes;": "⪬︀",
  	"sqcap;": "⊓",
  	"sqcup;": "⊔",
  	"sqsub;": "⊏",
  	"sqsup;": "⊐",
  	"srarr;": "→",
  	"starf;": "★",
  	"strns;": "¯",
  	"subnE;": "⫋",
  	"subne;": "⊊",
  	"supnE;": "⫌",
  	"supne;": "⊋",
  	"swArr;": "⇙",
  	"swarr;": "↙",
  	"szlig;": "ß",
  	"Theta;": "Θ",
  	"theta;": "θ",
  	"thkap;": "≈",
  	"THORN;": "Þ",
  	"thorn;": "þ",
  	"Tilde;": "∼",
  	"tilde;": "˜",
  	"times;": "×",
  	"TRADE;": "™",
  	"trade;": "™",
  	"trisb;": "⧍",
  	"TSHcy;": "Ћ",
  	"tshcy;": "ћ",
  	"twixt;": "≬",
  	Uacute: "Ú",
  	uacute: "ú",
  	"Ubrcy;": "Ў",
  	"ubrcy;": "ў",
  	"Ucirc;": "Û",
  	"ucirc;": "û",
  	"udarr;": "⇅",
  	"udhar;": "⥮",
  	Ugrave: "Ù",
  	ugrave: "ù",
  	"uharl;": "↿",
  	"uharr;": "↾",
  	"uhblk;": "▀",
  	"ultri;": "◸",
  	"Umacr;": "Ū",
  	"umacr;": "ū",
  	"Union;": "⋃",
  	"Uogon;": "Ų",
  	"uogon;": "ų",
  	"uplus;": "⊎",
  	"upsih;": "ϒ",
  	"UpTee;": "⊥",
  	"Uring;": "Ů",
  	"uring;": "ů",
  	"urtri;": "◹",
  	"utdot;": "⋰",
  	"utrif;": "▴",
  	"uuarr;": "⇈",
  	"varpi;": "ϖ",
  	"vBarv;": "⫩",
  	"VDash;": "⊫",
  	"Vdash;": "⊩",
  	"vDash;": "⊨",
  	"vdash;": "⊢",
  	"veeeq;": "≚",
  	"vltri;": "⊲",
  	"vnsub;": "⊂⃒",
  	"vnsup;": "⊃⃒",
  	"vprop;": "∝",
  	"vrtri;": "⊳",
  	"Wcirc;": "Ŵ",
  	"wcirc;": "ŵ",
  	"Wedge;": "⋀",
  	"wedge;": "∧",
  	"xcirc;": "◯",
  	"xdtri;": "▽",
  	"xhArr;": "⟺",
  	"xharr;": "⟷",
  	"xlArr;": "⟸",
  	"xlarr;": "⟵",
  	"xodot;": "⨀",
  	"xrArr;": "⟹",
  	"xrarr;": "⟶",
  	"xutri;": "△",
  	Yacute: "Ý",
  	yacute: "ý",
  	"Ycirc;": "Ŷ",
  	"ycirc;": "ŷ",
  	"Aacute;": "Á",
  	"aacute;": "á",
  	"Abreve;": "Ă",
  	"abreve;": "ă",
  	"Agrave;": "À",
  	"agrave;": "à",
  	"andand;": "⩕",
  	"angmsd;": "∡",
  	"angsph;": "∢",
  	"apacir;": "⩯",
  	"approx;": "≈",
  	"Assign;": "≔",
  	"Atilde;": "Ã",
  	"atilde;": "ã",
  	"barvee;": "⊽",
  	"Barwed;": "⌆",
  	"barwed;": "⌅",
  	"becaus;": "∵",
  	"bernou;": "ℬ",
  	"bigcap;": "⋂",
  	"bigcup;": "⋃",
  	"bigvee;": "⋁",
  	"bkarow;": "⤍",
  	"bottom;": "⊥",
  	"bowtie;": "⋈",
  	"boxbox;": "⧉",
  	"bprime;": "‵",
  	"brvbar;": "¦",
  	"bullet;": "•",
  	"Bumpeq;": "≎",
  	"bumpeq;": "≏",
  	"Cacute;": "Ć",
  	"cacute;": "ć",
  	"capand;": "⩄",
  	"capcap;": "⩋",
  	"capcup;": "⩇",
  	"capdot;": "⩀",
  	"Ccaron;": "Č",
  	"ccaron;": "č",
  	"Ccedil;": "Ç",
  	"ccedil;": "ç",
  	"circeq;": "≗",
  	"cirmid;": "⫯",
  	"Colone;": "⩴",
  	"colone;": "≔",
  	"commat;": "@",
  	"compfn;": "∘",
  	"Conint;": "∯",
  	"conint;": "∮",
  	"coprod;": "∐",
  	"copysr;": "℗",
  	"cularr;": "↶",
  	"CupCap;": "≍",
  	"cupcap;": "⩆",
  	"cupcup;": "⩊",
  	"cupdot;": "⊍",
  	"curarr;": "↷",
  	"curren;": "¤",
  	"cylcty;": "⌭",
  	"Dagger;": "‡",
  	"dagger;": "†",
  	"daleth;": "ℸ",
  	"Dcaron;": "Ď",
  	"dcaron;": "ď",
  	"dfisht;": "⥿",
  	"divide;": "÷",
  	"divonx;": "⋇",
  	"dlcorn;": "⌞",
  	"dlcrop;": "⌍",
  	"dollar;": "$",
  	"DotDot;": "⃜",
  	"drcorn;": "⌟",
  	"drcrop;": "⌌",
  	"Dstrok;": "Đ",
  	"dstrok;": "đ",
  	"Eacute;": "É",
  	"eacute;": "é",
  	"easter;": "⩮",
  	"Ecaron;": "Ě",
  	"ecaron;": "ě",
  	"ecolon;": "≕",
  	"Egrave;": "È",
  	"egrave;": "è",
  	"egsdot;": "⪘",
  	"elsdot;": "⪗",
  	"emptyv;": "∅",
  	"emsp13;": " ",
  	"emsp14;": " ",
  	"eparsl;": "⧣",
  	"eqcirc;": "≖",
  	"equals;": "=",
  	"equest;": "≟",
  	"Exists;": "∃",
  	"female;": "♀",
  	"ffilig;": "ﬃ",
  	"ffllig;": "ﬄ",
  	"ForAll;": "∀",
  	"forall;": "∀",
  	"frac12;": "½",
  	"frac13;": "⅓",
  	"frac14;": "¼",
  	"frac15;": "⅕",
  	"frac16;": "⅙",
  	"frac18;": "⅛",
  	"frac23;": "⅔",
  	"frac25;": "⅖",
  	"frac34;": "¾",
  	"frac35;": "⅗",
  	"frac38;": "⅜",
  	"frac45;": "⅘",
  	"frac56;": "⅚",
  	"frac58;": "⅝",
  	"frac78;": "⅞",
  	"gacute;": "ǵ",
  	"Gammad;": "Ϝ",
  	"gammad;": "ϝ",
  	"Gbreve;": "Ğ",
  	"gbreve;": "ğ",
  	"Gcedil;": "Ģ",
  	"gesdot;": "⪀",
  	"gesles;": "⪔",
  	"gtlPar;": "⦕",
  	"gtrarr;": "⥸",
  	"gtrdot;": "⋗",
  	"gtrsim;": "≳",
  	"hairsp;": " ",
  	"hamilt;": "ℋ",
  	"HARDcy;": "Ъ",
  	"hardcy;": "ъ",
  	"hearts;": "♥",
  	"hellip;": "…",
  	"hercon;": "⊹",
  	"homtht;": "∻",
  	"horbar;": "―",
  	"hslash;": "ℏ",
  	"Hstrok;": "Ħ",
  	"hstrok;": "ħ",
  	"hybull;": "⁃",
  	"hyphen;": "‐",
  	"Iacute;": "Í",
  	"iacute;": "í",
  	"Igrave;": "Ì",
  	"igrave;": "ì",
  	"iiiint;": "⨌",
  	"iinfin;": "⧜",
  	"incare;": "℅",
  	"inodot;": "ı",
  	"intcal;": "⊺",
  	"iquest;": "¿",
  	"isinsv;": "⋳",
  	"Itilde;": "Ĩ",
  	"itilde;": "ĩ",
  	"Jsercy;": "Ј",
  	"jsercy;": "ј",
  	"kappav;": "ϰ",
  	"Kcedil;": "Ķ",
  	"kcedil;": "ķ",
  	"kgreen;": "ĸ",
  	"Lacute;": "Ĺ",
  	"lacute;": "ĺ",
  	"lagran;": "ℒ",
  	"Lambda;": "Λ",
  	"lambda;": "λ",
  	"langle;": "⟨",
  	"larrfs;": "⤝",
  	"larrhk;": "↩",
  	"larrlp;": "↫",
  	"larrpl;": "⤹",
  	"larrtl;": "↢",
  	"lAtail;": "⤛",
  	"latail;": "⤙",
  	"lbrace;": "{",
  	"lbrack;": "[",
  	"Lcaron;": "Ľ",
  	"lcaron;": "ľ",
  	"Lcedil;": "Ļ",
  	"lcedil;": "ļ",
  	"ldquor;": "„",
  	"lesdot;": "⩿",
  	"lesges;": "⪓",
  	"lfisht;": "⥼",
  	"lfloor;": "⌊",
  	"lharul;": "⥪",
  	"llhard;": "⥫",
  	"Lmidot;": "Ŀ",
  	"lmidot;": "ŀ",
  	"lmoust;": "⎰",
  	"loplus;": "⨭",
  	"lowast;": "∗",
  	"lowbar;": "_",
  	"lparlt;": "⦓",
  	"lrhard;": "⥭",
  	"lsaquo;": "‹",
  	"lsquor;": "‚",
  	"Lstrok;": "Ł",
  	"lstrok;": "ł",
  	"lthree;": "⋋",
  	"ltimes;": "⋉",
  	"ltlarr;": "⥶",
  	"ltrPar;": "⦖",
  	"mapsto;": "↦",
  	"marker;": "▮",
  	"mcomma;": "⨩",
  	"midast;": "*",
  	"midcir;": "⫰",
  	"middot;": "·",
  	"minusb;": "⊟",
  	"minusd;": "∸",
  	"mnplus;": "∓",
  	"models;": "⊧",
  	"mstpos;": "∾",
  	"Nacute;": "Ń",
  	"nacute;": "ń",
  	"nbumpe;": "≏̸",
  	"Ncaron;": "Ň",
  	"ncaron;": "ň",
  	"Ncedil;": "Ņ",
  	"ncedil;": "ņ",
  	"nearhk;": "⤤",
  	"nequiv;": "≢",
  	"nesear;": "⤨",
  	"nexist;": "∄",
  	"nltrie;": "⋬",
  	"notinE;": "⋹̸",
  	"nparsl;": "⫽⃥",
  	"nprcue;": "⋠",
  	"nrarrc;": "⤳̸",
  	"nrarrw;": "↝̸",
  	"nrtrie;": "⋭",
  	"nsccue;": "⋡",
  	"nsimeq;": "≄",
  	"Ntilde;": "Ñ",
  	"ntilde;": "ñ",
  	"numero;": "№",
  	"nVDash;": "⊯",
  	"nVdash;": "⊮",
  	"nvDash;": "⊭",
  	"nvdash;": "⊬",
  	"nvHarr;": "⤄",
  	"nvlArr;": "⤂",
  	"nvrArr;": "⤃",
  	"nwarhk;": "⤣",
  	"nwnear;": "⤧",
  	"Oacute;": "Ó",
  	"oacute;": "ó",
  	"Odblac;": "Ő",
  	"odblac;": "ő",
  	"odsold;": "⦼",
  	"Ograve;": "Ò",
  	"ograve;": "ò",
  	"ominus;": "⊖",
  	"origof;": "⊶",
  	"Oslash;": "Ø",
  	"oslash;": "ø",
  	"Otilde;": "Õ",
  	"otilde;": "õ",
  	"Otimes;": "⨷",
  	"otimes;": "⊗",
  	"parsim;": "⫳",
  	"percnt;": "%",
  	"period;": ".",
  	"permil;": "‰",
  	"phmmat;": "ℳ",
  	"planck;": "ℏ",
  	"plankv;": "ℏ",
  	"plusdo;": "∔",
  	"plusdu;": "⨥",
  	"plusmn;": "±",
  	"preceq;": "⪯",
  	"primes;": "ℙ",
  	"prnsim;": "⋨",
  	"propto;": "∝",
  	"prurel;": "⊰",
  	"puncsp;": " ",
  	"qprime;": "⁗",
  	"Racute;": "Ŕ",
  	"racute;": "ŕ",
  	"rangle;": "⟩",
  	"rarrap;": "⥵",
  	"rarrfs;": "⤞",
  	"rarrhk;": "↪",
  	"rarrlp;": "↬",
  	"rarrpl;": "⥅",
  	"Rarrtl;": "⤖",
  	"rarrtl;": "↣",
  	"rAtail;": "⤜",
  	"ratail;": "⤚",
  	"rbrace;": "}",
  	"rbrack;": "]",
  	"Rcaron;": "Ř",
  	"rcaron;": "ř",
  	"Rcedil;": "Ŗ",
  	"rcedil;": "ŗ",
  	"rdquor;": "”",
  	"rfisht;": "⥽",
  	"rfloor;": "⌋",
  	"rharul;": "⥬",
  	"rmoust;": "⎱",
  	"roplus;": "⨮",
  	"rpargt;": "⦔",
  	"rsaquo;": "›",
  	"rsquor;": "’",
  	"rthree;": "⋌",
  	"rtimes;": "⋊",
  	"Sacute;": "Ś",
  	"sacute;": "ś",
  	"Scaron;": "Š",
  	"scaron;": "š",
  	"Scedil;": "Ş",
  	"scedil;": "ş",
  	"scnsim;": "⋩",
  	"searhk;": "⤥",
  	"seswar;": "⤩",
  	"sfrown;": "⌢",
  	"SHCHcy;": "Щ",
  	"shchcy;": "щ",
  	"sigmaf;": "ς",
  	"sigmav;": "ς",
  	"simdot;": "⩪",
  	"smashp;": "⨳",
  	"SOFTcy;": "Ь",
  	"softcy;": "ь",
  	"solbar;": "⌿",
  	"spades;": "♠",
  	"sqcaps;": "⊓︀",
  	"sqcups;": "⊔︀",
  	"sqsube;": "⊑",
  	"sqsupe;": "⊒",
  	"Square;": "□",
  	"square;": "□",
  	"squarf;": "▪",
  	"ssetmn;": "∖",
  	"ssmile;": "⌣",
  	"sstarf;": "⋆",
  	"subdot;": "⪽",
  	"Subset;": "⋐",
  	"subset;": "⊂",
  	"subsim;": "⫇",
  	"subsub;": "⫕",
  	"subsup;": "⫓",
  	"succeq;": "⪰",
  	"supdot;": "⪾",
  	"Supset;": "⋑",
  	"supset;": "⊃",
  	"supsim;": "⫈",
  	"supsub;": "⫔",
  	"supsup;": "⫖",
  	"swarhk;": "⤦",
  	"swnwar;": "⤪",
  	"target;": "⌖",
  	"Tcaron;": "Ť",
  	"tcaron;": "ť",
  	"Tcedil;": "Ţ",
  	"tcedil;": "ţ",
  	"telrec;": "⌕",
  	"there4;": "∴",
  	"thetav;": "ϑ",
  	"thinsp;": " ",
  	"thksim;": "∼",
  	"timesb;": "⊠",
  	"timesd;": "⨰",
  	"topbot;": "⌶",
  	"topcir;": "⫱",
  	"tprime;": "‴",
  	"tridot;": "◬",
  	"Tstrok;": "Ŧ",
  	"tstrok;": "ŧ",
  	"Uacute;": "Ú",
  	"uacute;": "ú",
  	"Ubreve;": "Ŭ",
  	"ubreve;": "ŭ",
  	"Udblac;": "Ű",
  	"udblac;": "ű",
  	"ufisht;": "⥾",
  	"Ugrave;": "Ù",
  	"ugrave;": "ù",
  	"ulcorn;": "⌜",
  	"ulcrop;": "⌏",
  	"urcorn;": "⌝",
  	"urcrop;": "⌎",
  	"Utilde;": "Ũ",
  	"utilde;": "ũ",
  	"vangrt;": "⦜",
  	"varphi;": "ϕ",
  	"varrho;": "ϱ",
  	"Vdashl;": "⫦",
  	"veebar;": "⊻",
  	"vellip;": "⋮",
  	"Verbar;": "‖",
  	"verbar;": "|",
  	"vsubnE;": "⫋︀",
  	"vsubne;": "⊊︀",
  	"vsupnE;": "⫌︀",
  	"vsupne;": "⊋︀",
  	"Vvdash;": "⊪",
  	"wedbar;": "⩟",
  	"wedgeq;": "≙",
  	"weierp;": "℘",
  	"wreath;": "≀",
  	"xoplus;": "⨁",
  	"xotime;": "⨂",
  	"xsqcup;": "⨆",
  	"xuplus;": "⨄",
  	"xwedge;": "⋀",
  	"Yacute;": "Ý",
  	"yacute;": "ý",
  	"Zacute;": "Ź",
  	"zacute;": "ź",
  	"Zcaron;": "Ž",
  	"zcaron;": "ž",
  	"zeetrf;": "ℨ",
  	"alefsym;": "ℵ",
  	"angrtvb;": "⊾",
  	"angzarr;": "⍼",
  	"asympeq;": "≍",
  	"backsim;": "∽",
  	"Because;": "∵",
  	"because;": "∵",
  	"bemptyv;": "⦰",
  	"between;": "≬",
  	"bigcirc;": "◯",
  	"bigodot;": "⨀",
  	"bigstar;": "★",
  	"bnequiv;": "≡⃥",
  	"boxplus;": "⊞",
  	"Cayleys;": "ℭ",
  	"Cconint;": "∰",
  	"ccupssm;": "⩐",
  	"Cedilla;": "¸",
  	"cemptyv;": "⦲",
  	"cirscir;": "⧂",
  	"coloneq;": "≔",
  	"congdot;": "⩭",
  	"cudarrl;": "⤸",
  	"cudarrr;": "⤵",
  	"cularrp;": "⤽",
  	"curarrm;": "⤼",
  	"dbkarow;": "⤏",
  	"ddagger;": "‡",
  	"ddotseq;": "⩷",
  	"demptyv;": "⦱",
  	"Diamond;": "⋄",
  	"diamond;": "⋄",
  	"digamma;": "ϝ",
  	"dotplus;": "∔",
  	"DownTee;": "⊤",
  	"dwangle;": "⦦",
  	"Element;": "∈",
  	"Epsilon;": "Ε",
  	"epsilon;": "ε",
  	"eqcolon;": "≕",
  	"equivDD;": "⩸",
  	"gesdoto;": "⪂",
  	"gtquest;": "⩼",
  	"gtrless;": "≷",
  	"harrcir;": "⥈",
  	"Implies;": "⇒",
  	"intprod;": "⨼",
  	"isindot;": "⋵",
  	"larrbfs;": "⤟",
  	"larrsim;": "⥳",
  	"lbrksld;": "⦏",
  	"lbrkslu;": "⦍",
  	"ldrdhar;": "⥧",
  	"LeftTee;": "⊣",
  	"lesdoto;": "⪁",
  	"lessdot;": "⋖",
  	"lessgtr;": "≶",
  	"lesssim;": "≲",
  	"lotimes;": "⨴",
  	"lozenge;": "◊",
  	"ltquest;": "⩻",
  	"luruhar;": "⥦",
  	"maltese;": "✠",
  	"minusdu;": "⨪",
  	"napprox;": "≉",
  	"natural;": "♮",
  	"nearrow;": "↗",
  	"NewLine;": "\n",
  	"nexists;": "∄",
  	"NoBreak;": "⁠",
  	"notinva;": "∉",
  	"notinvb;": "⋷",
  	"notinvc;": "⋶",
  	"NotLess;": "≮",
  	"notniva;": "∌",
  	"notnivb;": "⋾",
  	"notnivc;": "⋽",
  	"npolint;": "⨔",
  	"npreceq;": "⪯̸",
  	"nsqsube;": "⋢",
  	"nsqsupe;": "⋣",
  	"nsubset;": "⊂⃒",
  	"nsucceq;": "⪰̸",
  	"nsupset;": "⊃⃒",
  	"nvinfin;": "⧞",
  	"nvltrie;": "⊴⃒",
  	"nvrtrie;": "⊵⃒",
  	"nwarrow;": "↖",
  	"olcross;": "⦻",
  	"Omicron;": "Ο",
  	"omicron;": "ο",
  	"orderof;": "ℴ",
  	"orslope;": "⩗",
  	"OverBar;": "‾",
  	"pertenk;": "‱",
  	"planckh;": "ℎ",
  	"pluscir;": "⨢",
  	"plussim;": "⨦",
  	"plustwo;": "⨧",
  	"precsim;": "≾",
  	"Product;": "∏",
  	"quatint;": "⨖",
  	"questeq;": "≟",
  	"rarrbfs;": "⤠",
  	"rarrsim;": "⥴",
  	"rbrksld;": "⦎",
  	"rbrkslu;": "⦐",
  	"rdldhar;": "⥩",
  	"realine;": "ℛ",
  	"rotimes;": "⨵",
  	"ruluhar;": "⥨",
  	"searrow;": "↘",
  	"simplus;": "⨤",
  	"simrarr;": "⥲",
  	"subedot;": "⫃",
  	"submult;": "⫁",
  	"subplus;": "⪿",
  	"subrarr;": "⥹",
  	"succsim;": "≿",
  	"supdsub;": "⫘",
  	"supedot;": "⫄",
  	"suphsol;": "⟉",
  	"suphsub;": "⫗",
  	"suplarr;": "⥻",
  	"supmult;": "⫂",
  	"supplus;": "⫀",
  	"swarrow;": "↙",
  	"topfork;": "⫚",
  	"triplus;": "⨹",
  	"tritime;": "⨻",
  	"UpArrow;": "↑",
  	"Uparrow;": "⇑",
  	"uparrow;": "↑",
  	"Upsilon;": "Υ",
  	"upsilon;": "υ",
  	"uwangle;": "⦧",
  	"vzigzag;": "⦚",
  	"zigrarr;": "⇝",
  	"andslope;": "⩘",
  	"angmsdaa;": "⦨",
  	"angmsdab;": "⦩",
  	"angmsdac;": "⦪",
  	"angmsdad;": "⦫",
  	"angmsdae;": "⦬",
  	"angmsdaf;": "⦭",
  	"angmsdag;": "⦮",
  	"angmsdah;": "⦯",
  	"angrtvbd;": "⦝",
  	"approxeq;": "≊",
  	"awconint;": "∳",
  	"backcong;": "≌",
  	"barwedge;": "⌅",
  	"bbrktbrk;": "⎶",
  	"bigoplus;": "⨁",
  	"bigsqcup;": "⨆",
  	"biguplus;": "⨄",
  	"bigwedge;": "⋀",
  	"boxminus;": "⊟",
  	"boxtimes;": "⊠",
  	"bsolhsub;": "⟈",
  	"capbrcup;": "⩉",
  	"circledR;": "®",
  	"circledS;": "Ⓢ",
  	"cirfnint;": "⨐",
  	"clubsuit;": "♣",
  	"cupbrcap;": "⩈",
  	"curlyvee;": "⋎",
  	"cwconint;": "∲",
  	"DDotrahd;": "⤑",
  	"doteqdot;": "≑",
  	"DotEqual;": "≐",
  	"dotminus;": "∸",
  	"drbkarow;": "⤐",
  	"dzigrarr;": "⟿",
  	"elinters;": "⏧",
  	"emptyset;": "∅",
  	"eqvparsl;": "⧥",
  	"fpartint;": "⨍",
  	"geqslant;": "⩾",
  	"gesdotol;": "⪄",
  	"gnapprox;": "⪊",
  	"hksearow;": "⤥",
  	"hkswarow;": "⤦",
  	"imagline;": "ℐ",
  	"imagpart;": "ℑ",
  	"infintie;": "⧝",
  	"integers;": "ℤ",
  	"Integral;": "∫",
  	"intercal;": "⊺",
  	"intlarhk;": "⨗",
  	"laemptyv;": "⦴",
  	"ldrushar;": "⥋",
  	"leqslant;": "⩽",
  	"lesdotor;": "⪃",
  	"LessLess;": "⪡",
  	"llcorner;": "⌞",
  	"lnapprox;": "⪉",
  	"lrcorner;": "⌟",
  	"lurdshar;": "⥊",
  	"mapstoup;": "↥",
  	"multimap;": "⊸",
  	"naturals;": "ℕ",
  	"ncongdot;": "⩭̸",
  	"NotEqual;": "≠",
  	"notindot;": "⋵̸",
  	"NotTilde;": "≁",
  	"otimesas;": "⨶",
  	"parallel;": "∥",
  	"PartialD;": "∂",
  	"plusacir;": "⨣",
  	"pointint;": "⨕",
  	"Precedes;": "≺",
  	"precneqq;": "⪵",
  	"precnsim;": "⋨",
  	"profalar;": "⌮",
  	"profline;": "⌒",
  	"profsurf;": "⌓",
  	"raemptyv;": "⦳",
  	"realpart;": "ℜ",
  	"RightTee;": "⊢",
  	"rppolint;": "⨒",
  	"rtriltri;": "⧎",
  	"scpolint;": "⨓",
  	"setminus;": "∖",
  	"shortmid;": "∣",
  	"smeparsl;": "⧤",
  	"sqsubset;": "⊏",
  	"sqsupset;": "⊐",
  	"subseteq;": "⊆",
  	"Succeeds;": "≻",
  	"succneqq;": "⪶",
  	"succnsim;": "⋩",
  	"SuchThat;": "∋",
  	"Superset;": "⊃",
  	"supseteq;": "⊇",
  	"thetasym;": "ϑ",
  	"thicksim;": "∼",
  	"timesbar;": "⨱",
  	"triangle;": "▵",
  	"triminus;": "⨺",
  	"trpezium;": "⏢",
  	"Uarrocir;": "⥉",
  	"ulcorner;": "⌜",
  	"UnderBar;": "_",
  	"urcorner;": "⌝",
  	"varkappa;": "ϰ",
  	"varsigma;": "ς",
  	"vartheta;": "ϑ",
  	"backprime;": "‵",
  	"backsimeq;": "⋍",
  	"Backslash;": "∖",
  	"bigotimes;": "⨂",
  	"CenterDot;": "·",
  	"centerdot;": "·",
  	"checkmark;": "✓",
  	"CircleDot;": "⊙",
  	"complexes;": "ℂ",
  	"Congruent;": "≡",
  	"Coproduct;": "∐",
  	"dotsquare;": "⊡",
  	"DoubleDot;": "¨",
  	"DownArrow;": "↓",
  	"Downarrow;": "⇓",
  	"downarrow;": "↓",
  	"DownBreve;": "̑",
  	"gtrapprox;": "⪆",
  	"gtreqless;": "⋛",
  	"gvertneqq;": "≩︀",
  	"heartsuit;": "♥",
  	"HumpEqual;": "≏",
  	"LeftArrow;": "←",
  	"Leftarrow;": "⇐",
  	"leftarrow;": "←",
  	"LeftFloor;": "⌊",
  	"lesseqgtr;": "⋚",
  	"LessTilde;": "≲",
  	"lvertneqq;": "≨︀",
  	"Mellintrf;": "ℳ",
  	"MinusPlus;": "∓",
  	"ngeqslant;": "⩾̸",
  	"nleqslant;": "⩽̸",
  	"NotCupCap;": "≭",
  	"NotExists;": "∄",
  	"NotSubset;": "⊂⃒",
  	"nparallel;": "∦",
  	"nshortmid;": "∤",
  	"nsubseteq;": "⊈",
  	"nsupseteq;": "⊉",
  	"OverBrace;": "⏞",
  	"pitchfork;": "⋔",
  	"PlusMinus;": "±",
  	"rationals;": "ℚ",
  	"spadesuit;": "♠",
  	"subseteqq;": "⫅",
  	"subsetneq;": "⊊",
  	"supseteqq;": "⫆",
  	"supsetneq;": "⊋",
  	"Therefore;": "∴",
  	"therefore;": "∴",
  	"ThinSpace;": " ",
  	"triangleq;": "≜",
  	"TripleDot;": "⃛",
  	"UnionPlus;": "⊎",
  	"varpropto;": "∝",
  	"Bernoullis;": "ℬ",
  	"circledast;": "⊛",
  	"CirclePlus;": "⊕",
  	"complement;": "∁",
  	"curlywedge;": "⋏",
  	"eqslantgtr;": "⪖",
  	"EqualTilde;": "≂",
  	"Fouriertrf;": "ℱ",
  	"gtreqqless;": "⪌",
  	"ImaginaryI;": "ⅈ",
  	"Laplacetrf;": "ℒ",
  	"LeftVector;": "↼",
  	"lessapprox;": "⪅",
  	"lesseqqgtr;": "⪋",
  	"Lleftarrow;": "⇚",
  	"lmoustache;": "⎰",
  	"longmapsto;": "⟼",
  	"mapstodown;": "↧",
  	"mapstoleft;": "↤",
  	"nLeftarrow;": "⇍",
  	"nleftarrow;": "↚",
  	"NotElement;": "∉",
  	"NotGreater;": "≯",
  	"nsubseteqq;": "⫅̸",
  	"nsupseteqq;": "⫆̸",
  	"precapprox;": "⪷",
  	"Proportion;": "∷",
  	"RightArrow;": "→",
  	"Rightarrow;": "⇒",
  	"rightarrow;": "→",
  	"RightFloor;": "⌋",
  	"rmoustache;": "⎱",
  	"sqsubseteq;": "⊑",
  	"sqsupseteq;": "⊒",
  	"subsetneqq;": "⫋",
  	"succapprox;": "⪸",
  	"supsetneqq;": "⫌",
  	"ThickSpace;": "  ",
  	"TildeEqual;": "≃",
  	"TildeTilde;": "≈",
  	"UnderBrace;": "⏟",
  	"UpArrowBar;": "⤒",
  	"UpTeeArrow;": "↥",
  	"upuparrows;": "⇈",
  	"varepsilon;": "ϵ",
  	"varnothing;": "∅",
  	"backepsilon;": "϶",
  	"blacksquare;": "▪",
  	"circledcirc;": "⊚",
  	"circleddash;": "⊝",
  	"CircleMinus;": "⊖",
  	"CircleTimes;": "⊗",
  	"curlyeqprec;": "⋞",
  	"curlyeqsucc;": "⋟",
  	"diamondsuit;": "♦",
  	"eqslantless;": "⪕",
  	"Equilibrium;": "⇌",
  	"expectation;": "ℰ",
  	"GreaterLess;": "≷",
  	"LeftCeiling;": "⌈",
  	"LessGreater;": "≶",
  	"MediumSpace;": " ",
  	"NotLessLess;": "≪̸",
  	"NotPrecedes;": "⊀",
  	"NotSucceeds;": "⊁",
  	"NotSuperset;": "⊃⃒",
  	"nRightarrow;": "⇏",
  	"nrightarrow;": "↛",
  	"OverBracket;": "⎴",
  	"preccurlyeq;": "≼",
  	"precnapprox;": "⪹",
  	"quaternions;": "ℍ",
  	"RightVector;": "⇀",
  	"Rrightarrow;": "⇛",
  	"RuleDelayed;": "⧴",
  	"SmallCircle;": "∘",
  	"SquareUnion;": "⊔",
  	"straightphi;": "ϕ",
  	"SubsetEqual;": "⊆",
  	"succcurlyeq;": "≽",
  	"succnapprox;": "⪺",
  	"thickapprox;": "≈",
  	"UpDownArrow;": "↕",
  	"Updownarrow;": "⇕",
  	"updownarrow;": "↕",
  	"VerticalBar;": "∣",
  	"blacklozenge;": "⧫",
  	"DownArrowBar;": "⤓",
  	"DownTeeArrow;": "↧",
  	"ExponentialE;": "ⅇ",
  	"exponentiale;": "ⅇ",
  	"GreaterEqual;": "≥",
  	"GreaterTilde;": "≳",
  	"HilbertSpace;": "ℋ",
  	"HumpDownHump;": "≎",
  	"Intersection;": "⋂",
  	"LeftArrowBar;": "⇤",
  	"LeftTeeArrow;": "↤",
  	"LeftTriangle;": "⊲",
  	"LeftUpVector;": "↿",
  	"NotCongruent;": "≢",
  	"NotHumpEqual;": "≏̸",
  	"NotLessEqual;": "≰",
  	"NotLessTilde;": "≴",
  	"Proportional;": "∝",
  	"RightCeiling;": "⌉",
  	"risingdotseq;": "≓",
  	"RoundImplies;": "⥰",
  	"ShortUpArrow;": "↑",
  	"SquareSubset;": "⊏",
  	"triangledown;": "▿",
  	"triangleleft;": "◃",
  	"UnderBracket;": "⎵",
  	"varsubsetneq;": "⊊︀",
  	"varsupsetneq;": "⊋︀",
  	"VerticalLine;": "|",
  	"ApplyFunction;": "⁡",
  	"bigtriangleup;": "△",
  	"blacktriangle;": "▴",
  	"DifferentialD;": "ⅆ",
  	"divideontimes;": "⋇",
  	"DoubleLeftTee;": "⫤",
  	"DoubleUpArrow;": "⇑",
  	"fallingdotseq;": "≒",
  	"hookleftarrow;": "↩",
  	"leftarrowtail;": "↢",
  	"leftharpoonup;": "↼",
  	"LeftTeeVector;": "⥚",
  	"LeftVectorBar;": "⥒",
  	"LessFullEqual;": "≦",
  	"LongLeftArrow;": "⟵",
  	"Longleftarrow;": "⟸",
  	"longleftarrow;": "⟵",
  	"looparrowleft;": "↫",
  	"measuredangle;": "∡",
  	"NotEqualTilde;": "≂̸",
  	"NotTildeEqual;": "≄",
  	"NotTildeTilde;": "≉",
  	"ntriangleleft;": "⋪",
  	"Poincareplane;": "ℌ",
  	"PrecedesEqual;": "⪯",
  	"PrecedesTilde;": "≾",
  	"RightArrowBar;": "⇥",
  	"RightTeeArrow;": "↦",
  	"RightTriangle;": "⊳",
  	"RightUpVector;": "↾",
  	"shortparallel;": "∥",
  	"smallsetminus;": "∖",
  	"SucceedsEqual;": "⪰",
  	"SucceedsTilde;": "≿",
  	"SupersetEqual;": "⊇",
  	"triangleright;": "▹",
  	"UpEquilibrium;": "⥮",
  	"upharpoonleft;": "↿",
  	"varsubsetneqq;": "⫋︀",
  	"varsupsetneqq;": "⫌︀",
  	"VerticalTilde;": "≀",
  	"VeryThinSpace;": " ",
  	"curvearrowleft;": "↶",
  	"DiacriticalDot;": "˙",
  	"doublebarwedge;": "⌆",
  	"DoubleRightTee;": "⊨",
  	"downdownarrows;": "⇊",
  	"DownLeftVector;": "↽",
  	"GreaterGreater;": "⪢",
  	"hookrightarrow;": "↪",
  	"HorizontalLine;": "─",
  	"InvisibleComma;": "⁣",
  	"InvisibleTimes;": "⁢",
  	"LeftDownVector;": "⇃",
  	"leftleftarrows;": "⇇",
  	"LeftRightArrow;": "↔",
  	"Leftrightarrow;": "⇔",
  	"leftrightarrow;": "↔",
  	"leftthreetimes;": "⋋",
  	"LessSlantEqual;": "⩽",
  	"LongRightArrow;": "⟶",
  	"Longrightarrow;": "⟹",
  	"longrightarrow;": "⟶",
  	"looparrowright;": "↬",
  	"LowerLeftArrow;": "↙",
  	"NestedLessLess;": "≪",
  	"NotGreaterLess;": "≹",
  	"NotLessGreater;": "≸",
  	"NotSubsetEqual;": "⊈",
  	"NotVerticalBar;": "∤",
  	"nshortparallel;": "∦",
  	"ntriangleright;": "⋫",
  	"OpenCurlyQuote;": "‘",
  	"ReverseElement;": "∋",
  	"rightarrowtail;": "↣",
  	"rightharpoonup;": "⇀",
  	"RightTeeVector;": "⥛",
  	"RightVectorBar;": "⥓",
  	"ShortDownArrow;": "↓",
  	"ShortLeftArrow;": "←",
  	"SquareSuperset;": "⊐",
  	"TildeFullEqual;": "≅",
  	"trianglelefteq;": "⊴",
  	"upharpoonright;": "↾",
  	"UpperLeftArrow;": "↖",
  	"ZeroWidthSpace;": "​",
  	"bigtriangledown;": "▽",
  	"circlearrowleft;": "↺",
  	"CloseCurlyQuote;": "’",
  	"ContourIntegral;": "∮",
  	"curvearrowright;": "↷",
  	"DoubleDownArrow;": "⇓",
  	"DoubleLeftArrow;": "⇐",
  	"downharpoonleft;": "⇃",
  	"DownRightVector;": "⇁",
  	"leftharpoondown;": "↽",
  	"leftrightarrows;": "⇆",
  	"LeftRightVector;": "⥎",
  	"LeftTriangleBar;": "⧏",
  	"LeftUpTeeVector;": "⥠",
  	"LeftUpVectorBar;": "⥘",
  	"LowerRightArrow;": "↘",
  	"nLeftrightarrow;": "⇎",
  	"nleftrightarrow;": "↮",
  	"NotGreaterEqual;": "≱",
  	"NotGreaterTilde;": "≵",
  	"NotHumpDownHump;": "≎̸",
  	"NotLeftTriangle;": "⋪",
  	"NotSquareSubset;": "⊏̸",
  	"ntrianglelefteq;": "⋬",
  	"OverParenthesis;": "⏜",
  	"RightDownVector;": "⇂",
  	"rightleftarrows;": "⇄",
  	"rightsquigarrow;": "↝",
  	"rightthreetimes;": "⋌",
  	"ShortRightArrow;": "→",
  	"straightepsilon;": "ϵ",
  	"trianglerighteq;": "⊵",
  	"UpperRightArrow;": "↗",
  	"vartriangleleft;": "⊲",
  	"circlearrowright;": "↻",
  	"DiacriticalAcute;": "´",
  	"DiacriticalGrave;": "`",
  	"DiacriticalTilde;": "˜",
  	"DoubleRightArrow;": "⇒",
  	"DownArrowUpArrow;": "⇵",
  	"downharpoonright;": "⇂",
  	"EmptySmallSquare;": "◻",
  	"GreaterEqualLess;": "⋛",
  	"GreaterFullEqual;": "≧",
  	"LeftAngleBracket;": "⟨",
  	"LeftUpDownVector;": "⥑",
  	"LessEqualGreater;": "⋚",
  	"NonBreakingSpace;": " ",
  	"NotPrecedesEqual;": "⪯̸",
  	"NotRightTriangle;": "⋫",
  	"NotSucceedsEqual;": "⪰̸",
  	"NotSucceedsTilde;": "≿̸",
  	"NotSupersetEqual;": "⊉",
  	"ntrianglerighteq;": "⋭",
  	"rightharpoondown;": "⇁",
  	"rightrightarrows;": "⇉",
  	"RightTriangleBar;": "⧐",
  	"RightUpTeeVector;": "⥜",
  	"RightUpVectorBar;": "⥔",
  	"twoheadleftarrow;": "↞",
  	"UnderParenthesis;": "⏝",
  	"UpArrowDownArrow;": "⇅",
  	"vartriangleright;": "⊳",
  	"blacktriangledown;": "▾",
  	"blacktriangleleft;": "◂",
  	"DoubleUpDownArrow;": "⇕",
  	"DoubleVerticalBar;": "∥",
  	"DownLeftTeeVector;": "⥞",
  	"DownLeftVectorBar;": "⥖",
  	"FilledSmallSquare;": "◼",
  	"GreaterSlantEqual;": "⩾",
  	"LeftDoubleBracket;": "⟦",
  	"LeftDownTeeVector;": "⥡",
  	"LeftDownVectorBar;": "⥙",
  	"leftrightharpoons;": "⇋",
  	"LeftTriangleEqual;": "⊴",
  	"NegativeThinSpace;": "​",
  	"NotGreaterGreater;": "≫̸",
  	"NotLessSlantEqual;": "⩽̸",
  	"NotNestedLessLess;": "⪡̸",
  	"NotReverseElement;": "∌",
  	"NotSquareSuperset;": "⊐̸",
  	"NotTildeFullEqual;": "≇",
  	"RightAngleBracket;": "⟩",
  	"rightleftharpoons;": "⇌",
  	"RightUpDownVector;": "⥏",
  	"SquareSubsetEqual;": "⊑",
  	"twoheadrightarrow;": "↠",
  	"VerticalSeparator;": "❘",
  	"blacktriangleright;": "▸",
  	"DownRightTeeVector;": "⥟",
  	"DownRightVectorBar;": "⥗",
  	"LongLeftRightArrow;": "⟷",
  	"Longleftrightarrow;": "⟺",
  	"longleftrightarrow;": "⟷",
  	"NegativeThickSpace;": "​",
  	"NotLeftTriangleBar;": "⧏̸",
  	"PrecedesSlantEqual;": "≼",
  	"ReverseEquilibrium;": "⇋",
  	"RightDoubleBracket;": "⟧",
  	"RightDownTeeVector;": "⥝",
  	"RightDownVectorBar;": "⥕",
  	"RightTriangleEqual;": "⊵",
  	"SquareIntersection;": "⊓",
  	"SucceedsSlantEqual;": "≽",
  	"DoubleLongLeftArrow;": "⟸",
  	"DownLeftRightVector;": "⥐",
  	"LeftArrowRightArrow;": "⇆",
  	"leftrightsquigarrow;": "↭",
  	"NegativeMediumSpace;": "​",
  	"NotGreaterFullEqual;": "≧̸",
  	"NotRightTriangleBar;": "⧐̸",
  	"RightArrowLeftArrow;": "⇄",
  	"SquareSupersetEqual;": "⊒",
  	"CapitalDifferentialD;": "ⅅ",
  	"DoubleLeftRightArrow;": "⇔",
  	"DoubleLongRightArrow;": "⟹",
  	"EmptyVerySmallSquare;": "▫",
  	"NestedGreaterGreater;": "≫",
  	"NotDoubleVerticalBar;": "∦",
  	"NotGreaterSlantEqual;": "⩾̸",
  	"NotLeftTriangleEqual;": "⋬",
  	"NotSquareSubsetEqual;": "⋢",
  	"OpenCurlyDoubleQuote;": "“",
  	"ReverseUpEquilibrium;": "⥯",
  	"CloseCurlyDoubleQuote;": "”",
  	"DoubleContourIntegral;": "∯",
  	"FilledVerySmallSquare;": "▪",
  	"NegativeVeryThinSpace;": "​",
  	"NotPrecedesSlantEqual;": "⋠",
  	"NotRightTriangleEqual;": "⋭",
  	"NotSucceedsSlantEqual;": "⋡",
  	"DiacriticalDoubleAcute;": "˝",
  	"NotSquareSupersetEqual;": "⋣",
  	"NotNestedGreaterGreater;": "⪢̸",
  	"ClockwiseContourIntegral;": "∲",
  	"DoubleLongLeftRightArrow;": "⟺",
  	"CounterClockwiseContourIntegral;": "∳"
  };

  // lazy compute this to make this file tree-shakable for browser
  let maxCRNameLength;
  const decodeHtml = (rawText, asAttr) => {
      let offset = 0;
      const end = rawText.length;
      let decodedText = '';
      function advance(length) {
          offset += length;
          rawText = rawText.slice(length);
      }
      while (offset < end) {
          const head = /&(?:#x?)?/i.exec(rawText);
          if (!head || offset + head.index >= end) {
              const remaining = end - offset;
              decodedText += rawText.slice(0, remaining);
              advance(remaining);
              break;
          }
          // Advance to the "&".
          decodedText += rawText.slice(0, head.index);
          advance(head.index);
          if (head[0] === '&') {
              // Named character reference.
              let name = '';
              let value = undefined;
              if (/[0-9a-z]/i.test(rawText[1])) {
                  if (!maxCRNameLength) {
                      maxCRNameLength = Object.keys(namedCharacterReferences).reduce((max, name) => Math.max(max, name.length), 0);
                  }
                  for (let length = maxCRNameLength; !value && length > 0; --length) {
                      name = rawText.substr(1, length);
                      value = namedCharacterReferences[name];
                  }
                  if (value) {
                      const semi = name.endsWith(';');
                      if (asAttr &&
                          !semi &&
                          /[=a-z0-9]/i.test(rawText[name.length + 1] || '')) {
                          decodedText += '&' + name;
                          advance(1 + name.length);
                      }
                      else {
                          decodedText += value;
                          advance(1 + name.length);
                      }
                  }
                  else {
                      decodedText += '&' + name;
                      advance(1 + name.length);
                  }
              }
              else {
                  decodedText += '&';
                  advance(1);
              }
          }
          else {
              // Numeric character reference.
              const hex = head[0] === '&#x';
              const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;
              const body = pattern.exec(rawText);
              if (!body) {
                  decodedText += head[0];
                  advance(head[0].length);
              }
              else {
                  // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
                  let cp = Number.parseInt(body[1], hex ? 16 : 10);
                  if (cp === 0) {
                      cp = 0xfffd;
                  }
                  else if (cp > 0x10ffff) {
                      cp = 0xfffd;
                  }
                  else if (cp >= 0xd800 && cp <= 0xdfff) {
                      cp = 0xfffd;
                  }
                  else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) ;
                  else if ((cp >= 0x01 && cp <= 0x08) ||
                      cp === 0x0b ||
                      (cp >= 0x0d && cp <= 0x1f) ||
                      (cp >= 0x7f && cp <= 0x9f)) {
                      cp = CCR_REPLACEMENTS[cp] || cp;
                  }
                  decodedText += String.fromCodePoint(cp);
                  advance(body[0].length);
              }
          }
      }
      return decodedText;
  };
  // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state
  const CCR_REPLACEMENTS = {
      0x80: 0x20ac,
      0x82: 0x201a,
      0x83: 0x0192,
      0x84: 0x201e,
      0x85: 0x2026,
      0x86: 0x2020,
      0x87: 0x2021,
      0x88: 0x02c6,
      0x89: 0x2030,
      0x8a: 0x0160,
      0x8b: 0x2039,
      0x8c: 0x0152,
      0x8e: 0x017d,
      0x91: 0x2018,
      0x92: 0x2019,
      0x93: 0x201c,
      0x94: 0x201d,
      0x95: 0x2022,
      0x96: 0x2013,
      0x97: 0x2014,
      0x98: 0x02dc,
      0x99: 0x2122,
      0x9a: 0x0161,
      0x9b: 0x203a,
      0x9c: 0x0153,
      0x9e: 0x017e,
      0x9f: 0x0178
  };

  const isRawTextContainer = /*#__PURE__*/ makeMap('style,iframe,script,noscript', true);
  const parserOptions = {
      isVoidTag,
      isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),
      isPreTag: tag => tag === 'pre',
      decodeEntities:  decodeHtml,
      isBuiltInComponent: (tag) => {
          if (isBuiltInType(tag, `Transition`)) {
              return TRANSITION;
          }
          else if (isBuiltInType(tag, `TransitionGroup`)) {
              return TRANSITION_GROUP;
          }
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
      getNamespace(tag, parent) {
          let ns = parent ? parent.ns : 0 /* HTML */;
          if (parent && ns === 2 /* MATH_ML */) {
              if (parent.tag === 'annotation-xml') {
                  if (tag === 'svg') {
                      return 1 /* SVG */;
                  }
                  if (parent.props.some(a => a.type === 6 /* ATTRIBUTE */ &&
                      a.name === 'encoding' &&
                      a.value != null &&
                      (a.value.content === 'text/html' ||
                          a.value.content === 'application/xhtml+xml'))) {
                      ns = 0 /* HTML */;
                  }
              }
              else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                  tag !== 'mglyph' &&
                  tag !== 'malignmark') {
                  ns = 0 /* HTML */;
              }
          }
          else if (parent && ns === 1 /* SVG */) {
              if (parent.tag === 'foreignObject' ||
                  parent.tag === 'desc' ||
                  parent.tag === 'title') {
                  ns = 0 /* HTML */;
              }
          }
          if (ns === 0 /* HTML */) {
              if (tag === 'svg') {
                  return 1 /* SVG */;
              }
              if (tag === 'math') {
                  return 2 /* MATH_ML */;
              }
          }
          return ns;
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
      getTextMode({ tag, ns }) {
          if (ns === 0 /* HTML */) {
              if (tag === 'textarea' || tag === 'title') {
                  return 1 /* RCDATA */;
              }
              if (isRawTextContainer(tag)) {
                  return 2 /* RAWTEXT */;
              }
          }
          return 0 /* DATA */;
      }
  };

  // Parse inline CSS strings for static style attributes into an object.
  // This is a NodeTransform since it works on the static `style` attribute and
  // converts it into a dynamic equivalent:
  // style="color: red" -> :style='{ "color": "red" }'
  // It is then processed by `transformElement` and included in the generated
  // props.
  const transformStyle = node => {
      if (node.type === 1 /* ELEMENT */) {
          node.props.forEach((p, i) => {
              if (p.type === 6 /* ATTRIBUTE */ && p.name === 'style' && p.value) {
                  // replace p with an expression node
                  node.props[i] = {
                      type: 7 /* DIRECTIVE */,
                      name: `bind`,
                      arg: createSimpleExpression(`style`, true, p.loc),
                      exp: parseInlineCSS(p.value.content, p.loc),
                      modifiers: [],
                      loc: p.loc
                  };
              }
          });
      }
  };
  const parseInlineCSS = (cssText, loc) => {
      const normalized = parseStringStyle(cssText);
      return createSimpleExpression(JSON.stringify(normalized), false, loc, true);
  };

  function createDOMCompilerError(code, loc) {
      return createCompilerError(code, loc,  DOMErrorMessages );
  }
  const DOMErrorMessages = {
      [49 /* X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,
      [50 /* X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,
      [51 /* X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,
      [52 /* X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,
      [53 /* X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [54 /* X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,
      [55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [56 /* X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [57 /* X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,
      [58 /* X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,
      [59 /* X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
  };

  const transformVHtml = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
          context.onError(createDOMCompilerError(49 /* X_V_HTML_NO_EXPRESSION */, loc));
      }
      if (node.children.length) {
          context.onError(createDOMCompilerError(50 /* X_V_HTML_WITH_CHILDREN */, loc));
          node.children.length = 0;
      }
      return {
          props: [
              createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression('', true))
          ]
      };
  };

  const transformVText = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
          context.onError(createDOMCompilerError(51 /* X_V_TEXT_NO_EXPRESSION */, loc));
      }
      if (node.children.length) {
          context.onError(createDOMCompilerError(52 /* X_V_TEXT_WITH_CHILDREN */, loc));
          node.children.length = 0;
      }
      return {
          props: [
              createObjectProperty(createSimpleExpression(`textContent`, true, loc), exp || createSimpleExpression('', true))
          ]
      };
  };

  const transformModel$1 = (dir, node, context) => {
      const baseResult = transformModel(dir, node, context);
      // base transform has errors OR component v-model (only need props)
      if (!baseResult.props.length || node.tagType === 1 /* COMPONENT */) {
          return baseResult;
      }
      if (dir.arg) {
          context.onError(createDOMCompilerError(54 /* X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));
      }
      function checkDuplicatedValue() {
          const value = findProp(node, 'value');
          if (value) {
              context.onError(createDOMCompilerError(56 /* X_V_MODEL_UNNECESSARY_VALUE */, value.loc));
          }
      }
      const { tag } = node;
      const isCustomElement = context.isCustomElement(tag);
      if (tag === 'input' ||
          tag === 'textarea' ||
          tag === 'select' ||
          isCustomElement) {
          let directiveToUse = V_MODEL_TEXT;
          let isInvalidType = false;
          if (tag === 'input' || isCustomElement) {
              const type = findProp(node, `type`);
              if (type) {
                  if (type.type === 7 /* DIRECTIVE */) {
                      // :type="foo"
                      directiveToUse = V_MODEL_DYNAMIC;
                  }
                  else if (type.value) {
                      switch (type.value.content) {
                          case 'radio':
                              directiveToUse = V_MODEL_RADIO;
                              break;
                          case 'checkbox':
                              directiveToUse = V_MODEL_CHECKBOX;
                              break;
                          case 'file':
                              isInvalidType = true;
                              context.onError(createDOMCompilerError(55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));
                              break;
                          default:
                              // text type
                               checkDuplicatedValue();
                              break;
                      }
                  }
              }
              else if (hasDynamicKeyVBind(node)) {
                  // element has bindings with dynamic keys, which can possibly contain
                  // "type".
                  directiveToUse = V_MODEL_DYNAMIC;
              }
              else {
                  // text type
                   checkDuplicatedValue();
              }
          }
          else if (tag === 'select') {
              directiveToUse = V_MODEL_SELECT;
          }
          else {
              // textarea
               checkDuplicatedValue();
          }
          // inject runtime directive
          // by returning the helper symbol via needRuntime
          // the import will replaced a resolveDirective call.
          if (!isInvalidType) {
              baseResult.needRuntime = context.helper(directiveToUse);
          }
      }
      else {
          context.onError(createDOMCompilerError(53 /* X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));
      }
      // native vmodel doesn't need the `modelValue` props since they are also
      // passed to the runtime as `binding.value`. removing it reduces code size.
      baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
          p.key.content === 'modelValue'));
      return baseResult;
  };

  const isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`);
  const isNonKeyModifier = /*#__PURE__*/ makeMap(
  // event propagation management
`stop,prevent,self,`   +
      // system modifiers + exact
      `ctrl,shift,alt,meta,exact,` +
      // mouse
      `middle`);
  // left & right could be mouse or key modifiers based on event type
  const maybeKeyModifier = /*#__PURE__*/ makeMap('left,right');
  const isKeyboardEvent = /*#__PURE__*/ makeMap(`onkeyup,onkeydown,onkeypress`, true);
  const resolveModifiers = (key, modifiers) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
          const modifier = modifiers[i];
          if (isEventOptionModifier(modifier)) {
              // eventOptionModifiers: modifiers for addEventListener() options,
              // e.g. .passive & .capture
              eventOptionModifiers.push(modifier);
          }
          else {
              // runtimeModifiers: modifiers that needs runtime guards
              if (maybeKeyModifier(modifier)) {
                  if (isStaticExp(key)) {
                      if (isKeyboardEvent(key.content)) {
                          keyModifiers.push(modifier);
                      }
                      else {
                          nonKeyModifiers.push(modifier);
                      }
                  }
                  else {
                      keyModifiers.push(modifier);
                      nonKeyModifiers.push(modifier);
                  }
              }
              else {
                  if (isNonKeyModifier(modifier)) {
                      nonKeyModifiers.push(modifier);
                  }
                  else {
                      keyModifiers.push(modifier);
                  }
              }
          }
      }
      return {
          keyModifiers,
          nonKeyModifiers,
          eventOptionModifiers
      };
  };
  const transformClick = (key, event) => {
      const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === 'onclick';
      return isStaticClick
          ? createSimpleExpression(event, true)
          : key.type !== 4 /* SIMPLE_EXPRESSION */
              ? createCompoundExpression([
                  `(`,
                  key,
                  `) === "onClick" ? "${event}" : (`,
                  key,
                  `)`
              ])
              : key;
  };
  const transformOn$1 = (dir, node, context) => {
      return transformOn(dir, node, context, baseResult => {
          const { modifiers } = dir;
          if (!modifiers.length)
              return baseResult;
          let { key, value: handlerExp } = baseResult.props[0];
          const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers);
          // normalize click.right and click.middle since they don't actually fire
          if (nonKeyModifiers.includes('right')) {
              key = transformClick(key, `onContextmenu`);
          }
          if (nonKeyModifiers.includes('middle')) {
              key = transformClick(key, `onMouseup`);
          }
          if (nonKeyModifiers.length) {
              handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
                  handlerExp,
                  JSON.stringify(nonKeyModifiers)
              ]);
          }
          if (keyModifiers.length &&
              // if event name is dynamic, always wrap with keys guard
              (!isStaticExp(key) || isKeyboardEvent(key.content))) {
              handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
                  handlerExp,
                  JSON.stringify(keyModifiers)
              ]);
          }
          if (eventOptionModifiers.length) {
              const modifierPostfix = eventOptionModifiers.map(capitalize).join('');
              key = isStaticExp(key)
                  ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)
                  : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
          }
          return {
              props: [createObjectProperty(key, handlerExp)]
          };
      });
  };

  const transformShow = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
          context.onError(createDOMCompilerError(57 /* X_V_SHOW_NO_EXPRESSION */, loc));
      }
      return {
          props: [],
          needRuntime: context.helper(V_SHOW)
      };
  };

  const warnTransitionChildren = (node, context) => {
      if (node.type === 1 /* ELEMENT */ &&
          node.tagType === 1 /* COMPONENT */) {
          const component = context.isBuiltInComponent(node.tag);
          if (component === TRANSITION) {
              return () => {
                  if (node.children.length && hasMultipleChildren(node)) {
                      context.onError(createDOMCompilerError(58 /* X_TRANSITION_INVALID_CHILDREN */, {
                          start: node.children[0].loc.start,
                          end: node.children[node.children.length - 1].loc.end,
                          source: ''
                      }));
                  }
              };
          }
      }
  };
  function hasMultipleChildren(node) {
      // #1352 filter out potential comment nodes.
      const children = (node.children = node.children.filter(c => c.type !== 3 /* COMMENT */));
      const child = children[0];
      return (children.length !== 1 ||
          child.type === 11 /* FOR */ ||
          (child.type === 9 /* IF */ && child.branches.some(hasMultipleChildren)));
  }

  /**
   * This module is Node-only.
   */
  /**
   * Turn eligible hoisted static trees into stringified static nodes, e.g.
   *
   * ```js
   * const _hoisted_1 = createStaticVNode(`<div class="foo">bar</div>`)
   * ```
   *
   * A single static vnode can contain stringified content for **multiple**
   * consecutive nodes (element and plain text), called a "chunk".
   * `@vue/runtime-dom` will create the content via innerHTML in a hidden
   * container element and insert all the nodes in place. The call must also
   * provide the number of nodes contained in the chunk so that during hydration
   * we can know how many nodes the static vnode should adopt.
   *
   * The optimization scans a children list that contains hoisted nodes, and
   * tries to find the largest chunk of consecutive hoisted nodes before running
   * into a non-hoisted node or the end of the list. A chunk is then converted
   * into a single static vnode and replaces the hoisted expression of the first
   * node in the chunk. Other nodes in the chunk are considered "merged" and
   * therefore removed from both the hoist list and the children array.
   *
   * This optimization is only performed in Node.js.
   */
  const stringifyStatic = (children, context, parent) => {
      if (parent.type === 1 /* ELEMENT */ &&
          (parent.tagType === 1 /* COMPONENT */ ||
              parent.tagType === 3 /* TEMPLATE */)) {
          return;
      }
      let nc = 0; // current node count
      let ec = 0; // current element with binding count
      const currentChunk = [];
      const stringifyCurrentChunk = (currentIndex) => {
          if (nc >= 20 /* NODE_COUNT */ ||
              ec >= 5 /* ELEMENT_WITH_BINDING_COUNT */) {
              // combine all currently eligible nodes into a single static vnode call
              const staticCall = createCallExpression(context.helper(CREATE_STATIC), [
                  JSON.stringify(currentChunk.map(node => stringifyNode(node, context)).join('')),
                  // the 2nd argument indicates the number of DOM nodes this static vnode
                  // will insert / hydrate
                  String(currentChunk.length)
              ]);
              // replace the first node's hoisted expression with the static vnode call
              replaceHoist(currentChunk[0], staticCall, context);
              if (currentChunk.length > 1) {
                  for (let i = 1; i < currentChunk.length; i++) {
                      // for the merged nodes, set their hoisted expression to null
                      replaceHoist(currentChunk[i], null, context);
                  }
                  // also remove merged nodes from children
                  const deleteCount = currentChunk.length - 1;
                  children.splice(currentIndex - currentChunk.length + 1, deleteCount);
                  return deleteCount;
              }
          }
          return 0;
      };
      let i = 0;
      for (; i < children.length; i++) {
          const child = children[i];
          const hoisted = getHoistedNode(child);
          if (hoisted) {
              // presence of hoisted means child must be a stringifiable node
              const node = child;
              const result = analyzeNode(node);
              if (result) {
                  // node is stringifiable, record state
                  nc += result[0];
                  ec += result[1];
                  currentChunk.push(node);
                  continue;
              }
          }
          // we only reach here if we ran into a node that is not stringifiable
          // check if currently analyzed nodes meet criteria for stringification.
          // adjust iteration index
          i -= stringifyCurrentChunk(i);
          // reset state
          nc = 0;
          ec = 0;
          currentChunk.length = 0;
      }
      // in case the last node was also stringifiable
      stringifyCurrentChunk(i);
  };
  const getHoistedNode = (node) => ((node.type === 1 /* ELEMENT */ && node.tagType === 0 /* ELEMENT */) ||
      node.type == 12 /* TEXT_CALL */) &&
      node.codegenNode &&
      node.codegenNode.type === 4 /* SIMPLE_EXPRESSION */ &&
      node.codegenNode.hoisted;
  const dataAriaRE = /^(data|aria)-/;
  const isStringifiableAttr = (name) => {
      return isKnownAttr(name) || dataAriaRE.test(name);
  };
  const replaceHoist = (node, replacement, context) => {
      const hoistToReplace = node.codegenNode.hoisted;
      context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement;
  };
  const isNonStringifiable = /*#__PURE__*/ makeMap(`caption,thead,tr,th,tbody,td,tfoot,colgroup,col`);
  /**
   * for a hoisted node, analyze it and return:
   * - false: bailed (contains runtime constant)
   * - [nc, ec] where
   *   - nc is the number of nodes inside
   *   - ec is the number of element with bindings inside
   */
  function analyzeNode(node) {
      if (node.type === 1 /* ELEMENT */ && isNonStringifiable(node.tag)) {
          return false;
      }
      if (node.type === 12 /* TEXT_CALL */) {
          return [1, 0];
      }
      let nc = 1; // node count
      let ec = node.props.length > 0 ? 1 : 0; // element w/ binding count
      let bailed = false;
      const bail = () => {
          bailed = true;
          return false;
      };
      // TODO: check for cases where using innerHTML will result in different
      // output compared to imperative node insertions.
      // probably only need to check for most common case
      // i.e. non-phrasing-content tags inside `<p>`
      function walk(node) {
          for (let i = 0; i < node.props.length; i++) {
              const p = node.props[i];
              // bail on non-attr bindings
              if (p.type === 6 /* ATTRIBUTE */ && !isStringifiableAttr(p.name)) {
                  return bail();
              }
              if (p.type === 7 /* DIRECTIVE */ && p.name === 'bind') {
                  // bail on non-attr bindings
                  if (p.arg &&
                      (p.arg.type === 8 /* COMPOUND_EXPRESSION */ ||
                          (p.arg.isStatic && !isStringifiableAttr(p.arg.content)))) {
                      return bail();
                  }
              }
          }
          for (let i = 0; i < node.children.length; i++) {
              nc++;
              const child = node.children[i];
              if (child.type === 1 /* ELEMENT */) {
                  if (child.props.length > 0) {
                      ec++;
                  }
                  walk(child);
                  if (bailed) {
                      return false;
                  }
              }
          }
          return true;
      }
      return walk(node) ? [nc, ec] : false;
  }
  function stringifyNode(node, context) {
      if (isString(node)) {
          return node;
      }
      if (isSymbol(node)) {
          return ``;
      }
      switch (node.type) {
          case 1 /* ELEMENT */:
              return stringifyElement(node, context);
          case 2 /* TEXT */:
              return escapeHtml(node.content);
          case 3 /* COMMENT */:
              return `<!--${escapeHtml(node.content)}-->`;
          case 5 /* INTERPOLATION */:
              return escapeHtml(toDisplayString(evaluateConstant(node.content)));
          case 8 /* COMPOUND_EXPRESSION */:
              return escapeHtml(evaluateConstant(node));
          case 12 /* TEXT_CALL */:
              return stringifyNode(node.content, context);
          default:
              // static trees will not contain if/for nodes
              return '';
      }
  }
  function stringifyElement(node, context) {
      let res = `<${node.tag}`;
      for (let i = 0; i < node.props.length; i++) {
          const p = node.props[i];
          if (p.type === 6 /* ATTRIBUTE */) {
              res += ` ${p.name}`;
              if (p.value) {
                  res += `="${escapeHtml(p.value.content)}"`;
              }
          }
          else if (p.type === 7 /* DIRECTIVE */ && p.name === 'bind') {
              // constant v-bind, e.g. :foo="1"
              let evaluated = evaluateConstant(p.exp);
              const arg = p.arg && p.arg.content;
              if (arg === 'class') {
                  evaluated = normalizeClass(evaluated);
              }
              else if (arg === 'style') {
                  evaluated = stringifyStyle(normalizeStyle(evaluated));
              }
              res += ` ${p.arg.content}="${escapeHtml(evaluated)}"`;
          }
      }
      if (context.scopeId) {
          res += ` ${context.scopeId}`;
      }
      res += `>`;
      for (let i = 0; i < node.children.length; i++) {
          res += stringifyNode(node.children[i], context);
      }
      if (!isVoidTag(node.tag)) {
          res += `</${node.tag}>`;
      }
      return res;
  }
  // __UNSAFE__
  // Reason: eval.
  // It's technically safe to eval because only constant expressions are possible
  // here, e.g. `{{ 1 }}` or `{{ 'foo' }}`
  // in addition, constant exps bail on presence of parens so you can't even
  // run JSFuck in here. But we mark it unsafe for security review purposes.
  // (see compiler-core/src/transformExpressions)
  function evaluateConstant(exp) {
      if (exp.type === 4 /* SIMPLE_EXPRESSION */) {
          return new Function(`return ${exp.content}`)();
      }
      else {
          // compound
          let res = ``;
          exp.children.forEach(c => {
              if (isString(c) || isSymbol(c)) {
                  return;
              }
              if (c.type === 2 /* TEXT */) {
                  res += c.content;
              }
              else if (c.type === 5 /* INTERPOLATION */) {
                  res += toDisplayString(evaluateConstant(c.content));
              }
              else {
                  res += evaluateConstant(c);
              }
          });
          return res;
      }
  }

  const ignoreSideEffectTags = (node, context) => {
      if (node.type === 1 /* ELEMENT */ &&
          node.tagType === 0 /* ELEMENT */ &&
          (node.tag === 'script' || node.tag === 'style')) {
          context.onError(createDOMCompilerError(59 /* X_IGNORED_SIDE_EFFECT_TAG */, node.loc));
          context.removeNode();
      }
  };

  const DOMNodeTransforms = [
      transformStyle,
      ...( [warnTransitionChildren] )
  ];
  const DOMDirectiveTransforms = {
      cloak: noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel$1,
      on: transformOn$1,
      show: transformShow
  };
  function compile(template, options = {}) {
      return baseCompile(template, extend({}, parserOptions, options, {
          nodeTransforms: [
              // ignore <script> and <tag>
              // this is not put inside DOMNodeTransforms because that list is used
              // by compiler-ssr to generate vnode fallback branches
              ignoreSideEffectTags,
              ...DOMNodeTransforms,
              ...(options.nodeTransforms || [])
          ],
          directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
          transformHoist:  stringifyStatic
      }));
  }

  const SSR_INTERPOLATE = Symbol(`ssrInterpolate`);
  const SSR_RENDER_VNODE = Symbol(`ssrRenderVNode`);
  const SSR_RENDER_COMPONENT = Symbol(`ssrRenderComponent`);
  const SSR_RENDER_SLOT = Symbol(`ssrRenderSlot`);
  const SSR_RENDER_CLASS = Symbol(`ssrRenderClass`);
  const SSR_RENDER_STYLE = Symbol(`ssrRenderStyle`);
  const SSR_RENDER_ATTRS = Symbol(`ssrRenderAttrs`);
  const SSR_RENDER_ATTR = Symbol(`ssrRenderAttr`);
  const SSR_RENDER_DYNAMIC_ATTR = Symbol(`ssrRenderDynamicAttr`);
  const SSR_RENDER_LIST = Symbol(`ssrRenderList`);
  const SSR_LOOSE_EQUAL = Symbol(`ssrLooseEqual`);
  const SSR_LOOSE_CONTAIN = Symbol(`ssrLooseContain`);
  const SSR_RENDER_DYNAMIC_MODEL = Symbol(`ssrRenderDynamicModel`);
  const SSR_GET_DYNAMIC_MODEL_PROPS = Symbol(`ssrGetDynamicModelProps`);
  const SSR_RENDER_TELEPORT = Symbol(`ssrRenderTeleport`);
  const SSR_RENDER_SUSPENSE = Symbol(`ssrRenderSuspense`);
  const SSR_RESOLVE_CSS_VARS = Symbol(`ssrResolveCssVars`);
  const ssrHelpers = {
      [SSR_INTERPOLATE]: `ssrInterpolate`,
      [SSR_RENDER_VNODE]: `ssrRenderVNode`,
      [SSR_RENDER_COMPONENT]: `ssrRenderComponent`,
      [SSR_RENDER_SLOT]: `ssrRenderSlot`,
      [SSR_RENDER_CLASS]: `ssrRenderClass`,
      [SSR_RENDER_STYLE]: `ssrRenderStyle`,
      [SSR_RENDER_ATTRS]: `ssrRenderAttrs`,
      [SSR_RENDER_ATTR]: `ssrRenderAttr`,
      [SSR_RENDER_DYNAMIC_ATTR]: `ssrRenderDynamicAttr`,
      [SSR_RENDER_LIST]: `ssrRenderList`,
      [SSR_LOOSE_EQUAL]: `ssrLooseEqual`,
      [SSR_LOOSE_CONTAIN]: `ssrLooseContain`,
      [SSR_RENDER_DYNAMIC_MODEL]: `ssrRenderDynamicModel`,
      [SSR_GET_DYNAMIC_MODEL_PROPS]: `ssrGetDynamicModelProps`,
      [SSR_RENDER_TELEPORT]: `ssrRenderTeleport`,
      [SSR_RENDER_SUSPENSE]: `ssrRenderSuspense`,
      [SSR_RESOLVE_CSS_VARS]: `ssrResolveCssVars`
  };
  // Note: these are helpers imported from @vue/server-renderer
  // make sure the names match!
  registerRuntimeHelpers(ssrHelpers);

  // Plugin for the first transform pass, which simply constructs the AST node
  const ssrTransformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, processIf);
  // This is called during the 2nd transform pass to construct the SSR-specific
  // codegen nodes.
  function ssrProcessIf(node, context) {
      const [rootBranch] = node.branches;
      const ifStatement = createIfStatement(rootBranch.condition, processIfBranch(rootBranch, context));
      context.pushStatement(ifStatement);
      let currentIf = ifStatement;
      for (let i = 1; i < node.branches.length; i++) {
          const branch = node.branches[i];
          const branchBlockStatement = processIfBranch(branch, context);
          if (branch.condition) {
              // else-if
              currentIf = currentIf.alternate = createIfStatement(branch.condition, branchBlockStatement);
          }
          else {
              // else
              currentIf.alternate = branchBlockStatement;
          }
      }
      if (!currentIf.alternate) {
          currentIf.alternate = createBlockStatement([
              createCallExpression(`_push`, ['`<!---->`'])
          ]);
      }
  }
  function processIfBranch(branch, context) {
      const { children } = branch;
      const needFragmentWrapper = (children.length !== 1 || children[0].type !== 1 /* ELEMENT */) &&
          // optimize away nested fragments when the only child is a ForNode
          !(children.length === 1 && children[0].type === 11 /* FOR */);
      return processChildrenAsStatement(children, context, needFragmentWrapper);
  }

  // Plugin for the first transform pass, which simply constructs the AST node
  const ssrTransformFor = createStructuralDirectiveTransform('for', processFor);
  // This is called during the 2nd transform pass to construct the SSR-specific
  // codegen nodes.
  function ssrProcessFor(node, context) {
      const needFragmentWrapper = node.children.length !== 1 || node.children[0].type !== 1 /* ELEMENT */;
      const renderLoop = createFunctionExpression(createForLoopParams(node.parseResult));
      renderLoop.body = processChildrenAsStatement(node.children, context, needFragmentWrapper);
      // v-for always renders a fragment
      context.pushStringPart(`<!--[-->`);
      context.pushStatement(createCallExpression(context.helper(SSR_RENDER_LIST), [
          node.source,
          renderLoop
      ]));
      context.pushStringPart(`<!--]-->`);
  }

  const ssrTransformSlotOutlet = (node, context) => {
      if (isSlotOutlet(node)) {
          const { slotName, slotProps } = processSlotOutlet(node, context);
          node.ssrCodegenNode = createCallExpression(context.helper(SSR_RENDER_SLOT), [
              `_ctx.$slots`,
              slotName,
              slotProps || `{}`,
              `null`,
              `_push`,
              `_parent`
          ]);
      }
  };
  function ssrProcessSlotOutlet(node, context) {
      const renderCall = node.ssrCodegenNode;
      // has fallback content
      if (node.children.length) {
          const fallbackRenderFn = createFunctionExpression([]);
          fallbackRenderFn.body = processChildrenAsStatement(node.children, context);
          // _renderSlot(slots, name, props, fallback, ...)
          renderCall.arguments[3] = fallbackRenderFn;
      }
      context.pushStatement(node.ssrCodegenNode);
  }

  function createSSRCompilerError(code, loc) {
      return createCompilerError(code, loc, SSRErrorMessages);
  }
  const SSRErrorMessages = {
      [60 /* X_SSR_CUSTOM_DIRECTIVE_NO_TRANSFORM */]: `Custom directive is missing corresponding SSR transform and will be ignored.`,
      [61 /* X_SSR_UNSAFE_ATTR_NAME */]: `Unsafe attribute name for SSR.`,
      [62 /* X_SSR_NO_TELEPORT_TARGET */]: `Missing the 'to' prop on teleport element.`,
      [63 /* X_SSR_INVALID_AST_NODE */]: `Invalid AST node during SSR transform.`
  };

  // Note: this is a 2nd-pass codegen transform.
  function ssrProcessTeleport(node, context) {
      const targetProp = findProp(node, 'to');
      if (!targetProp) {
          context.onError(createSSRCompilerError(62 /* X_SSR_NO_TELEPORT_TARGET */, node.loc));
          return;
      }
      let target;
      if (targetProp.type === 6 /* ATTRIBUTE */) {
          target =
              targetProp.value && createSimpleExpression(targetProp.value.content, true);
      }
      else {
          target = targetProp.exp;
      }
      if (!target) {
          context.onError(createSSRCompilerError(62 /* X_SSR_NO_TELEPORT_TARGET */, targetProp.loc));
          return;
      }
      const disabledProp = findProp(node, 'disabled', false, true /* allow empty */);
      const disabled = disabledProp
          ? disabledProp.type === 6 /* ATTRIBUTE */
              ? `true`
              : disabledProp.exp || `false`
          : `false`;
      const contentRenderFn = createFunctionExpression([`_push`], undefined, // Body is added later
      true, // newline
      false, // isSlot
      node.loc);
      contentRenderFn.body = processChildrenAsStatement(node.children, context);
      context.pushStatement(createCallExpression(context.helper(SSR_RENDER_TELEPORT), [
          `_push`,
          contentRenderFn,
          target,
          disabled,
          `_parent`
      ]));
  }

  const wipMap = new WeakMap();
  // phase 1
  function ssrTransformSuspense(node, context) {
      return () => {
          if (node.children.length) {
              const wipEntry = {
                  slotsExp: null,
                  wipSlots: []
              };
              wipMap.set(node, wipEntry);
              wipEntry.slotsExp = buildSlots(node, context, (_props, children, loc) => {
                  const fn = createFunctionExpression([], undefined, // no return, assign body later
                  true, // newline
                  false, // suspense slots are not treated as normal slots
                  loc);
                  wipEntry.wipSlots.push({
                      fn,
                      children
                  });
                  return fn;
              }).slots;
          }
      };
  }
  // phase 2
  function ssrProcessSuspense(node, context) {
      // complete wip slots with ssr code
      const wipEntry = wipMap.get(node);
      if (!wipEntry) {
          return;
      }
      const { slotsExp, wipSlots } = wipEntry;
      for (let i = 0; i < wipSlots.length; i++) {
          const { fn, children } = wipSlots[i];
          fn.body = processChildrenAsStatement(children, context);
      }
      // _push(ssrRenderSuspense(slots))
      context.pushStatement(createCallExpression(context.helper(SSR_RENDER_SUSPENSE), [
          `_push`,
          slotsExp
      ]));
  }

  // We need to construct the slot functions in the 1st pass to ensure proper
  // scope tracking, but the children of each slot cannot be processed until
  // the 2nd pass, so we store the WIP slot functions in a weakmap during the 1st
  // pass and complete them in the 2nd pass.
  const wipMap$1 = new WeakMap();
  const componentTypeMap = new WeakMap();
  // ssr component transform is done in two phases:
  // In phase 1. we use `buildSlot` to analyze the children of the component into
  // WIP slot functions (it must be done in phase 1 because `buildSlot` relies on
  // the core transform context).
  // In phase 2. we convert the WIP slots from phase 1 into ssr-specific codegen
  // nodes.
  const ssrTransformComponent = (node, context) => {
      if (node.type !== 1 /* ELEMENT */ ||
          node.tagType !== 1 /* COMPONENT */) {
          return;
      }
      const component = resolveComponentType(node, context, true /* ssr */);
      componentTypeMap.set(node, component);
      if (isSymbol(component)) {
          if (component === SUSPENSE) {
              return ssrTransformSuspense(node, context);
          }
          return; // built-in component: fallthrough
      }
      // Build the fallback vnode-based branch for the component's slots.
      // We need to clone the node into a fresh copy and use the buildSlots' logic
      // to get access to the children of each slot. We then compile them with
      // a child transform pipeline using vnode-based transforms (instead of ssr-
      // based ones), and save the result branch (a ReturnStatement) in an array.
      // The branch is retrieved when processing slots again in ssr mode.
      const vnodeBranches = [];
      const clonedNode = clone(node);
      return function ssrPostTransformComponent() {
          // Using the cloned node, build the normal VNode-based branches (for
          // fallback in case the child is render-fn based). Store them in an array
          // for later use.
          if (clonedNode.children.length) {
              buildSlots(clonedNode, context, (props, children) => {
                  vnodeBranches.push(createVNodeSlotBranch(props, children, context));
                  return createFunctionExpression(undefined);
              });
          }
          const props = node.props.length > 0
              ? // note we are not passing ssr: true here because for components, v-on
                  // handlers should still be passed
                  buildProps(node, context).props || `null`
              : `null`;
          const wipEntries = [];
          wipMap$1.set(node, wipEntries);
          const buildSSRSlotFn = (props, children, loc) => {
              const fn = createFunctionExpression([props || `_`, `_push`, `_parent`, `_scopeId`], undefined, // no return, assign body later
              true, // newline
              true, // isSlot
              loc);
              wipEntries.push({
                  fn,
                  children,
                  // also collect the corresponding vnode branch built earlier
                  vnodeBranch: vnodeBranches[wipEntries.length]
              });
              return fn;
          };
          const slots = node.children.length
              ? buildSlots(node, context, buildSSRSlotFn).slots
              : `null`;
          if (typeof component !== 'string') {
              // dynamic component that resolved to a `resolveDynamicComponent` call
              // expression - since the resolved result may be a plain element (string)
              // or a VNode, handle it with `renderVNode`.
              node.ssrCodegenNode = createCallExpression(context.helper(SSR_RENDER_VNODE), [
                  `_push`,
                  createCallExpression(context.helper(CREATE_VNODE), [
                      component,
                      props,
                      slots
                  ]),
                  `_parent`
              ]);
          }
          else {
              node.ssrCodegenNode = createCallExpression(context.helper(SSR_RENDER_COMPONENT), [component, props, slots, `_parent`]);
          }
      };
  };
  function ssrProcessComponent(node, context) {
      const component = componentTypeMap.get(node);
      if (!node.ssrCodegenNode) {
          // this is a built-in component that fell-through.
          if (component === TELEPORT) {
              return ssrProcessTeleport(node, context);
          }
          else if (component === SUSPENSE) {
              return ssrProcessSuspense(node, context);
          }
          else {
              // real fall-through (e.g. KeepAlive): just render its children.
              processChildren(node.children, context, component === TRANSITION_GROUP);
          }
      }
      else {
          // finish up slot function expressions from the 1st pass.
          const wipEntries = wipMap$1.get(node) || [];
          for (let i = 0; i < wipEntries.length; i++) {
              const { fn, children, vnodeBranch } = wipEntries[i];
              // For each slot, we generate two branches: one SSR-optimized branch and
              // one normal vnode-based branch. The branches are taken based on the
              // presence of the 2nd `_push` argument (which is only present if the slot
              // is called by `_ssrRenderSlot`.
              fn.body = createIfStatement(createSimpleExpression(`_push`, false), processChildrenAsStatement(children, context, false, true /* withSlotScopeId */), vnodeBranch);
          }
          if (typeof component === 'string') {
              // static component
              context.pushStatement(createCallExpression(`_push`, [node.ssrCodegenNode]));
          }
          else {
              // dynamic component (`resolveDynamicComponent` call)
              // the codegen node is a `renderVNode` call
              context.pushStatement(node.ssrCodegenNode);
          }
      }
  }
  const rawOptionsMap = new WeakMap();
  const [baseNodeTransforms, baseDirectiveTransforms] = getBaseTransformPreset(true);
  const vnodeNodeTransforms = [...baseNodeTransforms, ...DOMNodeTransforms];
  const vnodeDirectiveTransforms = {
      ...baseDirectiveTransforms,
      ...DOMDirectiveTransforms
  };
  function createVNodeSlotBranch(props, children, parentContext) {
      // apply a sub-transform using vnode-based transforms.
      const rawOptions = rawOptionsMap.get(parentContext.root);
      const subOptions = {
          ...rawOptions,
          // overwrite with vnode-based transforms
          nodeTransforms: [
              ...vnodeNodeTransforms,
              ...(rawOptions.nodeTransforms || [])
          ],
          directiveTransforms: {
              ...vnodeDirectiveTransforms,
              ...(rawOptions.directiveTransforms || {})
          }
      };
      // wrap the children with a wrapper template for proper children treatment.
      const wrapperNode = {
          type: 1 /* ELEMENT */,
          ns: 0 /* HTML */,
          tag: 'template',
          tagType: 3 /* TEMPLATE */,
          isSelfClosing: false,
          // important: provide v-slot="props" on the wrapper for proper
          // scope analysis
          props: [
              {
                  type: 7 /* DIRECTIVE */,
                  name: 'slot',
                  exp: props,
                  arg: undefined,
                  modifiers: [],
                  loc: locStub
              }
          ],
          children,
          loc: locStub,
          codegenNode: undefined
      };
      subTransform(wrapperNode, subOptions, parentContext);
      return createReturnStatement(children);
  }
  function subTransform(node, options, parentContext) {
      const childRoot = createRoot([node]);
      const childContext = createTransformContext(childRoot, options);
      // this sub transform is for vnode fallback branch so it should be handled
      // like normal render functions
      childContext.ssr = false;
      // inherit parent scope analysis state
      childContext.scopes = { ...parentContext.scopes };
      childContext.identifiers = { ...parentContext.identifiers };
      // traverse
      traverseNode(childRoot, childContext);
      ['helpers', 'components', 'directives', 'imports'].forEach(key => {
          childContext[key].forEach((value) => {
              parentContext[key].add(value);
          });
      });
  }
  function clone(v) {
      if (isArray(v)) {
          return v.map(clone);
      }
      else if (isObject(v)) {
          const res = {};
          for (const key in v) {
              res[key] = clone(v[key]);
          }
          return res;
      }
      else {
          return v;
      }
  }

  // for directives with children overwrite (e.g. v-html & v-text), we need to
  // store the raw children so that they can be added in the 2nd pass.
  const rawChildrenMap = new WeakMap();
  const ssrTransformElement = (node, context) => {
      if (node.type !== 1 /* ELEMENT */ ||
          node.tagType !== 0 /* ELEMENT */) {
          return;
      }
      return function ssrPostTransformElement() {
          // element
          // generate the template literal representing the open tag.
          const openTag = [`<${node.tag}`];
          // some tags need to be passed to runtime for special checks
          const needTagForRuntime = node.tag === 'textarea' || node.tag.indexOf('-') > 0;
          // v-bind="obj" or v-bind:[key] can potentially overwrite other static
          // attrs and can affect final rendering result, so when they are present
          // we need to bail out to full `renderAttrs`
          const hasDynamicVBind = hasDynamicKeyVBind(node);
          if (hasDynamicVBind) {
              const { props } = buildProps(node, context, node.props, true /* ssr */);
              if (props) {
                  const propsExp = createCallExpression(context.helper(SSR_RENDER_ATTRS), [props]);
                  if (node.tag === 'textarea') {
                      const existingText = node.children[0];
                      // If interpolation, this is dynamic <textarea> content, potentially
                      // injected by v-model and takes higher priority than v-bind value
                      if (!existingText || existingText.type !== 5 /* INTERPOLATION */) {
                          // <textarea> with dynamic v-bind. We don't know if the final props
                          // will contain .value, so we will have to do something special:
                          // assign the merged props to a temp variable, and check whether
                          // it contains value (if yes, render is as children).
                          const tempId = `_temp${context.temps++}`;
                          propsExp.arguments = [
                              createAssignmentExpression(createSimpleExpression(tempId, false), props)
                          ];
                          rawChildrenMap.set(node, createCallExpression(context.helper(SSR_INTERPOLATE), [
                              createConditionalExpression(createSimpleExpression(`"value" in ${tempId}`, false), createSimpleExpression(`${tempId}.value`, false), createSimpleExpression(existingText ? existingText.content : ``, true), false)
                          ]));
                      }
                  }
                  else if (node.tag === 'input') {
                      // <input v-bind="obj" v-model>
                      // we need to determine the props to render for the dynamic v-model
                      // and merge it with the v-bind expression.
                      const vModel = findVModel(node);
                      if (vModel) {
                          // 1. save the props (san v-model) in a temp variable
                          const tempId = `_temp${context.temps++}`;
                          const tempExp = createSimpleExpression(tempId, false);
                          propsExp.arguments = [
                              createSequenceExpression([
                                  createAssignmentExpression(tempExp, props),
                                  createCallExpression(context.helper(MERGE_PROPS), [
                                      tempExp,
                                      createCallExpression(context.helper(SSR_GET_DYNAMIC_MODEL_PROPS), [
                                          tempExp,
                                          vModel.exp // model
                                      ])
                                  ])
                              ])
                          ];
                      }
                  }
                  if (needTagForRuntime) {
                      propsExp.arguments.push(`"${node.tag}"`);
                  }
                  openTag.push(propsExp);
              }
          }
          // book keeping static/dynamic class merging.
          let dynamicClassBinding = undefined;
          let staticClassBinding = undefined;
          // all style bindings are converted to dynamic by transformStyle.
          // but we need to make sure to merge them.
          let dynamicStyleBinding = undefined;
          for (let i = 0; i < node.props.length; i++) {
              const prop = node.props[i];
              // special cases with children override
              if (prop.type === 7 /* DIRECTIVE */) {
                  if (prop.name === 'html' && prop.exp) {
                      rawChildrenMap.set(node, prop.exp);
                  }
                  else if (prop.name === 'text' && prop.exp) {
                      node.children = [createInterpolation(prop.exp, prop.loc)];
                  }
                  else if (prop.name === 'slot') {
                      context.onError(createCompilerError(39 /* X_V_SLOT_MISPLACED */, prop.loc));
                  }
                  else if (isTextareaWithValue(node, prop) && prop.exp) {
                      if (!hasDynamicVBind) {
                          node.children = [createInterpolation(prop.exp, prop.loc)];
                      }
                  }
                  else {
                      // Directive transforms.
                      const directiveTransform = context.directiveTransforms[prop.name];
                      if (!directiveTransform) {
                          // no corresponding ssr directive transform found.
                          context.onError(createSSRCompilerError(60 /* X_SSR_CUSTOM_DIRECTIVE_NO_TRANSFORM */, prop.loc));
                      }
                      else if (!hasDynamicVBind) {
                          const { props, ssrTagParts } = directiveTransform(prop, node, context);
                          if (ssrTagParts) {
                              openTag.push(...ssrTagParts);
                          }
                          for (let j = 0; j < props.length; j++) {
                              const { key, value } = props[j];
                              if (isStaticExp(key)) {
                                  let attrName = key.content;
                                  // static key attr
                                  if (attrName === 'class') {
                                      openTag.push(` class="`, (dynamicClassBinding = createCallExpression(context.helper(SSR_RENDER_CLASS), [value])), `"`);
                                  }
                                  else if (attrName === 'style') {
                                      if (dynamicStyleBinding) {
                                          // already has style binding, merge into it.
                                          mergeCall(dynamicStyleBinding, value);
                                      }
                                      else {
                                          openTag.push(` style="`, (dynamicStyleBinding = createCallExpression(context.helper(SSR_RENDER_STYLE), [value])), `"`);
                                      }
                                  }
                                  else {
                                      attrName =
                                          node.tag.indexOf('-') > 0
                                              ? attrName // preserve raw name on custom elements
                                              : propsToAttrMap[attrName] || attrName.toLowerCase();
                                      if (isBooleanAttr(attrName)) {
                                          openTag.push(createConditionalExpression(value, createSimpleExpression(' ' + attrName, true), createSimpleExpression('', true), false /* no newline */));
                                      }
                                      else if (isSSRSafeAttrName(attrName)) {
                                          openTag.push(createCallExpression(context.helper(SSR_RENDER_ATTR), [
                                              key,
                                              value
                                          ]));
                                      }
                                      else {
                                          context.onError(createSSRCompilerError(61 /* X_SSR_UNSAFE_ATTR_NAME */, key.loc));
                                      }
                                  }
                              }
                              else {
                                  // dynamic key attr
                                  // this branch is only encountered for custom directive
                                  // transforms that returns properties with dynamic keys
                                  const args = [key, value];
                                  if (needTagForRuntime) {
                                      args.push(`"${node.tag}"`);
                                  }
                                  openTag.push(createCallExpression(context.helper(SSR_RENDER_DYNAMIC_ATTR), args));
                              }
                          }
                      }
                  }
              }
              else {
                  // special case: value on <textarea>
                  if (node.tag === 'textarea' && prop.name === 'value' && prop.value) {
                      rawChildrenMap.set(node, escapeHtml(prop.value.content));
                  }
                  else if (!hasDynamicVBind) {
                      // static prop
                      if (prop.name === 'class' && prop.value) {
                          staticClassBinding = JSON.stringify(prop.value.content);
                      }
                      openTag.push(` ${prop.name}` +
                          (prop.value ? `="${escapeHtml(prop.value.content)}"` : ``));
                  }
              }
          }
          // handle co-existence of dynamic + static class bindings
          if (dynamicClassBinding && staticClassBinding) {
              mergeCall(dynamicClassBinding, staticClassBinding);
              removeStaticBinding(openTag, 'class');
          }
          if (context.scopeId) {
              openTag.push(` ${context.scopeId}`);
          }
          node.ssrCodegenNode = createTemplateLiteral(openTag);
      };
  };
  function isTextareaWithValue(node, prop) {
      return !!(node.tag === 'textarea' &&
          prop.name === 'bind' &&
          isBindKey(prop.arg, 'value'));
  }
  function mergeCall(call, arg) {
      const existing = call.arguments[0];
      if (existing.type === 17 /* JS_ARRAY_EXPRESSION */) {
          existing.elements.push(arg);
      }
      else {
          call.arguments[0] = createArrayExpression([existing, arg]);
      }
  }
  function removeStaticBinding(tag, binding) {
      const i = tag.findIndex(e => typeof e === 'string' && e.startsWith(` ${binding}=`));
      if (i > -1) {
          tag.splice(i, 1);
      }
  }
  function findVModel(node) {
      return node.props.find(p => p.type === 7 /* DIRECTIVE */ && p.name === 'model' && p.exp);
  }
  function ssrProcessElement(node, context) {
      const isVoidTag = context.options.isVoidTag || NO;
      const elementsToAdd = node.ssrCodegenNode.elements;
      for (let j = 0; j < elementsToAdd.length; j++) {
          context.pushStringPart(elementsToAdd[j]);
      }
      // Handle slot scopeId
      if (context.withSlotScopeId) {
          context.pushStringPart(createSimpleExpression(`_scopeId`, false));
      }
      // close open tag
      context.pushStringPart(`>`);
      const rawChildren = rawChildrenMap.get(node);
      if (rawChildren) {
          context.pushStringPart(rawChildren);
      }
      else if (node.children.length) {
          processChildren(node.children, context);
      }
      if (!isVoidTag(node.tag)) {
          // push closing tag
          context.pushStringPart(`</${node.tag}>`);
      }
  }

  // Because SSR codegen output is completely different from client-side output
  // (e.g. multiple elements can be concatenated into a single template literal
  // instead of each getting a corresponding call), we need to apply an extra
  // transform pass to convert the template AST into a fresh JS AST before
  // passing it to codegen.
  function ssrCodegenTransform(ast, options) {
      const context = createSSRTransformContext(ast, options);
      // inject <style vars> resolution
      // we do this instead of inlining the expression to ensure the vars are
      // only resolved once per render
      if (options.ssrCssVars) {
          const varsExp = processExpression(createSimpleExpression(options.ssrCssVars, false), createTransformContext(createRoot([]), options));
          context.body.push(createCompoundExpression([
              `const _cssVars = _${ssrHelpers[SSR_RESOLVE_CSS_VARS]}(`,
              varsExp,
              options.scopeId ? `, ${JSON.stringify(options.scopeId)}` : ``,
              `)`
          ]));
      }
      const isFragment = ast.children.length > 1 && ast.children.some(c => !isText(c));
      processChildren(ast.children, context, isFragment);
      ast.codegenNode = createBlockStatement(context.body);
      // Finalize helpers.
      // We need to separate helpers imported from 'vue' vs. '@vue/server-renderer'
      ast.ssrHelpers = [
          ...ast.helpers.filter(h => h in ssrHelpers),
          ...context.helpers
      ];
      ast.helpers = ast.helpers.filter(h => !(h in ssrHelpers));
  }
  function createSSRTransformContext(root, options, helpers = new Set(), withSlotScopeId = false) {
      const body = [];
      let currentString = null;
      return {
          root,
          options,
          body,
          helpers,
          withSlotScopeId,
          onError: options.onError ||
              (e => {
                  throw e;
              }),
          helper(name) {
              helpers.add(name);
              return name;
          },
          pushStringPart(part) {
              if (!currentString) {
                  const currentCall = createCallExpression(`_push`);
                  body.push(currentCall);
                  currentString = createTemplateLiteral([]);
                  currentCall.arguments.push(currentString);
              }
              const bufferedElements = currentString.elements;
              const lastItem = bufferedElements[bufferedElements.length - 1];
              if (isString(part) && isString(lastItem)) {
                  bufferedElements[bufferedElements.length - 1] += part;
              }
              else {
                  bufferedElements.push(part);
              }
          },
          pushStatement(statement) {
              // close current string
              currentString = null;
              body.push(statement);
          }
      };
  }
  function createChildContext(parent, withSlotScopeId = parent.withSlotScopeId) {
      // ensure child inherits parent helpers
      return createSSRTransformContext(parent.root, parent.options, parent.helpers, withSlotScopeId);
  }
  function processChildren(children, context, asFragment = false) {
      if (asFragment) {
          context.pushStringPart(`<!--[-->`);
      }
      for (let i = 0; i < children.length; i++) {
          const child = children[i];
          switch (child.type) {
              case 1 /* ELEMENT */:
                  switch (child.tagType) {
                      case 0 /* ELEMENT */:
                          ssrProcessElement(child, context);
                          break;
                      case 1 /* COMPONENT */:
                          ssrProcessComponent(child, context);
                          break;
                      case 2 /* SLOT */:
                          ssrProcessSlotOutlet(child, context);
                          break;
                      case 3 /* TEMPLATE */:
                          // TODO
                          break;
                      default:
                          context.onError(createSSRCompilerError(63 /* X_SSR_INVALID_AST_NODE */, child.loc));
                          // make sure we exhaust all possible types
                          const exhaustiveCheck = child;
                          return exhaustiveCheck;
                  }
                  break;
              case 2 /* TEXT */:
                  context.pushStringPart(escapeHtml(child.content));
                  break;
              case 3 /* COMMENT */:
                  // no need to escape comment here because the AST can only
                  // contain valid comments.
                  context.pushStringPart(`<!--${child.content}-->`);
                  break;
              case 5 /* INTERPOLATION */:
                  context.pushStringPart(createCallExpression(context.helper(SSR_INTERPOLATE), [child.content]));
                  break;
              case 9 /* IF */:
                  ssrProcessIf(child, context);
                  break;
              case 11 /* FOR */:
                  ssrProcessFor(child, context);
                  break;
              case 10 /* IF_BRANCH */:
                  // no-op - handled by ssrProcessIf
                  break;
              case 12 /* TEXT_CALL */:
              case 8 /* COMPOUND_EXPRESSION */:
                  // no-op - these two types can never appear as template child node since
                  // `transformText` is not used during SSR compile.
                  break;
              default:
                  context.onError(createSSRCompilerError(63 /* X_SSR_INVALID_AST_NODE */, child.loc));
                  // make sure we exhaust all possible types
                  const exhaustiveCheck = child;
                  return exhaustiveCheck;
          }
      }
      if (asFragment) {
          context.pushStringPart(`<!--]-->`);
      }
  }
  function processChildrenAsStatement(children, parentContext, asFragment = false, withSlotScopeId = parentContext.withSlotScopeId) {
      const childContext = createChildContext(parentContext, withSlotScopeId);
      processChildren(children, childContext, asFragment);
      return createBlockStatement(childContext.body);
  }

  const ssrTransformModel = (dir, node, context) => {
      const model = dir.exp;
      function checkDuplicatedValue() {
          const value = findProp(node, 'value');
          if (value) {
              context.onError(createDOMCompilerError(56 /* X_V_MODEL_UNNECESSARY_VALUE */, value.loc));
          }
      }
      if (node.tagType === 0 /* ELEMENT */) {
          const res = { props: [] };
          const defaultProps = [
              // default value binding for text type inputs
              createObjectProperty(`value`, model)
          ];
          if (node.tag === 'input') {
              const type = findProp(node, 'type');
              if (type) {
                  const value = findValueBinding(node);
                  if (type.type === 7 /* DIRECTIVE */) {
                      // dynamic type
                      res.ssrTagParts = [
                          createCallExpression(context.helper(SSR_RENDER_DYNAMIC_MODEL), [
                              type.exp,
                              model,
                              value
                          ])
                      ];
                  }
                  else if (type.value) {
                      // static type
                      switch (type.value.content) {
                          case 'radio':
                              res.props = [
                                  createObjectProperty(`checked`, createCallExpression(context.helper(SSR_LOOSE_EQUAL), [
                                      model,
                                      value
                                  ]))
                              ];
                              break;
                          case 'checkbox':
                              res.props = [
                                  createObjectProperty(`checked`, createConditionalExpression(createCallExpression(`Array.isArray`, [model]), createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [
                                      model,
                                      value
                                  ]), model))
                              ];
                              break;
                          case 'file':
                              context.onError(createDOMCompilerError(55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));
                              break;
                          default:
                              checkDuplicatedValue();
                              res.props = defaultProps;
                              break;
                      }
                  }
              }
              else if (hasDynamicKeyVBind(node)) ;
              else {
                  // text type
                  checkDuplicatedValue();
                  res.props = defaultProps;
              }
          }
          else if (node.tag === 'textarea') {
              checkDuplicatedValue();
              node.children = [createInterpolation(model, model.loc)];
          }
          else if (node.tag === 'select') ;
          else {
              context.onError(createDOMCompilerError(53 /* X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));
          }
          return res;
      }
      else {
          // component v-model
          return transformModel(dir, node, context);
      }
  };
  function findValueBinding(node) {
      const valueBinding = findProp(node, 'value');
      return valueBinding
          ? valueBinding.type === 7 /* DIRECTIVE */
              ? valueBinding.exp
              : createSimpleExpression(valueBinding.value.content, true)
          : createSimpleExpression(`null`, false);
  }

  const ssrTransformShow = (dir, node, context) => {
      if (!dir.exp) {
          context.onError(createDOMCompilerError(57 /* X_V_SHOW_NO_EXPRESSION */));
      }
      return {
          props: [
              createObjectProperty(`style`, createConditionalExpression(dir.exp, createSimpleExpression(`null`, false), createObjectExpression([
                  createObjectProperty(`display`, createSimpleExpression(`none`, true))
              ]), false /* no newline */))
          ]
      };
  };

  const hasSingleChild = (node) => node.children.filter(n => n.type !== 3 /* COMMENT */).length === 1;
  const ssrInjectFallthroughAttrs = (node, context) => {
      // _attrs is provided as a function argument.
      // mark it as a known identifier so that it doesn't get prefixed by
      // transformExpression.
      if (node.type === 0 /* ROOT */) {
          context.identifiers._attrs = 1;
      }
      const parent = context.parent;
      if (!parent || parent.type !== 0 /* ROOT */) {
          return;
      }
      if (node.type === 10 /* IF_BRANCH */ && hasSingleChild(node)) {
          injectFallthroughAttrs(node.children[0]);
      }
      else if (hasSingleChild(parent)) {
          injectFallthroughAttrs(node);
      }
  };
  function injectFallthroughAttrs(node) {
      if (node.type === 1 /* ELEMENT */ &&
          (node.tagType === 0 /* ELEMENT */ ||
              node.tagType === 1 /* COMPONENT */) &&
          !findDir(node, 'for')) {
          node.props.push({
              type: 7 /* DIRECTIVE */,
              name: 'bind',
              arg: undefined,
              exp: createSimpleExpression(`_attrs`, false),
              modifiers: [],
              loc: locStub
          });
      }
  }

  const ssrInjectCssVars = (node, context) => {
      if (!context.ssrCssVars) {
          return;
      }
      // _cssVars is initailized once per render function
      // the code is injected in ssrCodegenTrasnform when creating the
      // ssr transform context
      if (node.type === 0 /* ROOT */) {
          context.identifiers._cssVars = 1;
      }
      const parent = context.parent;
      if (!parent || parent.type !== 0 /* ROOT */) {
          return;
      }
      context.helper(SSR_RESOLVE_CSS_VARS);
      if (node.type === 10 /* IF_BRANCH */) {
          for (const child of node.children) {
              injectCssVars(child);
          }
      }
      else {
          injectCssVars(node);
      }
  };
  function injectCssVars(node) {
      if (node.type === 1 /* ELEMENT */ &&
          (node.tagType === 0 /* ELEMENT */ ||
              node.tagType === 1 /* COMPONENT */) &&
          !findDir(node, 'for')) {
          node.props.push({
              type: 7 /* DIRECTIVE */,
              name: 'bind',
              arg: undefined,
              exp: createSimpleExpression(`_cssVars`, false),
              modifiers: [],
              loc: locStub
          });
      }
  }

  function compile$1(template, options = {}) {
      options = {
          ...options,
          // apply DOM-specific parsing options
          ...parserOptions,
          ssr: true,
          scopeId: options.mode === 'function' ? null : options.scopeId,
          // always prefix since compiler-ssr doesn't have size concern
          prefixIdentifiers: true,
          // disable optimizations that are unnecessary for ssr
          cacheHandlers: false,
          hoistStatic: false
      };
      const ast = baseParse(template, options);
      // Save raw options for AST. This is needed when performing sub-transforms
      // on slot vnode branches.
      rawOptionsMap.set(ast, options);
      transform(ast, {
          ...options,
          nodeTransforms: [
              ssrTransformIf,
              ssrTransformFor,
              trackVForSlotScopes,
              transformExpression,
              ssrTransformSlotOutlet,
              ssrInjectFallthroughAttrs,
              ssrInjectCssVars,
              ssrTransformElement,
              ssrTransformComponent,
              trackSlotScopes,
              transformStyle,
              ...(options.nodeTransforms || []) // user transforms
          ],
          directiveTransforms: {
              // reusing core v-bind
              bind: transformBind,
              // model and show has dedicated SSR handling
              model: ssrTransformModel,
              show: ssrTransformShow,
              // the following are ignored during SSR
              on: noopDirectiveTransform,
              cloak: noopDirectiveTransform,
              once: noopDirectiveTransform,
              ...(options.directiveTransforms || {}) // user transforms
          }
      });
      // traverse the template AST and convert into SSR codegen AST
      // by replacing ast.codegenNode.
      ssrCodegenTransform(ast, options);
      return generate(ast, options);
  }

  const targetMap = new WeakMap();
  const effectStack = [];
  let activeEffect;
  const ITERATE_KEY = Symbol( 'iterate' );
  const MAP_KEY_ITERATE_KEY = Symbol( 'Map key iterate' );
  function isEffect(fn) {
      return fn && fn._isEffect === true;
  }
  function effect(fn, options = EMPTY_OBJ) {
      if (isEffect(fn)) {
          fn = fn.raw;
      }
      const effect = createReactiveEffect(fn, options);
      // 计算属性会懒执行
      if (!options.lazy) {
          effect();
      }
      return effect;
  }
  function stop(effect) {
      if (effect.active) {
          cleanup(effect);
          if (effect.options.onStop) {
              effect.options.onStop();
          }
          effect.active = false;
      }
  }
  let uid = 0;
  function createReactiveEffect(fn, options) {
      const effect = function reactiveEffect() {
          if (!effect.active) {
              return options.scheduler ? undefined : fn();
          }
          if (!effectStack.includes(effect)) {
              cleanup(effect);
              try {
                  enableTracking();
                  effectStack.push(effect);
                  activeEffect = effect;
                  return fn();
              }
              finally {
                  effectStack.pop();
                  resetTracking();
                  activeEffect = effectStack[effectStack.length - 1];
              }
          }
      };
      effect.id = uid++;
      effect._isEffect = true;
      effect.active = true;
      effect.raw = fn;
      effect.deps = [];
      effect.options = options;
      return effect;
  }
  function cleanup(effect) {
      const { deps } = effect;
      if (deps.length) {
          for (let i = 0; i < deps.length; i++) {
              deps[i].delete(effect);
          }
          deps.length = 0;
      }
  }
  let shouldTrack = true;
  const trackStack = [];
  function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
  }
  function enableTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = true;
  }
  function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === undefined ? true : last;
  }
  function track(target, type, key) {
      if (!shouldTrack || activeEffect === undefined) {
          return;
      }
      let depsMap = targetMap.get(target);
      if (!depsMap) {
          targetMap.set(target, (depsMap = new Map()));
      }
      let dep = depsMap.get(key);
      if (!dep) {
          depsMap.set(key, (dep = new Set()));
      }
      if (!dep.has(activeEffect)) {
          dep.add(activeEffect);
          activeEffect.deps.push(dep);
          if ( activeEffect.options.onTrack) {
              activeEffect.options.onTrack({
                  effect: activeEffect,
                  target,
                  type,
                  key
              });
          }
      }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
          // never been tracked
          return;
      }
      const effects = new Set();
      const add = (effectsToAdd) => {
          if (effectsToAdd) {
              effectsToAdd.forEach(effect => {
                  if (effect !== activeEffect || effect.options.allowRecurse) {
                      effects.add(effect);
                  }
              });
          }
      };
      if (type === "clear" /* CLEAR */) {
          // collection being cleared
          // trigger all effects for target
          depsMap.forEach(add);
      }
      else if (key === 'length' && isArray(target)) {
          depsMap.forEach((dep, key) => {
              if (key === 'length' || key >= newValue) {
                  add(dep);
              }
          });
      }
      else {
          // schedule runs for SET | ADD | DELETE
          if (key !== void 0) {
              add(depsMap.get(key));
          }
          // also run for iteration key on ADD | DELETE | Map.SET
          switch (type) {
              case "add" /* ADD */:
                  if (!isArray(target)) {
                      add(depsMap.get(ITERATE_KEY));
                      if (isMap(target)) {
                          add(depsMap.get(MAP_KEY_ITERATE_KEY));
                      }
                  }
                  else if (isIntegerKey(key)) {
                      // new index added to array -> length changes
                      add(depsMap.get('length'));
                  }
                  break;
              case "delete" /* DELETE */:
                  if (!isArray(target)) {
                      add(depsMap.get(ITERATE_KEY));
                      if (isMap(target)) {
                          add(depsMap.get(MAP_KEY_ITERATE_KEY));
                      }
                  }
                  break;
              case "set" /* SET */:
                  if (isMap(target)) {
                      add(depsMap.get(ITERATE_KEY));
                  }
                  break;
          }
      }
      const run = (effect) => {
          if ( effect.options.onTrigger) {
              effect.options.onTrigger({
                  effect,
                  target,
                  key,
                  type,
                  newValue,
                  oldValue,
                  oldTarget
              });
          }
          if (effect.options.scheduler) {
              effect.options.scheduler(effect);
          }
          else {
              effect();
          }
      };
      effects.forEach(run);
  }

  const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)
      .map(key => Symbol[key])
      .filter(isSymbol));
  const get = /*#__PURE__*/ createGetter();
  const shallowGet = /*#__PURE__*/ createGetter(false, true);
  const readonlyGet = /*#__PURE__*/ createGetter(true);
  const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);
  const arrayInstrumentations = {};
  ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {
      const method = Array.prototype[key];
      arrayInstrumentations[key] = function (...args) {
          const arr = toRaw(this);
          for (let i = 0, l = this.length; i < l; i++) {
              track(arr, "get" /* GET */, i + '');
          }
          // we run the method using the original args first (which may be reactive)
          const res = method.apply(arr, args);
          if (res === -1 || res === false) {
              // if that didn't work, run it again using raw values.
              return method.apply(arr, args.map(toRaw));
          }
          else {
              return res;
          }
      };
  });
  ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {
      const method = Array.prototype[key];
      arrayInstrumentations[key] = function (...args) {
          pauseTracking();
          const res = method.apply(this, args);
          enableTracking();
          return res;
      };
  });
  function createGetter(isReadonly = false, shallow = false) {
      return function get(target, key, receiver) {
          if (key === "__v_isReactive" /* IS_REACTIVE */) {
              return !isReadonly;
          }
          else if (key === "__v_isReadonly" /* IS_READONLY */) {
              return isReadonly;
          }
          else if (key === "__v_raw" /* RAW */ &&
              receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)) {
              return target;
          }
          const targetIsArray = isArray(target);
          if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
              return Reflect.get(arrayInstrumentations, key, receiver);
          }
          const res = Reflect.get(target, key, receiver);
          const keyIsSymbol = isSymbol(key);
          if (keyIsSymbol
              ? builtInSymbols.has(key)
              : key === `__proto__` || key === `__v_isRef`) {
              return res;
          }
          if (!isReadonly) {
              track(target, "get" /* GET */, key);
          }
          if (shallow) {
              return res;
          }
          if (isRef(res)) {
              // ref unwrapping - does not apply for Array + integer key.
              const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
              return shouldUnwrap ? res.value : res;
          }
          if (isObject(res)) {
              // Convert returned value into a proxy as well. we do the isObject check
              // here to avoid invalid value warning. Also need to lazy access readonly
              // and reactive here to avoid circular dependency.
              return isReadonly ? readonly(res) : reactive(res);
          }
          return res;
      };
  }
  const set = /*#__PURE__*/ createSetter();
  const shallowSet = /*#__PURE__*/ createSetter(true);
  function createSetter(shallow = false) {
      return function set(target, key, value, receiver) {
          const oldValue = target[key];
          if (!shallow) {
              value = toRaw(value);
              if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
                  oldValue.value = value;
                  return true;
              }
          }
          const hadKey = isArray(target) && isIntegerKey(key)
              ? Number(key) < target.length
              : hasOwn(target, key);
          const result = Reflect.set(target, key, value, receiver);
          // don't trigger if target is something up in the prototype chain of original
          if (target === toRaw(receiver)) {
              if (!hadKey) {
                  trigger(target, "add" /* ADD */, key, value);
              }
              else if (hasChanged(value, oldValue)) {
                  trigger(target, "set" /* SET */, key, value, oldValue);
              }
          }
          return result;
      };
  }
  function deleteProperty(target, key) {
      const hadKey = hasOwn(target, key);
      const oldValue = target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
          trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
      }
      return result;
  }
  function has$1(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol(key) || !builtInSymbols.has(key)) {
          track(target, "has" /* HAS */, key);
      }
      return result;
  }
  function ownKeys(target) {
      track(target, "iterate" /* ITERATE */, ITERATE_KEY);
      return Reflect.ownKeys(target);
  }
  const mutableHandlers = {
      get,
      set,
      deleteProperty,
      has: has$1,
      ownKeys
  };
  const readonlyHandlers = {
      get: readonlyGet,
      set(target, key) {
          {
              console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
          }
          return true;
      },
      deleteProperty(target, key) {
          {
              console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
          }
          return true;
      }
  };
  const shallowReactiveHandlers = extend({}, mutableHandlers, {
      get: shallowGet,
      set: shallowSet
  });
  // Props handlers are special in the sense that it should not unwrap top-level
  // refs (in order to allow refs to be explicitly passed down), but should
  // retain the reactivity of the normal readonly object.
  const shallowReadonlyHandlers = extend({}, readonlyHandlers, {
      get: shallowReadonlyGet
  });

  const toReactive = (value) => isObject(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject(value) ? readonly(value) : value;
  const toShallow = (value) => value;
  const getProto = (v) => Reflect.getPrototypeOf(v);
  function get$1(target, key, isReadonly = false, isShallow = false) {
      // #1772: readonly(reactive(Map)) should return readonly + reactive version
      // of the value
      target = target["__v_raw" /* RAW */];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (key !== rawKey) {
          !isReadonly && track(rawTarget, "get" /* GET */, key);
      }
      !isReadonly && track(rawTarget, "get" /* GET */, rawKey);
      const { has } = getProto(rawTarget);
      const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;
      if (has.call(rawTarget, key)) {
          return wrap(target.get(key));
      }
      else if (has.call(rawTarget, rawKey)) {
          return wrap(target.get(rawKey));
      }
  }
  function has$2(key, isReadonly = false) {
      const target = this["__v_raw" /* RAW */];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (key !== rawKey) {
          !isReadonly && track(rawTarget, "has" /* HAS */, key);
      }
      !isReadonly && track(rawTarget, "has" /* HAS */, rawKey);
      return key === rawKey
          ? target.has(key)
          : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly = false) {
      target = target["__v_raw" /* RAW */];
      !isReadonly && track(toRaw(target), "iterate" /* ITERATE */, ITERATE_KEY);
      return Reflect.get(target, 'size', target);
  }
  function add(value) {
      value = toRaw(value);
      const target = toRaw(this);
      const proto = getProto(target);
      const hadKey = proto.has.call(target, value);
      const result = target.add(value);
      if (!hadKey) {
          trigger(target, "add" /* ADD */, value, value);
      }
      return result;
  }
  function set$1(key, value) {
      value = toRaw(value);
      const target = toRaw(this);
      const { has, get } = getProto(target);
      let hadKey = has.call(target, key);
      if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
      }
      else {
          checkIdentityKeys(target, has, key);
      }
      const oldValue = get.call(target, key);
      const result = target.set(key, value);
      if (!hadKey) {
          trigger(target, "add" /* ADD */, key, value);
      }
      else if (hasChanged(value, oldValue)) {
          trigger(target, "set" /* SET */, key, value, oldValue);
      }
      return result;
  }
  function deleteEntry(key) {
      const target = toRaw(this);
      const { has, get } = getProto(target);
      let hadKey = has.call(target, key);
      if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
      }
      else {
          checkIdentityKeys(target, has, key);
      }
      const oldValue = get ? get.call(target, key) : undefined;
      // forward the operation before queueing reactions
      const result = target.delete(key);
      if (hadKey) {
          trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
      }
      return result;
  }
  function clear() {
      const target = toRaw(this);
      const hadItems = target.size !== 0;
      const oldTarget =  isMap(target)
              ? new Map(target)
              : new Set(target)
          ;
      // forward the operation before queueing reactions
      const result = target.clear();
      if (hadItems) {
          trigger(target, "clear" /* CLEAR */, undefined, undefined, oldTarget);
      }
      return result;
  }
  function createForEach(isReadonly, isShallow) {
      return function forEach(callback, thisArg) {
          const observed = this;
          const target = observed["__v_raw" /* RAW */];
          const rawTarget = toRaw(target);
          const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;
          !isReadonly && track(rawTarget, "iterate" /* ITERATE */, ITERATE_KEY);
          return target.forEach((value, key) => {
              // important: make sure the callback is
              // 1. invoked with the reactive map as `this` and 3rd arg
              // 2. the value received should be a corresponding reactive/readonly.
              return callback.call(thisArg, wrap(value), wrap(key), observed);
          });
      };
  }
  function createIterableMethod(method, isReadonly, isShallow) {
      return function (...args) {
          const target = this["__v_raw" /* RAW */];
          const rawTarget = toRaw(target);
          const targetIsMap = isMap(rawTarget);
          const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);
          const isKeyOnly = method === 'keys' && targetIsMap;
          const innerIterator = target[method](...args);
          const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;
          !isReadonly &&
              track(rawTarget, "iterate" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
          // return a wrapped iterator which returns observed versions of the
          // values emitted from the real iterator
          return {
              // iterator protocol
              next() {
                  const { value, done } = innerIterator.next();
                  return done
                      ? { value, done }
                      : {
                          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                          done
                      };
              },
              // iterable protocol
              [Symbol.iterator]() {
                  return this;
              }
          };
      };
  }
  function createReadonlyMethod(type) {
      return function (...args) {
          {
              const key = args[0] ? `on key "${args[0]}" ` : ``;
              console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
          }
          return type === "delete" /* DELETE */ ? false : this;
      };
  }
  const mutableInstrumentations = {
      get(key) {
          return get$1(this, key);
      },
      get size() {
          return size(this);
      },
      has: has$2,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
  };
  const shallowInstrumentations = {
      get(key) {
          return get$1(this, key, false, true);
      },
      get size() {
          return size(this);
      },
      has: has$2,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
  };
  const readonlyInstrumentations = {
      get(key) {
          return get$1(this, key, true);
      },
      get size() {
          return size(this, true);
      },
      has(key) {
          return has$2.call(this, key, true);
      },
      add: createReadonlyMethod("add" /* ADD */),
      set: createReadonlyMethod("set" /* SET */),
      delete: createReadonlyMethod("delete" /* DELETE */),
      clear: createReadonlyMethod("clear" /* CLEAR */),
      forEach: createForEach(true, false)
  };
  const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
  iteratorMethods.forEach(method => {
      mutableInstrumentations[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations[method] = createIterableMethod(method, true, false);
      shallowInstrumentations[method] = createIterableMethod(method, false, true);
  });
  function createInstrumentationGetter(isReadonly, shallow) {
      const instrumentations = shallow
          ? shallowInstrumentations
          : isReadonly
              ? readonlyInstrumentations
              : mutableInstrumentations;
      return (target, key, receiver) => {
          if (key === "__v_isReactive" /* IS_REACTIVE */) {
              return !isReadonly;
          }
          else if (key === "__v_isReadonly" /* IS_READONLY */) {
              return isReadonly;
          }
          else if (key === "__v_raw" /* RAW */) {
              return target;
          }
          return Reflect.get(hasOwn(instrumentations, key) && key in target
              ? instrumentations
              : target, key, receiver);
      };
  }
  const mutableCollectionHandlers = {
      get: createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
      get: createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
      get: createInstrumentationGetter(true, false)
  };
  function checkIdentityKeys(target, has, key) {
      const rawKey = toRaw(key);
      if (rawKey !== key && has.call(target, rawKey)) {
          const type = toRawType(target);
          console.warn(`Reactive ${type} contains both the raw and reactive ` +
              `versions of the same object${type === `Map` ? `as keys` : ``}, ` +
              `which can lead to inconsistencies. ` +
              `Avoid differentiating between the raw and reactive versions ` +
              `of an object and only use the reactive version if possible.`);
      }
  }

  const reactiveMap = new WeakMap();
  const readonlyMap = new WeakMap();
  function targetTypeMap(rawType) {
      switch (rawType) {
          case 'Object':
          case 'Array':
              return 1 /* COMMON */;
          case 'Map':
          case 'Set':
          case 'WeakMap':
          case 'WeakSet':
              return 2 /* COLLECTION */;
          default:
              return 0 /* INVALID */;
      }
  }
  function getTargetType(value) {
      return value["__v_skip" /* SKIP */] || !Object.isExtensible(value)
          ? 0 /* INVALID */
          : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
      // if trying to observe a readonly proxy, return the readonly version.
      if (target && target["__v_isReadonly" /* IS_READONLY */]) {
          return target;
      }
      return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);
  }
  // Return a reactive-copy of the original object, where only the root level
  // properties are reactive, and does NOT unwrap refs nor recursively convert
  // returned properties.
  function shallowReactive(target) {
      return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers);
  }
  function readonly(target) {
      return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers);
  }
  // Return a reactive-copy of the original object, where only the root level
  // properties are readonly, and does NOT unwrap refs nor recursively convert
  // returned properties.
  // This is used for creating the props proxy object for stateful components.
  function shallowReadonly(target) {
      return createReactiveObject(target, true, shallowReadonlyHandlers, readonlyCollectionHandlers);
  }
  function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {
      if (!isObject(target)) {
          {
              console.warn(`value cannot be made reactive: ${String(target)}`);
          }
          return target;
      }
      // target is already a Proxy, return it.
      // exception: calling readonly() on a reactive object
      if (target["__v_raw" /* RAW */] &&
          !(isReadonly && target["__v_isReactive" /* IS_REACTIVE */])) {
          return target;
      }
      // target already has corresponding Proxy
      const proxyMap = isReadonly ? readonlyMap : reactiveMap;
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
          return existingProxy;
      }
      // only a whitelist of value types can be observed.
      const targetType = getTargetType(target);
      if (targetType === 0 /* INVALID */) {
          return target;
      }
      // 代理
      const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);
      proxyMap.set(target, proxy);
      return proxy;
  }
  function isReactive(value) {
      if (isReadonly(value)) {
          return isReactive(value["__v_raw" /* RAW */]);
      }
      return !!(value && value["__v_isReactive" /* IS_REACTIVE */]);
  }
  function isReadonly(value) {
      return !!(value && value["__v_isReadonly" /* IS_READONLY */]);
  }
  function isProxy(value) {
      return isReactive(value) || isReadonly(value);
  }
  function toRaw(observed) {
      return ((observed && toRaw(observed["__v_raw" /* RAW */])) || observed);
  }

  const convert = (val) => isObject(val) ? reactive(val) : val;
  function isRef(r) {
      return Boolean(r && r.__v_isRef === true);
  }
  function ref(value) {
      return createRef(value);
  }
  class RefImpl {
      constructor(_rawValue, _shallow = false) {
          this._rawValue = _rawValue;
          this._shallow = _shallow;
          this.__v_isRef = true;
          this._value = _shallow ? _rawValue : convert(_rawValue);
      }
      get value() {
          track(toRaw(this), "get" /* GET */, 'value');
          return this._value;
      }
      set value(newVal) {
          if (hasChanged(toRaw(newVal), this._rawValue)) {
              this._rawValue = newVal;
              this._value = this._shallow ? newVal : convert(newVal);
              trigger(toRaw(this), "set" /* SET */, 'value', newVal);
          }
      }
  }
  function createRef(rawValue, shallow = false) {
      if (isRef(rawValue)) {
          return rawValue;
      }
      return new RefImpl(rawValue, shallow);
  }
  function unref(ref) {
      return isRef(ref) ? ref.value : ref;
  }
  const shallowUnwrapHandlers = {
      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
          const oldValue = target[key];
          if (isRef(oldValue) && !isRef(value)) {
              oldValue.value = value;
              return true;
          }
          else {
              return Reflect.set(target, key, value, receiver);
          }
      }
  };
  function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs)
          ? objectWithRefs
          : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }

  class ComputedRefImpl {
      constructor(getter, _setter, isReadonly) {
          this._setter = _setter;
          this._dirty = true;
          this.__v_isRef = true;
          this.effect = effect(getter, {
              lazy: true,
              scheduler: () => {
                  if (!this._dirty) {
                      this._dirty = true;
                      trigger(toRaw(this), "set" /* SET */, 'value');
                  }
              }
          });
          this["__v_isReadonly" /* IS_READONLY */] = isReadonly;
      }
      get value() {
          if (this._dirty) {
              this._value = this.effect();
              this._dirty = false;
          }
          track(toRaw(this), "get" /* GET */, 'value');
          return this._value;
      }
      set value(newValue) {
          this._setter(newValue);
      }
  }
  function computed(getterOrOptions) {
      let getter;
      let setter;
      if (isFunction(getterOrOptions)) {
          getter = getterOrOptions;
          setter =  () => {
                  console.warn('Write operation failed: computed value is readonly');
              }
              ;
      }
      else {
          getter = getterOrOptions.get;
          setter = getterOrOptions.set;
      }
      return new ComputedRefImpl(getter, setter, isFunction(getterOrOptions) || !getterOrOptions.set);
  }

  const stack = [];
  function pushWarningContext(vnode) {
      stack.push(vnode);
  }
  function popWarningContext() {
      stack.pop();
  }
  function warn(msg, ...args) {
      // avoid props formatting or warn handler tracking deps that might be mutated
      // during patch, leading to infinite recursion.
      pauseTracking();
      const instance = stack.length ? stack[stack.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
          callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [
              msg + args.join(''),
              instance && instance.proxy,
              trace
                  .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)
                  .join('\n'),
              trace
          ]);
      }
      else {
          const warnArgs = [`[Vue warn]: ${msg}`, ...args];
          /* istanbul ignore if */
          if (trace.length &&
              // avoid spamming console during tests
              !false) {
              warnArgs.push(`\n`, ...formatTrace(trace));
          }
          console.warn(...warnArgs);
      }
      resetTracking();
  }
  function getComponentTrace() {
      let currentVNode = stack[stack.length - 1];
      if (!currentVNode) {
          return [];
      }
      // we can't just use the stack because it will be incomplete during updates
      // that did not start from the root. Re-construct the parent chain using
      // instance parent pointers.
      const normalizedStack = [];
      while (currentVNode) {
          const last = normalizedStack[0];
          if (last && last.vnode === currentVNode) {
              last.recurseCount++;
          }
          else {
              normalizedStack.push({
                  vnode: currentVNode,
                  recurseCount: 0
              });
          }
          const parentInstance = currentVNode.component && currentVNode.component.parent;
          currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
  }
  /* istanbul ignore next */
  function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i) => {
          logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));
      });
      return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
      const close = `>` + postfix;
      return vnode.props
          ? [open, ...formatProps(vnode.props), close]
          : [open + close];
  }
  /* istanbul ignore next */
  function formatProps(props) {
      const res = [];
      const keys = Object.keys(props);
      keys.slice(0, 3).forEach(key => {
          res.push(...formatProp(key, props[key]));
      });
      if (keys.length > 3) {
          res.push(` ...`);
      }
      return res;
  }
  /* istanbul ignore next */
  function formatProp(key, value, raw) {
      if (isString(value)) {
          value = JSON.stringify(value);
          return raw ? value : [`${key}=${value}`];
      }
      else if (typeof value === 'number' ||
          typeof value === 'boolean' ||
          value == null) {
          return raw ? value : [`${key}=${value}`];
      }
      else if (isRef(value)) {
          value = formatProp(key, toRaw(value.value), true);
          return raw ? value : [`${key}=Ref<`, value, `>`];
      }
      else if (isFunction(value)) {
          return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      }
      else {
          value = toRaw(value);
          return raw ? value : [`${key}=`, value];
      }
  }

  const ErrorTypeStrings = {
      ["bc" /* BEFORE_CREATE */]: 'beforeCreate hook',
      ["c" /* CREATED */]: 'created hook',
      ["bm" /* BEFORE_MOUNT */]: 'beforeMount hook',
      ["m" /* MOUNTED */]: 'mounted hook',
      ["bu" /* BEFORE_UPDATE */]: 'beforeUpdate hook',
      ["u" /* UPDATED */]: 'updated',
      ["bum" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',
      ["um" /* UNMOUNTED */]: 'unmounted hook',
      ["a" /* ACTIVATED */]: 'activated hook',
      ["da" /* DEACTIVATED */]: 'deactivated hook',
      ["ec" /* ERROR_CAPTURED */]: 'errorCaptured hook',
      ["rtc" /* RENDER_TRACKED */]: 'renderTracked hook',
      ["rtg" /* RENDER_TRIGGERED */]: 'renderTriggered hook',
      [0 /* SETUP_FUNCTION */]: 'setup function',
      [1 /* RENDER_FUNCTION */]: 'render function',
      [2 /* WATCH_GETTER */]: 'watcher getter',
      [3 /* WATCH_CALLBACK */]: 'watcher callback',
      [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',
      [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',
      [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',
      [7 /* VNODE_HOOK */]: 'vnode hook',
      [8 /* DIRECTIVE_HOOK */]: 'directive hook',
      [9 /* TRANSITION_HOOK */]: 'transition hook',
      [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',
      [11 /* APP_WARN_HANDLER */]: 'app warnHandler',
      [12 /* FUNCTION_REF */]: 'ref function',
      [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',
      [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +
          'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'
  };
  function callWithErrorHandling(fn, instance, type, args) {
      let res;
      try {
          res = args ? fn(...args) : fn();
      }
      catch (err) {
          handleError(err, instance, type);
      }
      return res;
  }
  function callWithAsyncErrorHandling(fn, instance, type, args) {
      if (isFunction(fn)) {
          const res = callWithErrorHandling(fn, instance, type, args);
          if (res && isPromise(res)) {
              res.catch(err => {
                  handleError(err, instance, type);
              });
          }
          return res;
      }
      const values = [];
      for (let i = 0; i < fn.length; i++) {
          values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
      }
      return values;
  }
  function handleError(err, instance, type, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
          let cur = instance.parent;
          // the exposed instance is the render proxy to keep it consistent with 2.x
          const exposedInstance = instance.proxy;
          // in production the hook receives only the error code
          const errorInfo =  ErrorTypeStrings[type] ;
          while (cur) {
              const errorCapturedHooks = cur.ec;
              if (errorCapturedHooks) {
                  for (let i = 0; i < errorCapturedHooks.length; i++) {
                      if (errorCapturedHooks[i](err, exposedInstance, errorInfo)) {
                          return;
                      }
                  }
              }
              cur = cur.parent;
          }
          // app-level handling
          const appErrorHandler = instance.appContext.config.errorHandler;
          if (appErrorHandler) {
              callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);
              return;
          }
      }
      logError(err, type, contextVNode, throwInDev);
  }
  function logError(err, type, contextVNode, throwInDev = true) {
      {
          const info = ErrorTypeStrings[type];
          if (contextVNode) {
              pushWarningContext(contextVNode);
          }
          warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
          if (contextVNode) {
              popWarningContext();
          }
          // crash in dev by default so it's more noticeable
          if (throwInDev) {
              throw err;
          }
          else {
              console.error(err);
          }
      }
  }

  let isFlushing = false;
  let isFlushPending = false;
  const queue = [];
  let flushIndex = 0;
  const pendingPreFlushCbs = [];
  let activePreFlushCbs = null;
  let preFlushIndex = 0;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = Promise.resolve();
  let currentFlushPromise = null;
  let currentPreFlushParentJob = null;
  const RECURSION_LIMIT = 100;
  function nextTick(fn) {
      const p = currentFlushPromise || resolvedPromise;
      return fn ? p.then(fn) : p;
  }
  function queueJob(job) {
      // the dedupe search uses the startIndex argument of Array.includes()
      // by default the search index includes the current job that is being run
      // so it cannot recursively trigger itself again.
      // if the job is a watch() callback, the search will start with a +1 index to
      // allow it recursively trigger itself - it is the user's responsibility to
      // ensure it doesn't end up in an infinite loop.
      if ((!queue.length ||
          !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&
          job !== currentPreFlushParentJob) {
          queue.push(job);
          queueFlush();
      }
  }
  function queueFlush() {
      if (!isFlushing && !isFlushPending) {
          isFlushPending = true;
          currentFlushPromise = resolvedPromise.then(flushJobs);
      }
  }
  function invalidateJob(job) {
      const i = queue.indexOf(job);
      if (i > -1) {
          queue[i] = null;
      }
  }
  function queueCb(cb, activeQueue, pendingQueue, index) {
      if (!isArray(cb)) {
          if (!activeQueue ||
              !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
              pendingQueue.push(cb);
          }
      }
      else {
          // if cb is an array, it is a component lifecycle hook which can only be
          // triggered by a job, which is already deduped in the main queue, so
          // we can skip duplicate check here to improve perf
          pendingQueue.push(...cb);
      }
      queueFlush();
  }
  function queuePreFlushCb(cb) {
      queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
  }
  function queuePostFlushCb(cb) {
      queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
  }
  function flushPreFlushCbs(seen, parentJob = null) {
      if (pendingPreFlushCbs.length) {
          currentPreFlushParentJob = parentJob;
          activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
          pendingPreFlushCbs.length = 0;
          {
              seen = seen || new Map();
          }
          for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
              {
                  checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex]);
              }
              activePreFlushCbs[preFlushIndex]();
          }
          activePreFlushCbs = null;
          preFlushIndex = 0;
          currentPreFlushParentJob = null;
          // recursively flush until it drains
          flushPreFlushCbs(seen, parentJob);
      }
  }
  function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
          const deduped = [...new Set(pendingPostFlushCbs)];
          pendingPostFlushCbs.length = 0;
          // #1947 already has active queue, nested flushPostFlushCbs call
          if (activePostFlushCbs) {
              activePostFlushCbs.push(...deduped);
              return;
          }
          activePostFlushCbs = deduped;
          {
              seen = seen || new Map();
          }
          activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
          for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
              {
                  checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex]);
              }
              activePostFlushCbs[postFlushIndex]();
          }
          activePostFlushCbs = null;
          postFlushIndex = 0;
      }
  }
  const getId = (job) => job.id == null ? Infinity : job.id;
  function flushJobs(seen) {
      isFlushPending = false;
      isFlushing = true;
      {
          seen = seen || new Map();
      }
      flushPreFlushCbs(seen);
      // Sort queue before flush.
      // This ensures that:
      // 1. Components are updated from parent to child. (because parent is always
      //    created before the child so its render effect will have smaller
      //    priority number)
      // 2. If a component is unmounted during a parent component's update,
      //    its update can be skipped.
      // Jobs can never be null before flush starts, since they are only invalidated
      // during execution of another flushed job.
      queue.sort((a, b) => getId(a) - getId(b));
      try {
          for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
              const job = queue[flushIndex];
              if (job) {
                  if (true) {
                      checkRecursiveUpdates(seen, job);
                  }
                  callWithErrorHandling(job, null, 14 /* SCHEDULER */);
              }
          }
      }
      finally {
          flushIndex = 0;
          queue.length = 0;
          flushPostFlushCbs(seen);
          isFlushing = false;
          currentFlushPromise = null;
          // some postFlushCb queued jobs!
          // keep flushing until it drains.
          if (queue.length || pendingPostFlushCbs.length) {
              flushJobs(seen);
          }
      }
  }
  function checkRecursiveUpdates(seen, fn) {
      if (!seen.has(fn)) {
          seen.set(fn, 1);
      }
      else {
          const count = seen.get(fn);
          if (count > RECURSION_LIMIT) {
              throw new Error(`Maximum recursive updates exceeded. ` +
                  `This means you have a reactive effect that is mutating its own ` +
                  `dependencies and thus recursively triggering itself. Possible sources ` +
                  `include component template, render function, updated hook or ` +
                  `watcher source function.`);
          }
          else {
              seen.set(fn, count + 1);
          }
      }
  }

  /* eslint-disable no-restricted-globals */
  let isHmrUpdating = false;
  const hmrDirtyComponents = new Set();
  // Expose the HMR runtime on the global object
  // This makes it entirely tree-shakable without polluting the exports and makes
  // it easier to be used in toolings like vue-loader
  // Note: for a component to be eligible for HMR it also needs the __hmrId option
  // to be set so that its instances can be registered / removed.
  {
      const globalObject = typeof global !== 'undefined'
          ? global
          : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
                  ? window
                  : {};
      globalObject.__VUE_HMR_RUNTIME__ = {
          createRecord: tryWrap(createRecord),
          rerender: tryWrap(rerender),
          reload: tryWrap(reload)
      };
  }
  const map = new Map();
  function registerHMR(instance) {
      const id = instance.type.__hmrId;
      let record = map.get(id);
      if (!record) {
          createRecord(id);
          record = map.get(id);
      }
      record.add(instance);
  }
  function unregisterHMR(instance) {
      map.get(instance.type.__hmrId).delete(instance);
  }
  function createRecord(id) {
      if (map.has(id)) {
          return false;
      }
      map.set(id, new Set());
      return true;
  }
  function rerender(id, newRender) {
      const record = map.get(id);
      if (!record)
          return;
      // Array.from creates a snapshot which avoids the set being mutated during
      // updates
      Array.from(record).forEach(instance => {
          if (newRender) {
              instance.render = newRender;
          }
          instance.renderCache = [];
          // this flag forces child components with slot content to update
          isHmrUpdating = true;
          instance.update();
          isHmrUpdating = false;
      });
  }
  function reload(id, newComp) {
      const record = map.get(id);
      if (!record)
          return;
      // Array.from creates a snapshot which avoids the set being mutated during
      // updates
      Array.from(record).forEach(instance => {
          const comp = instance.type;
          if (!hmrDirtyComponents.has(comp)) {
              // 1. Update existing comp definition to match new one
              newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp;
              extend(comp, newComp);
              for (const key in comp) {
                  if (!(key in newComp)) {
                      delete comp[key];
                  }
              }
              // 2. Mark component dirty. This forces the renderer to replace the component
              // on patch.
              hmrDirtyComponents.add(comp);
              // 3. Make sure to unmark the component after the reload.
              queuePostFlushCb(() => {
                  hmrDirtyComponents.delete(comp);
              });
          }
          if (instance.parent) {
              // 4. Force the parent instance to re-render. This will cause all updated
              // components to be unmounted and re-mounted. Queue the update so that we
              // don't end up forcing the same parent to re-render multiple times.
              queueJob(instance.parent.update);
          }
          else if (instance.appContext.reload) {
              // root instance mounted via createApp() has a reload method
              instance.appContext.reload();
          }
          else if (typeof window !== 'undefined') {
              // root instance inside tree created via raw render(). Force reload.
              window.location.reload();
          }
          else {
              console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
          }
      });
  }
  function tryWrap(fn) {
      return (id, arg) => {
          try {
              return fn(id, arg);
          }
          catch (e) {
              console.error(e);
              console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +
                  `Full reload required.`);
          }
      };
  }

  function emit(instance, event, ...args) {
      const props = instance.vnode.props || EMPTY_OBJ;
      {
          const { emitsOptions, propsOptions: [propsOptions] } = instance;
          if (emitsOptions) {
              if (!(event in emitsOptions)) {
                  if (!propsOptions || !(`on` + capitalize(event) in propsOptions)) {
                      warn(`Component emitted event "${event}" but it is neither declared in ` +
                          `the emits option nor as an "on${capitalize(event)}" prop.`);
                  }
              }
              else {
                  const validator = emitsOptions[event];
                  if (isFunction(validator)) {
                      const isValid = validator(...args);
                      if (!isValid) {
                          warn(`Invalid event arguments: event validation failed for event "${event}".`);
                      }
                  }
              }
          }
      }
      let handlerName = `on${capitalize(event)}`;
      let handler = props[handlerName];
      // for v-model update:xxx events, also trigger kebab-case equivalent
      // for props passed via kebab-case
      if (!handler && event.startsWith('update:')) {
          handlerName = `on${capitalize(hyphenate(event))}`;
          handler = props[handlerName];
      }
      if (!handler) {
          handler = props[handlerName + `Once`];
          if (!instance.emitted) {
              (instance.emitted = {})[handlerName] = true;
          }
          else if (instance.emitted[handlerName]) {
              return;
          }
      }
      if (handler) {
          callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
      }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const appId = appContext.app ? appContext.app._uid : -1;
      const cache = comp.__emits || (comp.__emits = {});
      const cached = cache[appId];
      if (cached !== undefined) {
          return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      // apply mixin/extends props
      let hasExtends = false;
      if ( !isFunction(comp)) {
          const extendEmits = (raw) => {
              hasExtends = true;
              extend(normalized, normalizeEmitsOptions(raw, appContext, true));
          };
          if (!asMixin && appContext.mixins.length) {
              appContext.mixins.forEach(extendEmits);
          }
          if (comp.extends) {
              extendEmits(comp.extends);
          }
          if (comp.mixins) {
              comp.mixins.forEach(extendEmits);
          }
      }
      if (!raw && !hasExtends) {
          return (cache[appId] = null);
      }
      if (isArray(raw)) {
          raw.forEach(key => (normalized[key] = null));
      }
      else {
          extend(normalized, raw);
      }
      return (cache[appId] = normalized);
  }
  // Check if an incoming prop key is a declared emit event listener.
  // e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
  // both considered matched listeners.
  function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
          return false;
      }
      key = key.replace(/Once$/, '');
      return (hasOwn(options, key[2].toLowerCase() + key.slice(3)) ||
          hasOwn(options, key.slice(2)));
  }

  // mark the current rendering instance for asset resolution (e.g.
  // resolveComponent, resolveDirective) during render
  let currentRenderingInstance = null;
  function setCurrentRenderingInstance(instance) {
      currentRenderingInstance = instance;
  }
  // dev only flag to track whether $attrs was used during render.
  // If $attrs was used during render then the warning for failed attrs
  // fallthrough can be suppressed.
  let accessedAttrs = false;
  function markAttrsAccessed() {
      accessedAttrs = true;
  }
  function renderComponentRoot(instance) {
      const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx } = instance;
      let result;
      currentRenderingInstance = instance;
      {
          accessedAttrs = false;
      }
      try {
          let fallthroughAttrs;
          if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
              // withProxy is a proxy with a different `has` trap only for
              // runtime-compiled render functions using `with` block.
              const proxyToUse = withProxy || proxy;
              result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
              fallthroughAttrs = attrs;
          }
          else {
              // functional
              const render = Component;
              // in dev, mark attrs accessed if optional props (attrs === props)
              if (true && attrs === props) {
                  markAttrsAccessed();
              }
              result = normalizeVNode(render.length > 1
                  ? render(props, true
                      ? {
                          get attrs() {
                              markAttrsAccessed();
                              return attrs;
                          },
                          slots,
                          emit
                      }
                      : { attrs, slots, emit })
                  : render(props, null /* we know it doesn't need it */));
              fallthroughAttrs = Component.props
                  ? attrs
                  : getFunctionalFallthrough(attrs);
          }
          // attr merging
          // in dev mode, comments are preserved, and it's possible for a template
          // to have comments along side the root element which makes it a fragment
          let root = result;
          let setRoot = undefined;
          if (true) {
              ;
              [root, setRoot] = getChildRoot(result);
          }
          if (Component.inheritAttrs !== false && fallthroughAttrs) {
              const keys = Object.keys(fallthroughAttrs);
              const { shapeFlag } = root;
              if (keys.length) {
                  if (shapeFlag & 1 /* ELEMENT */ ||
                      shapeFlag & 6 /* COMPONENT */) {
                      if (propsOptions && keys.some(isModelListener)) {
                          // If a v-model listener (onUpdate:xxx) has a corresponding declared
                          // prop, it indicates this component expects to handle v-model and
                          // it should not fallthrough.
                          // related: #1543, #1643, #1989
                          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                      }
                      root = cloneVNode(root, fallthroughAttrs);
                  }
                  else if (true && !accessedAttrs && root.type !== Comment) {
                      const allAttrs = Object.keys(attrs);
                      const eventAttrs = [];
                      const extraAttrs = [];
                      for (let i = 0, l = allAttrs.length; i < l; i++) {
                          const key = allAttrs[i];
                          if (isOn(key)) {
                              // ignore v-model handlers when they fail to fallthrough
                              if (!isModelListener(key)) {
                                  // remove `on`, lowercase first letter to reflect event casing
                                  // accurately
                                  eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                              }
                          }
                          else {
                              extraAttrs.push(key);
                          }
                      }
                      if (extraAttrs.length) {
                          warn(`Extraneous non-props attributes (` +
                              `${extraAttrs.join(', ')}) ` +
                              `were passed to component but could not be automatically inherited ` +
                              `because component renders fragment or text root nodes.`);
                      }
                      if (eventAttrs.length) {
                          warn(`Extraneous non-emits event listeners (` +
                              `${eventAttrs.join(', ')}) ` +
                              `were passed to component but could not be automatically inherited ` +
                              `because component renders fragment or text root nodes. ` +
                              `If the listener is intended to be a component custom event listener only, ` +
                              `declare it using the "emits" option.`);
                      }
                  }
              }
          }
          // inherit directives
          if (vnode.dirs) {
              if (true && !isElementRoot(root)) {
                  warn(`Runtime directive used on component with non-element root node. ` +
                      `The directives will not function as intended.`);
              }
              root.dirs = vnode.dirs;
          }
          // inherit transition data
          if (vnode.transition) {
              if (true && !isElementRoot(root)) {
                  warn(`Component inside <Transition> renders non-element root node ` +
                      `that cannot be animated.`);
              }
              root.transition = vnode.transition;
          }
          if (true && setRoot) {
              setRoot(root);
          }
          else {
              result = root;
          }
      }
      catch (err) {
          handleError(err, instance, 1 /* RENDER_FUNCTION */);
          result = createVNode(Comment);
      }
      currentRenderingInstance = null;
      return result;
  }
  /**
   * dev only
   * In dev mode, template root level comments are rendered, which turns the
   * template into a fragment root, but we need to locate the single element
   * root for attrs and scope id processing.
   */
  const getChildRoot = (vnode) => {
      if (vnode.type !== Fragment) {
          return [vnode, undefined];
      }
      const rawChildren = vnode.children;
      const dynamicChildren = vnode.dynamicChildren;
      const childRoot = filterSingleRoot(rawChildren);
      if (!childRoot) {
          return [vnode, undefined];
      }
      const index = rawChildren.indexOf(childRoot);
      const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
      const setRoot = (updatedRoot) => {
          rawChildren[index] = updatedRoot;
          if (dynamicIndex > -1) {
              dynamicChildren[dynamicIndex] = updatedRoot;
          }
          else if (dynamicChildren && updatedRoot.patchFlag > 0) {
              dynamicChildren.push(updatedRoot);
          }
      };
      return [normalizeVNode(childRoot), setRoot];
  };
  /**
   * dev only
   */
  function filterSingleRoot(children) {
      const filtered = children.filter(child => {
          return !(isVNode(child) &&
              child.type === Comment &&
              child.children !== 'v-if');
      });
      return filtered.length === 1 && isVNode(filtered[0]) ? filtered[0] : null;
  }
  const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
          if (key === 'class' || key === 'style' || isOn(key)) {
              (res || (res = {}))[key] = attrs[key];
          }
      }
      return res;
  };
  const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
          if (!isModelListener(key) || !(key.slice(9) in props)) {
              res[key] = attrs[key];
          }
      }
      return res;
  };
  const isElementRoot = (vnode) => {
      return (vnode.shapeFlag & 6 /* COMPONENT */ ||
          vnode.shapeFlag & 1 /* ELEMENT */ ||
          vnode.type === Comment // potential v-if branch switch
      );
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      // Parent component's render function was hot-updated. Since this may have
      // caused the child component's slots content to have changed, we need to
      // force the child to update as well.
      if ( (prevChildren || nextChildren) && isHmrUpdating) {
          return true;
      }
      // force child update for runtime directive or transition on component vnode.
      if (nextVNode.dirs || nextVNode.transition) {
          return true;
      }
      if (optimized && patchFlag > 0) {
          if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {
              // slot content that references values that might have changed,
              // e.g. in a v-for
              return true;
          }
          if (patchFlag & 16 /* FULL_PROPS */) {
              if (!prevProps) {
                  return !!nextProps;
              }
              // presence of this flag indicates props are always non-null
              return hasPropsChanged(prevProps, nextProps, emits);
          }
          else if (patchFlag & 8 /* PROPS */) {
              const dynamicProps = nextVNode.dynamicProps;
              for (let i = 0; i < dynamicProps.length; i++) {
                  const key = dynamicProps[i];
                  if (nextProps[key] !== prevProps[key] &&
                      !isEmitListener(emits, key)) {
                      return true;
                  }
              }
          }
      }
      else {
          // this path is only taken by manually written render functions
          // so presence of any children leads to a forced update
          if (prevChildren || nextChildren) {
              if (!nextChildren || !nextChildren.$stable) {
                  return true;
              }
          }
          if (prevProps === nextProps) {
              return false;
          }
          if (!prevProps) {
              return !!nextProps;
          }
          if (!nextProps) {
              return true;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
          return true;
      }
      for (let i = 0; i < nextKeys.length; i++) {
          const key = nextKeys[i];
          if (nextProps[key] !== prevProps[key] &&
              !isEmitListener(emitsOptions, key)) {
              return true;
          }
      }
      return false;
  }
  function updateHOCHostEl({ vnode, parent }, el // HostNode
  ) {
      while (parent && parent.subTree === vnode) {
          (vnode = parent.vnode).el = el;
          parent = parent.parent;
      }
  }

  const isSuspense = (type) => type.__isSuspense;
  function normalizeSuspenseChildren(vnode) {
      const { shapeFlag, children } = vnode;
      let content;
      let fallback;
      if (shapeFlag & 32 /* SLOTS_CHILDREN */) {
          content = normalizeSuspenseSlot(children.default);
          fallback = normalizeSuspenseSlot(children.fallback);
      }
      else {
          content = normalizeSuspenseSlot(children);
          fallback = normalizeVNode(null);
      }
      return {
          content,
          fallback
      };
  }
  function normalizeSuspenseSlot(s) {
      if (isFunction(s)) {
          s = s();
      }
      if (isArray(s)) {
          const singleChild = filterSingleRoot(s);
          if ( !singleChild) {
              warn(`<Suspense> slots expect a single root node.`);
          }
          s = singleChild;
      }
      return normalizeVNode(s);
  }
  function queueEffectWithSuspense(fn, suspense) {
      if (suspense && suspense.pendingBranch) {
          if (isArray(fn)) {
              suspense.effects.push(...fn);
          }
          else {
              suspense.effects.push(fn);
          }
      }
      else {
          queuePostFlushCb(fn);
      }
  }

  let isRenderingCompiledSlot = 0;
  const setCompiledSlotRendering = (n) => (isRenderingCompiledSlot += n);

  /**
   * Wrap a slot function to memoize current rendering instance
   * @private
   */
  function withCtx(fn, ctx = currentRenderingInstance) {
      if (!ctx)
          return fn;
      const renderFnWithContext = (...args) => {
          // If a user calls a compiled slot inside a template expression (#1745), it
          // can mess up block tracking, so by default we need to push a null block to
          // avoid that. This isn't necessary if rendering a compiled `<slot>`.
          if (!isRenderingCompiledSlot) {
              openBlock(true /* null block that disables tracking */);
          }
          const owner = currentRenderingInstance;
          setCurrentRenderingInstance(ctx);
          const res = fn(...args);
          setCurrentRenderingInstance(owner);
          if (!isRenderingCompiledSlot) {
              closeBlock();
          }
          return res;
      };
      renderFnWithContext._c = true;
      return renderFnWithContext;
  }

  // SFC scoped style ID management.
  let currentScopeId = null;

  const isTeleport = (type) => type.__isTeleport;

  const NULL_DYNAMIC_COMPONENT = Symbol();

  const Fragment = Symbol( 'Fragment' );
  const Text = Symbol( 'Text' );
  const Comment = Symbol( 'Comment' );
  const Static = Symbol( 'Static' );
  // Since v-if and v-for are the two possible ways node structure can dynamically
  // change, once we consider v-if branches and each v-for fragment a block, we
  // can divide a template into nested blocks, and within each block the node
  // structure would be stable. This allows us to skip most children diffing
  // and only worry about the dynamic nodes (indicated by patch flags).
  const blockStack = [];
  let currentBlock = null;
  /**
   * Open a block.
   * This must be called before `createBlock`. It cannot be part of `createBlock`
   * because the children of the block are evaluated before `createBlock` itself
   * is called. The generated code typically looks like this:
   *
   * ```js
   * function render() {
   *   return (openBlock(),createBlock('div', null, [...]))
   * }
   * ```
   * disableTracking is true when creating a v-for fragment block, since a v-for
   * fragment always diffs its children.
   *
   * @private
   */
  function openBlock(disableTracking = false) {
      blockStack.push((currentBlock = disableTracking ? null : []));
  }
  function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
  }
  function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
      if (
          n2.shapeFlag & 6 /* COMPONENT */ &&
          hmrDirtyComponents.has(n2.type)) {
          // HMR only: if the component has been hot-updated, force a reload.
          return false;
      }
      return n1.type === n2.type && n1.key === n2.key;
  }
  const createVNodeWithArgsTransform = (...args) => {
      return _createVNode(...( args));
  };
  const InternalObjectKey = `__vInternal`;
  const normalizeKey = ({ key }) => key != null ? key : null;
  const normalizeRef = ({ ref }) => {
      return (ref != null
          ? isArray(ref)
              ? ref
              : { i: currentRenderingInstance, r: ref }
          : null);
  };
  const createVNode = ( createVNodeWithArgsTransform
      );
  function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type || type === NULL_DYNAMIC_COMPONENT) {
          if ( !type) {
              warn(`Invalid vnode type when creating vnode: ${type}.`);
          }
          type = Comment;
      }
      if (isVNode(type)) {
          // createVNode receiving an existing vnode. This happens in cases like
          // <component :is="vnode"/>
          // #2078 make sure to merge refs during the clone instead of overwriting it
          const cloned = cloneVNode(type, props, true /* mergeRef: true */);
          if (children) {
              normalizeChildren(cloned, children);
          }
          return cloned;
      }
      // class component normalization.
      if (isClassComponent(type)) {
          type = type.__vccOpts;
      }
      // class & style normalization.
      if (props) {
          // for reactive or proxy objects, we need to clone it to enable mutation.
          if (isProxy(props) || InternalObjectKey in props) {
              props = extend({}, props);
          }
          let { class: klass, style } = props;
          if (klass && !isString(klass)) {
              props.class = normalizeClass(klass);
          }
          if (isObject(style)) {
              // reactive state objects need to be cloned since they are likely to be
              // mutated
              if (isProxy(style) && !isArray(style)) {
                  style = extend({}, style);
              }
              props.style = normalizeStyle(style);
          }
      }
      // encode the vnode type information into a bitmap
      const shapeFlag = isString(type)
          ? 1 /* ELEMENT */
          :  isSuspense(type)
              ? 128 /* SUSPENSE */
              : isTeleport(type)
                  ? 64 /* TELEPORT */
                  : isObject(type)
                      ? 4 /* STATEFUL_COMPONENT */
                      : isFunction(type)
                          ? 2 /* FUNCTIONAL_COMPONENT */
                          : 0;
      if ( shapeFlag & 4 /* STATEFUL_COMPONENT */ && isProxy(type)) {
          type = toRaw(type);
          warn(`Vue received a Component which was made a reactive object. This can ` +
              `lead to unnecessary performance overhead, and should be avoided by ` +
              `marking the component with \`markRaw\` or using \`shallowRef\` ` +
              `instead of \`ref\`.`, `\nComponent that was made reactive: `, type);
      }
      const vnode = {
          __v_isVNode: true,
          ["__v_skip" /* SKIP */]: true,
          type,
          props,
          key: props && normalizeKey(props),
          ref: props && normalizeRef(props),
          scopeId: currentScopeId,
          children: null,
          component: null,
          suspense: null,
          ssContent: null,
          ssFallback: null,
          dirs: null,
          transition: null,
          el: null,
          anchor: null,
          target: null,
          targetAnchor: null,
          staticCount: 0,
          shapeFlag,
          patchFlag,
          dynamicProps,
          dynamicChildren: null,
          appContext: null
      };
      // validate key
      if ( vnode.key !== vnode.key) {
          warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
      }
      normalizeChildren(vnode, children);
      // normalize suspense children
      if ( shapeFlag & 128 /* SUSPENSE */) {
          const { content, fallback } = normalizeSuspenseChildren(vnode);
          vnode.ssContent = content;
          vnode.ssFallback = fallback;
      }
      if (
          // avoid a block node from tracking itself
          !isBlockNode &&
          // has current parent block
          currentBlock &&
          // presence of a patch flag indicates this node needs patching on updates.
          // component nodes also should always be patched, because even if the
          // component doesn't need to update, it needs to persist the instance on to
          // the next vnode so that it can be properly unmounted later.
          (patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&
          // the EVENTS flag is only for hydration and if it is the only flag, the
          // vnode should not be considered dynamic due to handler caching.
          patchFlag !== 32 /* HYDRATE_EVENTS */) {
          currentBlock.push(vnode);
      }
      return vnode;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false) {
      // This is intentionally NOT using spread or extend to avoid the runtime
      // key enumeration cost.
      const { props, ref, patchFlag } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      return {
          __v_isVNode: true,
          ["__v_skip" /* SKIP */]: true,
          type: vnode.type,
          props: mergedProps,
          key: mergedProps && normalizeKey(mergedProps),
          ref: extraProps && extraProps.ref
              ? // #2078 in the case of <component :is="vnode" ref="extra"/>
                  // if the vnode itself already has a ref, cloneVNode will need to merge
                  // the refs so the single vnode can be set on multiple refs
                  mergeRef && ref
                      ? isArray(ref)
                          ? ref.concat(normalizeRef(extraProps))
                          : [ref, normalizeRef(extraProps)]
                      : normalizeRef(extraProps)
              : ref,
          scopeId: vnode.scopeId,
          children: vnode.children,
          target: vnode.target,
          targetAnchor: vnode.targetAnchor,
          staticCount: vnode.staticCount,
          shapeFlag: vnode.shapeFlag,
          // if the vnode is cloned with extra props, we can no longer assume its
          // existing patch flag to be reliable and need to add the FULL_PROPS flag.
          // note: perserve flag for fragments since they use the flag for children
          // fast paths only.
          patchFlag: extraProps && vnode.type !== Fragment
              ? patchFlag === -1 // hoisted node
                  ? 16 /* FULL_PROPS */
                  : patchFlag | 16 /* FULL_PROPS */
              : patchFlag,
          dynamicProps: vnode.dynamicProps,
          dynamicChildren: vnode.dynamicChildren,
          appContext: vnode.appContext,
          dirs: vnode.dirs,
          transition: vnode.transition,
          // These should technically only be non-null on mounted VNodes. However,
          // they *should* be copied for kept-alive vnodes. So we just always copy
          // them since them being non-null during a mount doesn't affect the logic as
          // they will simply be overwritten.
          component: vnode.component,
          suspense: vnode.suspense,
          ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
          ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
          el: vnode.el,
          anchor: vnode.anchor
      };
  }
  /**
   * @private
   */
  function createTextVNode(text = ' ', flag = 0) {
      return createVNode(Text, null, text, flag);
  }
  function normalizeVNode(child) {
      if (child == null || typeof child === 'boolean') {
          // empty placeholder
          return createVNode(Comment);
      }
      else if (isArray(child)) {
          // fragment
          return createVNode(Fragment, null, child);
      }
      else if (typeof child === 'object') {
          // already vnode, this should be the most common since compiled templates
          // always produce all-vnode children arrays
          return child.el === null ? child : cloneVNode(child);
      }
      else {
          // strings and numbers
          return createVNode(Text, null, String(child));
      }
  }
  // optimized normalization for template-compiled render fns
  function cloneIfMounted(child) {
      return child.el === null ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
      let type = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
          children = null;
      }
      else if (isArray(children)) {
          type = 16 /* ARRAY_CHILDREN */;
      }
      else if (typeof children === 'object') {
          if (shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) {
              // Normalize slot to plain children for plain element and Teleport
              const slot = children.default;
              if (slot) {
                  // _c marker is added by withCtx() indicating this is a compiled slot
                  slot._c && setCompiledSlotRendering(1);
                  normalizeChildren(vnode, slot());
                  slot._c && setCompiledSlotRendering(-1);
              }
              return;
          }
          else {
              type = 32 /* SLOTS_CHILDREN */;
              const slotFlag = children._;
              if (!slotFlag && !(InternalObjectKey in children)) {
                  children._ctx = currentRenderingInstance;
              }
              else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {
                  // a child component receives forwarded slots from the parent.
                  // its slot type is determined by its parent's slot type.
                  if (currentRenderingInstance.vnode.patchFlag & 1024 /* DYNAMIC_SLOTS */) {
                      children._ = 2 /* DYNAMIC */;
                      vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                  }
                  else {
                      children._ = 1 /* STABLE */;
                  }
              }
          }
      }
      else if (isFunction(children)) {
          children = { default: children, _ctx: currentRenderingInstance };
          type = 32 /* SLOTS_CHILDREN */;
      }
      else {
          children = String(children);
          // force teleport children to array so it can be moved around
          if (shapeFlag & 64 /* TELEPORT */) {
              type = 16 /* ARRAY_CHILDREN */;
              children = [createTextVNode(children)];
          }
          else {
              type = 8 /* TEXT_CHILDREN */;
          }
      }
      vnode.children = children;
      vnode.shapeFlag |= type;
  }
  function mergeProps(...args) {
      const ret = extend({}, args[0]);
      for (let i = 1; i < args.length; i++) {
          const toMerge = args[i];
          for (const key in toMerge) {
              if (key === 'class') {
                  if (ret.class !== toMerge.class) {
                      ret.class = normalizeClass([ret.class, toMerge.class]);
                  }
              }
              else if (key === 'style') {
                  ret.style = normalizeStyle([ret.style, toMerge.style]);
              }
              else if (isOn(key)) {
                  const existing = ret[key];
                  const incoming = toMerge[key];
                  if (existing !== incoming) {
                      ret[key] = existing
                          ? [].concat(existing, toMerge[key])
                          : incoming;
                  }
              }
              else {
                  ret[key] = toMerge[key];
              }
          }
      }
      return ret;
  }

  function initProps(instance, rawProps, isStateful, // result of bitwise flag comparison
  isSSR = false) {
      const props = {};
      const attrs = {};
      def(attrs, InternalObjectKey, 1);
      setFullProps(instance, rawProps, props, attrs);
      // validation
      {
          validateProps(props, instance);
      }
      if (isStateful) {
          // stateful
          instance.props = isSSR ? props : shallowReactive(props);
      }
      else {
          if (!instance.type.props) {
              // functional w/ optional props, props === attrs
              instance.props = attrs;
          }
          else {
              // functional w/ declared props
              instance.props = props;
          }
      }
      instance.attrs = attrs;
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const { props, attrs, vnode: { patchFlag } } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      if (
      // always force full diff if hmr is enabled
      !( instance.type.__hmrId) &&
          (optimized || patchFlag > 0) &&
          !(patchFlag & 16 /* FULL_PROPS */)) {
          if (patchFlag & 8 /* PROPS */) {
              // Compiler-generated props & no keys change, just set the updated
              // the props.
              const propsToUpdate = instance.vnode.dynamicProps;
              for (let i = 0; i < propsToUpdate.length; i++) {
                  const key = propsToUpdate[i];
                  // PROPS flag guarantees rawProps to be non-null
                  const value = rawProps[key];
                  if (options) {
                      // attr / props separation was done on init and will be consistent
                      // in this code path, so just check if attrs have it.
                      if (hasOwn(attrs, key)) {
                          attrs[key] = value;
                      }
                      else {
                          const camelizedKey = camelize(key);
                          props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance);
                      }
                  }
                  else {
                      attrs[key] = value;
                  }
              }
          }
      }
      else {
          // full props update.
          setFullProps(instance, rawProps, props, attrs);
          // in case of dynamic props, check if we need to delete keys from
          // the props object
          let kebabKey;
          for (const key in rawCurrentProps) {
              if (!rawProps ||
                  // for camelCase
                  (!hasOwn(rawProps, key) &&
                      // it's possible the original props was passed in as kebab-case
                      // and converted to camelCase (#955)
                      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey)))) {
                  if (options) {
                      if (rawPrevProps &&
                          // for camelCase
                          (rawPrevProps[key] !== undefined ||
                              // for kebab-case
                              rawPrevProps[kebabKey] !== undefined)) {
                          props[key] = resolvePropValue(options, rawProps || EMPTY_OBJ, key, undefined, instance);
                      }
                  }
                  else {
                      delete props[key];
                  }
              }
          }
          // in the case of functional component w/o props declaration, props and
          // attrs point to the same object so it should already have been updated.
          if (attrs !== rawCurrentProps) {
              for (const key in attrs) {
                  if (!rawProps || !hasOwn(rawProps, key)) {
                      delete attrs[key];
                  }
              }
          }
      }
      // trigger updates for $attrs in case it's used in component slots
      trigger(instance, "set" /* SET */, '$attrs');
      if ( rawProps) {
          validateProps(props, instance);
      }
  }
  function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      if (rawProps) {
          for (const key in rawProps) {
              const value = rawProps[key];
              // key, ref are reserved and never passed down
              if (isReservedProp(key)) {
                  continue;
              }
              // prop option names are camelized during normalization, so to support
              // kebab -> camel conversion here we need to camelize the key.
              let camelKey;
              if (options && hasOwn(options, (camelKey = camelize(key)))) {
                  props[camelKey] = value;
              }
              else if (!isEmitListener(instance.emitsOptions, key)) {
                  // Any non-declared (either as a prop or an emitted event) props are put
                  // into a separate `attrs` object for spreading. Make sure to preserve
                  // original key casing
                  attrs[key] = value;
              }
          }
      }
      if (needCastKeys) {
          const rawCurrentProps = toRaw(props);
          for (let i = 0; i < needCastKeys.length; i++) {
              const key = needCastKeys[i];
              props[key] = resolvePropValue(options, rawCurrentProps, key, rawCurrentProps[key], instance);
          }
      }
  }
  function resolvePropValue(options, props, key, value, instance) {
      const opt = options[key];
      if (opt != null) {
          const hasDefault = hasOwn(opt, 'default');
          // default values
          if (hasDefault && value === undefined) {
              const defaultValue = opt.default;
              if (opt.type !== Function && isFunction(defaultValue)) {
                  setCurrentInstance(instance);
                  value = defaultValue(props);
                  setCurrentInstance(null);
              }
              else {
                  value = defaultValue;
              }
          }
          // boolean casting
          if (opt[0 /* shouldCast */]) {
              if (!hasOwn(props, key) && !hasDefault) {
                  value = false;
              }
              else if (opt[1 /* shouldCastTrue */] &&
                  (value === '' || value === hyphenate(key))) {
                  value = true;
              }
          }
      }
      return value;
  }
  function normalizePropsOptions(comp, appContext, asMixin = false) {
      const appId = appContext.app ? appContext.app._uid : -1;
      const cache = comp.__props || (comp.__props = {});
      const cached = cache[appId];
      if (cached) {
          return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      // apply mixin/extends props
      let hasExtends = false;
      if ( !isFunction(comp)) {
          const extendProps = (raw) => {
              hasExtends = true;
              const [props, keys] = normalizePropsOptions(raw, appContext, true);
              extend(normalized, props);
              if (keys)
                  needCastKeys.push(...keys);
          };
          if (!asMixin && appContext.mixins.length) {
              appContext.mixins.forEach(extendProps);
          }
          if (comp.extends) {
              extendProps(comp.extends);
          }
          if (comp.mixins) {
              comp.mixins.forEach(extendProps);
          }
      }
      if (!raw && !hasExtends) {
          return (cache[appId] = EMPTY_ARR);
      }
      if (isArray(raw)) {
          for (let i = 0; i < raw.length; i++) {
              if ( !isString(raw[i])) {
                  warn(`props must be strings when using array syntax.`, raw[i]);
              }
              const normalizedKey = camelize(raw[i]);
              if (validatePropName(normalizedKey)) {
                  normalized[normalizedKey] = EMPTY_OBJ;
              }
          }
      }
      else if (raw) {
          if ( !isObject(raw)) {
              warn(`invalid props options`, raw);
          }
          for (const key in raw) {
              const normalizedKey = camelize(key);
              if (validatePropName(normalizedKey)) {
                  const opt = raw[key];
                  const prop = (normalized[normalizedKey] =
                      isArray(opt) || isFunction(opt) ? { type: opt } : opt);
                  if (prop) {
                      const booleanIndex = getTypeIndex(Boolean, prop.type);
                      const stringIndex = getTypeIndex(String, prop.type);
                      prop[0 /* shouldCast */] = booleanIndex > -1;
                      prop[1 /* shouldCastTrue */] =
                          stringIndex < 0 || booleanIndex < stringIndex;
                      // if the prop needs boolean casting or default value
                      if (booleanIndex > -1 || hasOwn(prop, 'default')) {
                          needCastKeys.push(normalizedKey);
                      }
                  }
              }
          }
      }
      return (cache[appId] = [normalized, needCastKeys]);
  }
  // use function string name to check type constructors
  // so that it works across vms / iframes.
  function getType(ctor) {
      const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
      return match ? match[1] : '';
  }
  function isSameType(a, b) {
      return getType(a) === getType(b);
  }
  function getTypeIndex(type, expectedTypes) {
      if (isArray(expectedTypes)) {
          for (let i = 0, len = expectedTypes.length; i < len; i++) {
              if (isSameType(expectedTypes[i], type)) {
                  return i;
              }
          }
      }
      else if (isFunction(expectedTypes)) {
          return isSameType(expectedTypes, type) ? 0 : -1;
      }
      return -1;
  }
  /**
   * dev only
   */
  function validateProps(props, instance) {
      const rawValues = toRaw(props);
      const options = instance.propsOptions[0];
      for (const key in options) {
          let opt = options[key];
          if (opt == null)
              continue;
          validateProp(key, rawValues[key], opt, !hasOwn(rawValues, key));
      }
  }
  /**
   * dev only
   */
  function validatePropName(key) {
      if (key[0] !== '$') {
          return true;
      }
      else {
          warn(`Invalid prop name: "${key}" is a reserved property.`);
      }
      return false;
  }
  /**
   * dev only
   */
  function validateProp(name, value, prop, isAbsent) {
      const { type, required, validator } = prop;
      // required!
      if (required && isAbsent) {
          warn('Missing required prop: "' + name + '"');
          return;
      }
      // missing but optional
      if (value == null && !prop.required) {
          return;
      }
      // type check
      if (type != null && type !== true) {
          let isValid = false;
          const types = isArray(type) ? type : [type];
          const expectedTypes = [];
          // value is valid as long as one of the specified types match
          for (let i = 0; i < types.length && !isValid; i++) {
              const { valid, expectedType } = assertType(value, types[i]);
              expectedTypes.push(expectedType || '');
              isValid = valid;
          }
          if (!isValid) {
              warn(getInvalidTypeMessage(name, value, expectedTypes));
              return;
          }
      }
      // custom validator
      if (validator && !validator(value)) {
          warn('Invalid prop: custom validator check failed for prop "' + name + '".');
      }
  }
  const isSimpleType = /*#__PURE__*/ makeMap('String,Number,Boolean,Function,Symbol');
  /**
   * dev only
   */
  function assertType(value, type) {
      let valid;
      const expectedType = getType(type);
      if (isSimpleType(expectedType)) {
          const t = typeof value;
          valid = t === expectedType.toLowerCase();
          // for primitive wrapper objects
          if (!valid && t === 'object') {
              valid = value instanceof type;
          }
      }
      else if (expectedType === 'Object') {
          valid = isObject(value);
      }
      else if (expectedType === 'Array') {
          valid = isArray(value);
      }
      else {
          valid = value instanceof type;
      }
      return {
          valid,
          expectedType
      };
  }
  /**
   * dev only
   */
  function getInvalidTypeMessage(name, value, expectedTypes) {
      let message = `Invalid prop: type check failed for prop "${name}".` +
          ` Expected ${expectedTypes.map(capitalize).join(', ')}`;
      const expectedType = expectedTypes[0];
      const receivedType = toRawType(value);
      const expectedValue = styleValue(value, expectedType);
      const receivedValue = styleValue(value, receivedType);
      // check if we need to specify expected value
      if (expectedTypes.length === 1 &&
          isExplicable(expectedType) &&
          !isBoolean(expectedType, receivedType)) {
          message += ` with value ${expectedValue}`;
      }
      message += `, got ${receivedType} `;
      // check if we need to specify received value
      if (isExplicable(receivedType)) {
          message += `with value ${receivedValue}.`;
      }
      return message;
  }
  /**
   * dev only
   */
  function styleValue(value, type) {
      if (type === 'String') {
          return `"${value}"`;
      }
      else if (type === 'Number') {
          return `${Number(value)}`;
      }
      else {
          return `${value}`;
      }
  }
  /**
   * dev only
   */
  function isExplicable(type) {
      const explicitTypes = ['string', 'number', 'boolean'];
      return explicitTypes.some(elem => type.toLowerCase() === elem);
  }
  /**
   * dev only
   */
  function isBoolean(...args) {
      return args.some(elem => elem.toLowerCase() === 'boolean');
  }

  function injectHook(type, hook, target = currentInstance, prepend = false) {
      if (target) {
          const hooks = target[type] || (target[type] = []);
          // cache the error handling wrapper for injected hooks so the same hook
          // can be properly deduped by the scheduler. "__weh" stands for "with error
          // handling".
          const wrappedHook = hook.__weh ||
              (hook.__weh = (...args) => {
                  if (target.isUnmounted) {
                      return;
                  }
                  // disable tracking inside all lifecycle hooks
                  // since they can potentially be called inside effects.
                  pauseTracking();
                  // Set currentInstance during hook invocation.
                  // This assumes the hook does not synchronously trigger other hooks, which
                  // can only be false when the user does something really funky.
                  setCurrentInstance(target);
                  const res = callWithAsyncErrorHandling(hook, target, type, args);
                  setCurrentInstance(null);
                  resetTracking();
                  return res;
              });
          if (prepend) {
              hooks.unshift(wrappedHook);
          }
          else {
              hooks.push(wrappedHook);
          }
          return wrappedHook;
      }
      else {
          const apiName = `on${capitalize(ErrorTypeStrings[type].replace(/ hook$/, ''))}`;
          warn(`${apiName} is called when there is no active component instance to be ` +
              `associated with. ` +
              `Lifecycle injection APIs can only be used during execution of setup().` +
              ( ` If you are using async setup(), make sure to register lifecycle ` +
                      `hooks before the first await statement.`
                  ));
      }
  }
  const createHook = (lifecycle) => (hook, target = currentInstance) => 
  // post-create lifecycle registrations are noops during SSR
  !isInSSRComponentSetup && injectHook(lifecycle, hook, target);
  const onBeforeMount = createHook("bm" /* BEFORE_MOUNT */);
  const onMounted = createHook("m" /* MOUNTED */);
  const onBeforeUpdate = createHook("bu" /* BEFORE_UPDATE */);
  const onUpdated = createHook("u" /* UPDATED */);
  const onBeforeUnmount = createHook("bum" /* BEFORE_UNMOUNT */);
  const onUnmounted = createHook("um" /* UNMOUNTED */);
  const onRenderTriggered = createHook("rtg" /* RENDER_TRIGGERED */);
  const onRenderTracked = createHook("rtc" /* RENDER_TRACKED */);
  const onErrorCaptured = (hook, target = currentInstance) => {
      injectHook("ec" /* ERROR_CAPTURED */, hook, target);
  };

  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a" /* ACTIVATED */, target);
  }
  function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da" /* DEACTIVATED */, target);
  }
  function registerKeepAliveHook(hook, type, target = currentInstance) {
      // cache the deactivate branch check wrapper for injected hooks so the same
      // hook can be properly deduped by the scheduler. "__wdc" stands for "with
      // deactivation check".
      const wrappedHook = hook.__wdc ||
          (hook.__wdc = () => {
              // only fire the hook if the target instance is NOT in a deactivated branch.
              let current = target;
              while (current) {
                  if (current.isDeactivated) {
                      return;
                  }
                  current = current.parent;
              }
              hook();
          });
      injectHook(type, wrappedHook, target);
      // In addition to registering it on the target instance, we walk up the parent
      // chain and register it on all ancestor instances that are keep-alive roots.
      // This avoids the need to walk the entire component tree when invoking these
      // hooks, and more importantly, avoids the need to track child components in
      // arrays.
      if (target) {
          let current = target.parent;
          while (current && current.parent) {
              if (isKeepAlive(current.parent.vnode)) {
                  injectToKeepAliveRoot(wrappedHook, type, target, current);
              }
              current = current.parent;
          }
      }
  }
  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
      // injectHook wraps the original for error handling, so make sure to remove
      // the wrapped version.
      const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);
      onUnmounted(() => {
          remove(keepAliveRoot[type], injected);
      }, target);
  }

  const isInternalKey = (key) => key[0] === '_' || key === '$stable';
  const normalizeSlotValue = (value) => isArray(value)
      ? value.map(normalizeVNode)
      : [normalizeVNode(value)];
  const normalizeSlot = (key, rawSlot, ctx) => withCtx((props) => {
      if ( currentInstance) {
          warn(`Slot "${key}" invoked outside of the render function: ` +
              `this will not track dependencies used in the slot. ` +
              `Invoke the slot function inside the render function instead.`);
      }
      return normalizeSlotValue(rawSlot(props));
  }, ctx);
  const normalizeObjectSlots = (rawSlots, slots) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
          if (isInternalKey(key))
              continue;
          const value = rawSlots[key];
          if (isFunction(value)) {
              slots[key] = normalizeSlot(key, value, ctx);
          }
          else if (value != null) {
              {
                  warn(`Non-function value encountered for slot "${key}". ` +
                      `Prefer function slots for better performance.`);
              }
              const normalized = normalizeSlotValue(value);
              slots[key] = () => normalized;
          }
      }
  };
  const normalizeVNodeSlots = (instance, children) => {
      if ( !isKeepAlive(instance.vnode)) {
          warn(`Non-function value encountered for default slot. ` +
              `Prefer function slots for better performance.`);
      }
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
  };
  const initSlots = (instance, children) => {
      if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
          const type = children._;
          if (type) {
              instance.slots = children;
              // make compiler marker non-enumerable
              def(children, '_', type);
          }
          else {
              normalizeObjectSlots(children, (instance.slots = {}));
          }
      }
      else {
          instance.slots = {};
          if (children) {
              normalizeVNodeSlots(instance, children);
          }
      }
      def(instance.slots, InternalObjectKey, 1);
  };
  const updateSlots = (instance, children) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
          const type = children._;
          if (type) {
              // compiled slots.
              if ( isHmrUpdating) {
                  // Parent was HMR updated so slot content may have changed.
                  // force update slots and mark instance for hmr as well
                  extend(slots, children);
              }
              else if (type === 1 /* STABLE */) {
                  // compiled AND stable.
                  // no need to update, and skip stale slots removal.
                  needDeletionCheck = false;
              }
              else {
                  // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
                  // normalization.
                  extend(slots, children);
              }
          }
          else {
              needDeletionCheck = !children.$stable;
              normalizeObjectSlots(children, slots);
          }
          deletionComparisonTarget = children;
      }
      else if (children) {
          // non slot object children (direct value) passed to a component
          normalizeVNodeSlots(instance, children);
          deletionComparisonTarget = { default: 1 };
      }
      // delete stale slots
      if (needDeletionCheck) {
          for (const key in slots) {
              if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
                  delete slots[key];
              }
          }
      }
  };

  /**
  Runtime helper for applying directives to a vnode. Example usage:

  const comp = resolveComponent('comp')
  const foo = resolveDirective('foo')
  const bar = resolveDirective('bar')

  return withDirectives(h(comp), [
    [foo, this.x],
    [bar, this.y]
  ])
  */
  const isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text');
  function validateDirectiveName(name) {
      if (isBuiltInDirective(name)) {
          warn('Do not use built-in directive ids as custom directive id: ' + name);
      }
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i = 0; i < bindings.length; i++) {
          const binding = bindings[i];
          if (oldBindings) {
              binding.oldValue = oldBindings[i].value;
          }
          const hook = binding.dir[name];
          if (hook) {
              callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [
                  vnode.el,
                  binding,
                  vnode,
                  prevVNode
              ]);
          }
      }
  }

  function createAppContext() {
      return {
          app: null,
          config: {
              isNativeTag: NO,
              performance: false,
              globalProperties: {},
              optionMergeStrategies: {},
              isCustomElement: NO,
              errorHandler: undefined,
              warnHandler: undefined
          },
          mixins: [],
          components: {},
          directives: {},
          provides: Object.create(null)
      };
  }
  let uid$1 = 0;
  function createAppAPI(render, hydrate) {
      // 真正应用程序实例工厂函数
      // rootComponent：就是用户传入根组件配置
      return function createApp(rootComponent, rootProps = null) {
          if (rootProps != null && !isObject(rootProps)) {
               warn(`root props passed to app.mount() must be an object.`);
              rootProps = null;
          }
          const context = createAppContext();
          const installedPlugins = new Set();
          let isMounted = false;
          // 应用程序实例
          const app = (context.app = {
              _uid: uid$1++,
              _component: rootComponent,
              _props: rootProps,
              _container: null,
              _context: context,
              version,
              get config() {
                  return context.config;
              },
              set config(v) {
                  {
                      warn(`app.config cannot be replaced. Modify individual options instead.`);
                  }
              },
              use(plugin, ...options) {
                  if (installedPlugins.has(plugin)) {
                       warn(`Plugin has already been applied to target app.`);
                  }
                  else if (plugin && isFunction(plugin.install)) {
                      installedPlugins.add(plugin);
                      plugin.install(app, ...options);
                  }
                  else if (isFunction(plugin)) {
                      installedPlugins.add(plugin);
                      plugin(app, ...options);
                  }
                  else {
                      warn(`A plugin must either be a function or an object with an "install" ` +
                          `function.`);
                  }
                  return app;
              },
              mixin(mixin) {
                  {
                      if (!context.mixins.includes(mixin)) {
                          context.mixins.push(mixin);
                      }
                      else {
                          warn('Mixin has already been applied to target app' +
                              (mixin.name ? `: ${mixin.name}` : ''));
                      }
                  }
                  return app;
              },
              component(name, component) {
                  {
                      validateComponentName(name, context.config);
                  }
                  if (!component) {
                      return context.components[name];
                  }
                  if ( context.components[name]) {
                      warn(`Component "${name}" has already been registered in target app.`);
                  }
                  context.components[name] = component;
                  return app;
              },
              directive(name, directive) {
                  {
                      validateDirectiveName(name);
                  }
                  if (!directive) {
                      return context.directives[name];
                  }
                  if ( context.directives[name]) {
                      warn(`Directive "${name}" has already been registered in target app.`);
                  }
                  context.directives[name] = directive;
                  return app;
              },
              // 挂载方法
              mount(rootContainer, isHydrate) {
                  if (!isMounted) {
                      // 根组件虚拟dom
                      const vnode = createVNode(rootComponent, rootProps);
                      // store app context on the root VNode.
                      // this will be set on the root instance on initial mount.
                      vnode.appContext = context;
                      // HMR root reload
                      {
                          context.reload = () => {
                              render(cloneVNode(vnode), rootContainer);
                          };
                      }
                      if (isHydrate && hydrate) {
                          hydrate(vnode, rootContainer);
                      }
                      else {
                          // spa默认使用render
                          // 渲染vnode为dom并追加到rootContainer
                          render(vnode, rootContainer);
                      }
                      isMounted = true;
                      app._container = rootContainer;
                      rootContainer.__vue_app__ = app;
                      return vnode.component.proxy;
                  }
                  else {
                      warn(`App has already been mounted.\n` +
                          `If you want to remount the same app, move your app creation logic ` +
                          `into a factory function and create fresh app instances for each ` +
                          `mount - e.g. \`const createMyApp = () => createApp(App)\``);
                  }
              },
              unmount() {
                  if (isMounted) {
                      render(null, app._container);
                  }
                  else {
                      warn(`Cannot unmount an app that is not mounted.`);
                  }
              },
              provide(key, value) {
                  if ( key in context.provides) {
                      warn(`App already provides property with key "${String(key)}". ` +
                          `It will be overwritten with the new value.`);
                  }
                  // TypeScript doesn't allow symbols as index type
                  // https://github.com/Microsoft/TypeScript/issues/24587
                  context.provides[key] = value;
                  return app;
              }
          });
          return app;
      };
  }

  let supported;
  let perf;
  function startMeasure(instance, type) {
      if (instance.appContext.config.performance && isSupported()) {
          perf.mark(`vue-${type}-${instance.uid}`);
      }
  }
  function endMeasure(instance, type) {
      if (instance.appContext.config.performance && isSupported()) {
          const startTag = `vue-${type}-${instance.uid}`;
          const endTag = startTag + `:end`;
          perf.mark(endTag);
          perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
          perf.clearMarks(startTag);
          perf.clearMarks(endTag);
      }
  }
  function isSupported() {
      if (supported !== undefined) {
          return supported;
      }
      /* eslint-disable no-restricted-globals */
      if (typeof window !== 'undefined' && window.performance) {
          supported = true;
          perf = window.performance;
      }
      else {
          supported = false;
      }
      /* eslint-enable no-restricted-globals */
      return supported;
  }

  function createDevEffectOptions(instance) {
      return {
          scheduler: queueJob,
          allowRecurse: true,
          onTrack: instance.rtc ? e => invokeArrayFns(instance.rtc, e) : void 0,
          onTrigger: instance.rtg ? e => invokeArrayFns(instance.rtg, e) : void 0
      };
  }
  const queuePostRenderEffect =  queueEffectWithSuspense
      ;
  const setRef = (rawRef, oldRawRef, parentComponent, parentSuspense, vnode) => {
      if (isArray(rawRef)) {
          rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentComponent, parentSuspense, vnode));
          return;
      }
      let value;
      if (!vnode) {
          value = null;
      }
      else {
          if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
              value = vnode.component.proxy;
          }
          else {
              value = vnode.el;
          }
      }
      const { i: owner, r: ref } = rawRef;
      if ( !owner) {
          warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` +
              `A vnode with ref must be created inside the render function.`);
          return;
      }
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? (owner.refs = {}) : owner.refs;
      const setupState = owner.setupState;
      // unset old ref
      if (oldRef != null && oldRef !== ref) {
          if (isString(oldRef)) {
              refs[oldRef] = null;
              if (hasOwn(setupState, oldRef)) {
                  setupState[oldRef] = null;
              }
          }
          else if (isRef(oldRef)) {
              oldRef.value = null;
          }
      }
      if (isString(ref)) {
          const doSet = () => {
              refs[ref] = value;
              if (hasOwn(setupState, ref)) {
                  setupState[ref] = value;
              }
          };
          // #1789: for non-null values, set them after render
          // null values means this is unmount and it should not overwrite another
          // ref with the same key
          if (value) {
              doSet.id = -1;
              queuePostRenderEffect(doSet, parentSuspense);
          }
          else {
              doSet();
          }
      }
      else if (isRef(ref)) {
          const doSet = () => {
              ref.value = value;
          };
          if (value) {
              doSet.id = -1;
              queuePostRenderEffect(doSet, parentSuspense);
          }
          else {
              doSet();
          }
      }
      else if (isFunction(ref)) {
          callWithErrorHandling(ref, parentComponent, 12 /* FUNCTION_REF */, [
              value,
              refs
          ]);
      }
      else {
          warn('Invalid template ref type:', value, `(${typeof value})`);
      }
  };
  /**
   * The createRenderer function accepts two generic arguments:
   * HostNode and HostElement, corresponding to Node and Element types in the
   * host environment. For example, for runtime-dom, HostNode would be the DOM
   * `Node` interface and HostElement would be the DOM `Element` interface.
   *
   * Custom renderers can pass in the platform specific types like this:
   *
   * ``` js
   * const { render, createApp } = createRenderer<Node, Element>({
   *   patchProp,
   *   ...nodeOps
   * })
   * ```
   */
  function createRenderer(options) {
      return baseCreateRenderer(options);
  }
  // implementation
  function baseCreateRenderer(options, createHydrationFns) {
      const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, forcePatchProp: hostForcePatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
      // Note: functions inside this closure should use `const xxx = () => {}`
      // style in order to prevent being inlined by minifiers.
      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false) => {
          // patching & not same type, unmount old tree
          if (n1 && !isSameVNodeType(n1, n2)) {
              anchor = getNextHostNode(n1);
              unmount(n1, parentComponent, parentSuspense, true);
              n1 = null;
          }
          if (n2.patchFlag === -2 /* BAIL */) {
              optimized = false;
              n2.dynamicChildren = null;
          }
          // n2是新的vnode
          const { type, ref, shapeFlag } = n2;
          // 根据当前虚拟dom代表的不同类型执行不同分支
          switch (type) {
              case Text:
                  processText(n1, n2, container, anchor);
                  break;
              case Comment:
                  processCommentNode(n1, n2, container, anchor);
                  break;
              case Static:
                  if (n1 == null) {
                      mountStaticNode(n2, container, anchor, isSVG);
                  }
                  else {
                      patchStaticNode(n1, n2, container, isSVG);
                  }
                  break;
              case Fragment:
                  processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                  break;
              default:
                  // 元素
                  if (shapeFlag & 1 /* ELEMENT */) {
                      processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                      // 组件
                  }
                  else if (shapeFlag & 6 /* COMPONENT */) {
                      processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                  }
                  else if (shapeFlag & 64 /* TELEPORT */) {
                      type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);
                  }
                  else if ( shapeFlag & 128 /* SUSPENSE */) {
                      type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);
                  }
                  else {
                      warn('Invalid VNode type:', type, `(${typeof type})`);
                  }
          }
          // set ref
          if (ref != null && parentComponent) {
              setRef(ref, n1 && n1.ref, parentComponent, parentSuspense, n2);
          }
      };
      const processText = (n1, n2, container, anchor) => {
          if (n1 == null) {
              hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);
          }
          else {
              const el = (n2.el = n1.el);
              if (n2.children !== n1.children) {
                  hostSetText(el, n2.children);
              }
          }
      };
      const processCommentNode = (n1, n2, container, anchor) => {
          if (n1 == null) {
              hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);
          }
          else {
              // there's no support for dynamic comments
              n2.el = n1.el;
          }
      };
      const mountStaticNode = (n2, container, anchor, isSVG) => {
          [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
      };
      /**
       * Dev / HMR only
       */
      const patchStaticNode = (n1, n2, container, isSVG) => {
          // static nodes are only patched during dev for HMR
          if (n2.children !== n1.children) {
              const anchor = hostNextSibling(n1.anchor);
              // remove existing
              removeStaticNode(n1);
              [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
          }
          else {
              n2.el = n1.el;
              n2.anchor = n1.anchor;
          }
      };
      /**
       * Dev / HMR only
       */
      const moveStaticNode = (vnode, container, anchor) => {
          let cur = vnode.el;
          const end = vnode.anchor;
          while (cur && cur !== end) {
              const next = hostNextSibling(cur);
              hostInsert(cur, container, anchor);
              cur = next;
          }
          hostInsert(end, container, anchor);
      };
      /**
       * Dev / HMR only
       */
      const removeStaticNode = (vnode) => {
          let cur = vnode.el;
          while (cur && cur !== vnode.anchor) {
              const next = hostNextSibling(cur);
              hostRemove(cur);
              cur = next;
          }
          hostRemove(vnode.anchor);
      };
      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
          isSVG = isSVG || n2.type === 'svg';
          if (n1 == null) {
              mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
          }
          else {
              patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);
          }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
          let el;
          let vnodeHook;
          const { type, props, shapeFlag, transition, scopeId, patchFlag, dirs } = vnode;
          {
              el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is);
              // mount children first, since some props may rely on child content
              // being already rendered, e.g. `<select value>`
              if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                  hostSetElementText(el, vnode.children);
              }
              else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                  mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', optimized || !!vnode.dynamicChildren);
              }
              if (dirs) {
                  invokeDirectiveHook(vnode, null, parentComponent, 'created');
              }
              // props
              if (props) {
                  for (const key in props) {
                      if (!isReservedProp(key)) {
                          hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                      }
                  }
                  if ((vnodeHook = props.onVnodeBeforeMount)) {
                      invokeVNodeHook(vnodeHook, parentComponent, vnode);
                  }
              }
              // scopeId
              setScopeId(el, scopeId, vnode, parentComponent);
          }
          {
              Object.defineProperty(el, '__vnode', {
                  value: vnode,
                  enumerable: false
              });
              Object.defineProperty(el, '__vueParentComponent', {
                  value: parentComponent,
                  enumerable: false
              });
          }
          if (dirs) {
              invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
          }
          // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
          // #1689 For inside suspense + suspense resolved case, just call it
          const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&
              transition &&
              !transition.persisted;
          if (needCallTransitionHooks) {
              transition.beforeEnter(el);
          }
          hostInsert(el, container, anchor);
          if ((vnodeHook = props && props.onVnodeMounted) ||
              needCallTransitionHooks ||
              dirs) {
              queuePostRenderEffect(() => {
                  vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                  needCallTransitionHooks && transition.enter(el);
                  dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
              }, parentSuspense);
          }
      };
      const setScopeId = (el, scopeId, vnode, parentComponent) => {
          if (scopeId) {
              hostSetScopeId(el, scopeId);
          }
          if (parentComponent) {
              const treeOwnerId = parentComponent.type.__scopeId;
              // vnode's own scopeId and the current patched component's scopeId is
              // different - this is a slot content node.
              if (treeOwnerId && treeOwnerId !== scopeId) {
                  hostSetScopeId(el, treeOwnerId + '-s');
              }
              let subTree = parentComponent.subTree;
              if ( subTree.type === Fragment) {
                  subTree =
                      filterSingleRoot(subTree.children) || subTree;
              }
              if (vnode === subTree) {
                  setScopeId(el, parentComponent.vnode.scopeId, parentComponent.vnode, parentComponent.parent);
              }
          }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, start = 0) => {
          for (let i = start; i < children.length; i++) {
              const child = (children[i] = optimized
                  ? cloneIfMounted(children[i])
                  : normalizeVNode(children[i]));
              patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
          }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, optimized) => {
          const el = (n2.el = n1.el);
          let { patchFlag, dynamicChildren, dirs } = n2;
          // #1426 take the old vnode's patch flag into account since user may clone a
          // compiler-generated vnode, which de-opts to FULL_PROPS
          patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;
          const oldProps = n1.props || EMPTY_OBJ;
          const newProps = n2.props || EMPTY_OBJ;
          let vnodeHook;
          if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
              invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          }
          if (dirs) {
              invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
          }
          if ( isHmrUpdating) {
              // HMR updated, force full diff
              patchFlag = 0;
              optimized = false;
              dynamicChildren = null;
          }
          if (patchFlag > 0) {
              // the presence of a patchFlag means this element's render code was
              // generated by the compiler and can take the fast path.
              // in this path old node and new node are guaranteed to have the same shape
              // (i.e. at the exact same position in the source template)
              if (patchFlag & 16 /* FULL_PROPS */) {
                  // element props contain dynamic keys, full diff needed
                  patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
              }
              else {
                  // class
                  // this flag is matched when the element has dynamic class bindings.
                  if (patchFlag & 2 /* CLASS */) {
                      if (oldProps.class !== newProps.class) {
                          hostPatchProp(el, 'class', null, newProps.class, isSVG);
                      }
                  }
                  // style
                  // this flag is matched when the element has dynamic style bindings
                  if (patchFlag & 4 /* STYLE */) {
                      hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
                  }
                  // props
                  // This flag is matched when the element has dynamic prop/attr bindings
                  // other than class and style. The keys of dynamic prop/attrs are saved for
                  // faster iteration.
                  // Note dynamic keys like :[foo]="bar" will cause this optimization to
                  // bail out and go through a full diff because we need to unset the old key
                  if (patchFlag & 8 /* PROPS */) {
                      // if the flag is present then dynamicProps must be non-null
                      const propsToUpdate = n2.dynamicProps;
                      for (let i = 0; i < propsToUpdate.length; i++) {
                          const key = propsToUpdate[i];
                          const prev = oldProps[key];
                          const next = newProps[key];
                          if (next !== prev ||
                              (hostForcePatchProp && hostForcePatchProp(el, key))) {
                              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                          }
                      }
                  }
              }
              // text
              // This flag is matched when the element has only dynamic text children.
              if (patchFlag & 1 /* TEXT */) {
                  if (n1.children !== n2.children) {
                      hostSetElementText(el, n2.children);
                  }
              }
          }
          else if (!optimized && dynamicChildren == null) {
              // unoptimized, full diff
              patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
          }
          const areChildrenSVG = isSVG && n2.type !== 'foreignObject';
          if (dynamicChildren) {
              patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG);
              if ( parentComponent && parentComponent.type.__hmrId) {
                  traverseStaticChildren(n1, n2);
              }
          }
          else if (!optimized) {
              // full diff
              patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG);
          }
          if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
              queuePostRenderEffect(() => {
                  vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                  dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
              }, parentSuspense);
          }
      };
      // The fast path for blocks.
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG) => {
          for (let i = 0; i < newChildren.length; i++) {
              const oldVNode = oldChildren[i];
              const newVNode = newChildren[i];
              // Determine the container (parent element) for the patch.
              const container = 
              // - In the case of a Fragment, we need to provide the actual parent
              // of the Fragment itself so it can move its children.
              oldVNode.type === Fragment ||
                  // - In the case of different nodes, there is going to be a replacement
                  // which also requires the correct parent container
                  !isSameVNodeType(oldVNode, newVNode) ||
                  // - In the case of a component, it could contain anything.
                  oldVNode.shapeFlag & 6 /* COMPONENT */ ||
                  oldVNode.shapeFlag & 64 /* TELEPORT */
                  ? hostParentNode(oldVNode.el)
                  : // In other cases, the parent container is not actually used so we
                      // just pass the block element here to avoid a DOM parentNode call.
                      fallbackContainer;
              patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, true);
          }
      };
      const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
          if (oldProps !== newProps) {
              for (const key in newProps) {
                  if (isReservedProp(key))
                      continue;
                  const next = newProps[key];
                  const prev = oldProps[key];
                  if (next !== prev ||
                      (hostForcePatchProp && hostForcePatchProp(el, key))) {
                      hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                  }
              }
              if (oldProps !== EMPTY_OBJ) {
                  for (const key in oldProps) {
                      if (!isReservedProp(key) && !(key in newProps)) {
                          hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                      }
                  }
              }
          }
      };
      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
          const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));
          const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));
          let { patchFlag, dynamicChildren } = n2;
          if (patchFlag > 0) {
              optimized = true;
          }
          if ( isHmrUpdating) {
              // HMR updated, force full diff
              patchFlag = 0;
              optimized = false;
              dynamicChildren = null;
          }
          if (n1 == null) {
              hostInsert(fragmentStartAnchor, container, anchor);
              hostInsert(fragmentEndAnchor, container, anchor);
              // a fragment can only have array children
              // since they are either generated by the compiler, or implicitly created
              // from arrays.
              mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);
          }
          else {
              if (patchFlag > 0 &&
                  patchFlag & 64 /* STABLE_FRAGMENT */ &&
                  dynamicChildren) {
                  // a stable fragment (template root or <template v-for>) doesn't need to
                  // patch children order, but it may contain dynamicChildren.
                  patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG);
                  if ( parentComponent && parentComponent.type.__hmrId) {
                      traverseStaticChildren(n1, n2);
                  }
                  else if (
                  // #2080 if the stable fragment has a key, it's a <template v-for> that may
                  //  get moved around. Make sure all root level vnodes inherit el.
                  // #2134 or if it's a component root, it may also get moved around
                  // as the component is being moved.
                  n2.key != null ||
                      (parentComponent && n2 === parentComponent.subTree)) {
                      traverseStaticChildren(n1, n2, true /* shallow */);
                  }
              }
              else {
                  // keyed / unkeyed, or manual fragments.
                  // for keyed & unkeyed, since they are compiler generated from v-for,
                  // each child is guaranteed to be a block so the fragment will never
                  // have dynamicChildren.
                  patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);
              }
          }
      };
      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
          if (n1 == null) {
              if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
                  parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
              }
              else {
                  // 初始化走这里
                  mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
              }
          }
          else {
              updateComponent(n1, n2, optimized);
          }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
          // 1.创建根组件实例
          const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));
          if ( instance.type.__hmrId) {
              registerHMR(instance);
          }
          {
              pushWarningContext(initialVNode);
              startMeasure(instance, `mount`);
          }
          // inject renderer internals for keepAlive
          if (isKeepAlive(initialVNode)) {
              instance.ctx.renderer = internals;
          }
          // resolve props and slots for setup context
          {
              startMeasure(instance, `init`);
          }
          // 2.执行初始化：实例属性、状态初始化
          setupComponent(instance);
          {
              endMeasure(instance, `init`);
          }
          // setup() is async. This component relies on async logic to be resolved
          // before proceeding
          if ( instance.asyncDep) {
              parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
              // Give it a placeholder if this is not hydration
              // TODO handle self-defined fallback
              if (!initialVNode.el) {
                  const placeholder = (instance.subTree = createVNode(Comment));
                  processCommentNode(null, placeholder, container, anchor);
              }
              return;
          }
          // 渲染副作用安装
          setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
          {
              popWarningContext();
              endMeasure(instance, `mount`);
          }
      };
      const updateComponent = (n1, n2, optimized) => {
          const instance = (n2.component = n1.component);
          if (shouldUpdateComponent(n1, n2, optimized)) {
              if (
                  instance.asyncDep &&
                  !instance.asyncResolved) {
                  // async & still pending - just update props and slots
                  // since the component's reactive effect for render isn't set-up yet
                  {
                      pushWarningContext(n2);
                  }
                  updateComponentPreRender(instance, n2, optimized);
                  {
                      popWarningContext();
                  }
                  return;
              }
              else {
                  // normal update
                  instance.next = n2;
                  // in case the child component is also queued, remove it to avoid
                  // double updating the same child component in the same flush.
                  invalidateJob(instance.update);
                  // instance.update is the reactive effect runner.
                  instance.update();
              }
          }
          else {
              // no update needed. just copy over properties
              n2.component = n1.component;
              n2.el = n1.el;
              instance.vnode = n2;
          }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
          // create reactive effect for rendering
          instance.update = effect(function componentEffect() {
              if (!instance.isMounted) {
                  let vnodeHook;
                  const { el, props } = initialVNode;
                  const { bm, m, parent } = instance;
                  // beforeMount hook
                  if (bm) {
                      invokeArrayFns(bm);
                  }
                  // onVnodeBeforeMount
                  if ((vnodeHook = props && props.onVnodeBeforeMount)) {
                      invokeVNodeHook(vnodeHook, parent, initialVNode);
                  }
                  // render
                  {
                      startMeasure(instance, `render`);
                  }
                  // 首次渲染
                  const subTree = (instance.subTree = renderComponentRoot(instance));
                  {
                      endMeasure(instance, `render`);
                  }
                  if (el && hydrateNode) {
                      {
                          startMeasure(instance, `hydrate`);
                      }
                      // vnode has adopted host node - perform hydration instead of mount.
                      hydrateNode(initialVNode.el, subTree, instance, parentSuspense);
                      {
                          endMeasure(instance, `hydrate`);
                      }
                  }
                  else {
                      {
                          startMeasure(instance, `patch`);
                      }
                      patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                      {
                          endMeasure(instance, `patch`);
                      }
                      initialVNode.el = subTree.el;
                  }
                  // mounted hook
                  if (m) {
                      queuePostRenderEffect(m, parentSuspense);
                  }
                  // onVnodeMounted
                  if ((vnodeHook = props && props.onVnodeMounted)) {
                      queuePostRenderEffect(() => {
                          invokeVNodeHook(vnodeHook, parent, initialVNode);
                      }, parentSuspense);
                  }
                  // activated hook for keep-alive roots.
                  // #1742 activated hook must be accessed after first render
                  // since the hook may be injected by a child keep-alive
                  const { a } = instance;
                  if (a &&
                      initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
                      queuePostRenderEffect(a, parentSuspense);
                  }
                  instance.isMounted = true;
              }
              else {
                  // updateComponent
                  // This is triggered by mutation of component's own state (next: null)
                  // OR parent calling processComponent (next: VNode)
                  let { next, bu, u, parent, vnode } = instance;
                  let originNext = next;
                  let vnodeHook;
                  {
                      pushWarningContext(next || instance.vnode);
                  }
                  if (next) {
                      updateComponentPreRender(instance, next, optimized);
                  }
                  else {
                      next = vnode;
                  }
                  next.el = vnode.el;
                  // beforeUpdate hook
                  if (bu) {
                      invokeArrayFns(bu);
                  }
                  // onVnodeBeforeUpdate
                  if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {
                      invokeVNodeHook(vnodeHook, parent, next, vnode);
                  }
                  // render
                  {
                      startMeasure(instance, `render`);
                  }
                  const nextTree = renderComponentRoot(instance);
                  {
                      endMeasure(instance, `render`);
                  }
                  const prevTree = instance.subTree;
                  instance.subTree = nextTree;
                  // reset refs
                  // only needed if previous patch had refs
                  if (instance.refs !== EMPTY_OBJ) {
                      instance.refs = {};
                  }
                  {
                      startMeasure(instance, `patch`);
                  }
                  patch(prevTree, nextTree, 
                  // parent may have changed if it's in a teleport
                  hostParentNode(prevTree.el), 
                  // anchor may have changed if it's in a fragment
                  getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                  {
                      endMeasure(instance, `patch`);
                  }
                  next.el = nextTree.el;
                  if (originNext === null) {
                      // self-triggered update. In case of HOC, update parent component
                      // vnode el. HOC is indicated by parent instance's subTree pointing
                      // to child component's vnode
                      updateHOCHostEl(instance, nextTree.el);
                  }
                  // updated hook
                  if (u) {
                      queuePostRenderEffect(u, parentSuspense);
                  }
                  // onVnodeUpdated
                  if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
                      queuePostRenderEffect(() => {
                          invokeVNodeHook(vnodeHook, parent, next, vnode);
                      }, parentSuspense);
                  }
                  {
                      popWarningContext();
                  }
              }
          },  createDevEffectOptions(instance) );
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
          nextVNode.component = instance;
          const prevProps = instance.vnode.props;
          instance.vnode = nextVNode;
          instance.next = null;
          updateProps(instance, nextVNode.props, prevProps, optimized);
          updateSlots(instance, nextVNode.children);
          // props update may have triggered pre-flush watchers.
          // flush them before the render update.
          flushPreFlushCbs(undefined, instance.update);
      };
      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) => {
          const c1 = n1 && n1.children;
          const prevShapeFlag = n1 ? n1.shapeFlag : 0;
          const c2 = n2.children;
          const { patchFlag, shapeFlag } = n2;
          // fast path
          if (patchFlag > 0) {
              if (patchFlag & 128 /* KEYED_FRAGMENT */) {
                  // this could be either fully-keyed or mixed (some keyed some not)
                  // presence of patchFlag means children are guaranteed to be arrays
                  patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                  return;
              }
              else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {
                  // unkeyed
                  patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                  return;
              }
          }
          // children has 3 possibilities: text, array or no children.
          if (shapeFlag & 8 /* TEXT_CHILDREN */) {
              // text children fast path
              if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                  unmountChildren(c1, parentComponent, parentSuspense);
              }
              if (c2 !== c1) {
                  hostSetElementText(container, c2);
              }
          }
          else {
              if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                  // prev children was array
                  if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                      // two arrays, cannot assume anything, do full diff
                      patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                  }
                  else {
                      // no new children, just unmount old
                      unmountChildren(c1, parentComponent, parentSuspense, true);
                  }
              }
              else {
                  // prev children was text OR null
                  // new children is array OR null
                  if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {
                      hostSetElementText(container, '');
                  }
                  // mount new if array
                  if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                  }
              }
          }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
          c1 = c1 || EMPTY_ARR;
          c2 = c2 || EMPTY_ARR;
          const oldLength = c1.length;
          const newLength = c2.length;
          const commonLength = Math.min(oldLength, newLength);
          let i;
          for (i = 0; i < commonLength; i++) {
              const nextChild = (c2[i] = optimized
                  ? cloneIfMounted(c2[i])
                  : normalizeVNode(c2[i]));
              patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, optimized);
          }
          if (oldLength > newLength) {
              // remove old
              unmountChildren(c1, parentComponent, parentSuspense, true, commonLength);
          }
          else {
              // mount new
              mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, commonLength);
          }
      };
      // can be all-keyed or mixed
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {
          let i = 0;
          const l2 = c2.length;
          let e1 = c1.length - 1; // prev ending index
          let e2 = l2 - 1; // next ending index
          // 1. sync from start
          // (a b) c
          // (a b) d e
          while (i <= e1 && i <= e2) {
              const n1 = c1[i];
              const n2 = (c2[i] = optimized
                  ? cloneIfMounted(c2[i])
                  : normalizeVNode(c2[i]));
              if (isSameVNodeType(n1, n2)) {
                  patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);
              }
              else {
                  break;
              }
              i++;
          }
          // 2. sync from end
          // a (b c)
          // d e (b c)
          while (i <= e1 && i <= e2) {
              const n1 = c1[e1];
              const n2 = (c2[e2] = optimized
                  ? cloneIfMounted(c2[e2])
                  : normalizeVNode(c2[e2]));
              if (isSameVNodeType(n1, n2)) {
                  patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);
              }
              else {
                  break;
              }
              e1--;
              e2--;
          }
          // 3. common sequence + mount
          // (a b)
          // (a b) c
          // i = 2, e1 = 1, e2 = 2
          // (a b)
          // c (a b)
          // i = 0, e1 = -1, e2 = 0
          if (i > e1) {
              if (i <= e2) {
                  const nextPos = e2 + 1;
                  const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                  while (i <= e2) {
                      patch(null, (c2[i] = optimized
                          ? cloneIfMounted(c2[i])
                          : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG);
                      i++;
                  }
              }
          }
          // 4. common sequence + unmount
          // (a b) c
          // (a b)
          // i = 2, e1 = 2, e2 = 1
          // a (b c)
          // (b c)
          // i = 0, e1 = 0, e2 = -1
          else if (i > e2) {
              while (i <= e1) {
                  unmount(c1[i], parentComponent, parentSuspense, true);
                  i++;
              }
          }
          // 5. unknown sequence
          // [i ... e1 + 1]: a b [c d e] f g
          // [i ... e2 + 1]: a b [e d c h] f g
          // i = 2, e1 = 4, e2 = 5
          else {
              const s1 = i; // prev starting index
              const s2 = i; // next starting index
              // 5.1 build key:index map for newChildren
              const keyToNewIndexMap = new Map();
              for (i = s2; i <= e2; i++) {
                  const nextChild = (c2[i] = optimized
                      ? cloneIfMounted(c2[i])
                      : normalizeVNode(c2[i]));
                  if (nextChild.key != null) {
                      if ( keyToNewIndexMap.has(nextChild.key)) {
                          warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                      }
                      keyToNewIndexMap.set(nextChild.key, i);
                  }
              }
              // 5.2 loop through old children left to be patched and try to patch
              // matching nodes & remove nodes that are no longer present
              let j;
              let patched = 0;
              const toBePatched = e2 - s2 + 1;
              let moved = false;
              // used to track whether any node has moved
              let maxNewIndexSoFar = 0;
              // works as Map<newIndex, oldIndex>
              // Note that oldIndex is offset by +1
              // and oldIndex = 0 is a special value indicating the new node has
              // no corresponding old node.
              // used for determining longest stable subsequence
              const newIndexToOldIndexMap = new Array(toBePatched);
              for (i = 0; i < toBePatched; i++)
                  newIndexToOldIndexMap[i] = 0;
              for (i = s1; i <= e1; i++) {
                  const prevChild = c1[i];
                  if (patched >= toBePatched) {
                      // all new children have been patched so this can only be a removal
                      unmount(prevChild, parentComponent, parentSuspense, true);
                      continue;
                  }
                  let newIndex;
                  if (prevChild.key != null) {
                      newIndex = keyToNewIndexMap.get(prevChild.key);
                  }
                  else {
                      // key-less node, try to locate a key-less node of the same type
                      for (j = s2; j <= e2; j++) {
                          if (newIndexToOldIndexMap[j - s2] === 0 &&
                              isSameVNodeType(prevChild, c2[j])) {
                              newIndex = j;
                              break;
                          }
                      }
                  }
                  if (newIndex === undefined) {
                      unmount(prevChild, parentComponent, parentSuspense, true);
                  }
                  else {
                      newIndexToOldIndexMap[newIndex - s2] = i + 1;
                      if (newIndex >= maxNewIndexSoFar) {
                          maxNewIndexSoFar = newIndex;
                      }
                      else {
                          moved = true;
                      }
                      patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, optimized);
                      patched++;
                  }
              }
              // 5.3 move and mount
              // generate longest stable subsequence only when nodes have moved
              const increasingNewIndexSequence = moved
                  ? getSequence(newIndexToOldIndexMap)
                  : EMPTY_ARR;
              j = increasingNewIndexSequence.length - 1;
              // looping backwards so that we can use last patched node as anchor
              for (i = toBePatched - 1; i >= 0; i--) {
                  const nextIndex = s2 + i;
                  const nextChild = c2[nextIndex];
                  const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                  if (newIndexToOldIndexMap[i] === 0) {
                      // mount new
                      patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG);
                  }
                  else if (moved) {
                      // move if:
                      // There is no stable subsequence (e.g. a reverse)
                      // OR current node is not among the stable sequence
                      if (j < 0 || i !== increasingNewIndexSequence[j]) {
                          move(nextChild, container, anchor, 2 /* REORDER */);
                      }
                      else {
                          j--;
                      }
                  }
              }
          }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
          const { el, type, transition, children, shapeFlag } = vnode;
          if (shapeFlag & 6 /* COMPONENT */) {
              move(vnode.component.subTree, container, anchor, moveType);
              return;
          }
          if ( shapeFlag & 128 /* SUSPENSE */) {
              vnode.suspense.move(container, anchor, moveType);
              return;
          }
          if (shapeFlag & 64 /* TELEPORT */) {
              type.move(vnode, container, anchor, internals);
              return;
          }
          if (type === Fragment) {
              hostInsert(el, container, anchor);
              for (let i = 0; i < children.length; i++) {
                  move(children[i], container, anchor, moveType);
              }
              hostInsert(vnode.anchor, container, anchor);
              return;
          }
          // static node move can only happen when force updating HMR
          if ( type === Static) {
              moveStaticNode(vnode, container, anchor);
              return;
          }
          // single nodes
          const needTransition = moveType !== 2 /* REORDER */ &&
              shapeFlag & 1 /* ELEMENT */ &&
              transition;
          if (needTransition) {
              if (moveType === 0 /* ENTER */) {
                  transition.beforeEnter(el);
                  hostInsert(el, container, anchor);
                  queuePostRenderEffect(() => transition.enter(el), parentSuspense);
              }
              else {
                  const { leave, delayLeave, afterLeave } = transition;
                  const remove = () => hostInsert(el, container, anchor);
                  const performLeave = () => {
                      leave(el, () => {
                          remove();
                          afterLeave && afterLeave();
                      });
                  };
                  if (delayLeave) {
                      delayLeave(el, remove, performLeave);
                  }
                  else {
                      performLeave();
                  }
              }
          }
          else {
              hostInsert(el, container, anchor);
          }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false) => {
          const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
          // unset ref
          if (ref != null && parentComponent) {
              setRef(ref, null, parentComponent, parentSuspense, null);
          }
          if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
              parentComponent.ctx.deactivate(vnode);
              return;
          }
          const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;
          let vnodeHook;
          if ((vnodeHook = props && props.onVnodeBeforeUnmount)) {
              invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
          if (shapeFlag & 6 /* COMPONENT */) {
              unmountComponent(vnode.component, parentSuspense, doRemove);
          }
          else {
              if ( shapeFlag & 128 /* SUSPENSE */) {
                  vnode.suspense.unmount(parentSuspense, doRemove);
                  return;
              }
              if (shouldInvokeDirs) {
                  invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
              }
              if (dynamicChildren &&
                  // #1153: fast path should not be taken for non-stable (v-for) fragments
                  (type !== Fragment ||
                      (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {
                  // fast path for block nodes: only need to unmount dynamic children.
                  unmountChildren(dynamicChildren, parentComponent, parentSuspense);
              }
              else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                  unmountChildren(children, parentComponent, parentSuspense);
              }
              // an unmounted teleport should always remove its children
              if (shapeFlag & 64 /* TELEPORT */) {
                  vnode.type.remove(vnode, internals);
              }
              if (doRemove) {
                  remove(vnode);
              }
          }
          if ((vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
              queuePostRenderEffect(() => {
                  vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                  shouldInvokeDirs &&
                      invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
              }, parentSuspense);
          }
      };
      const remove = vnode => {
          const { type, el, anchor, transition } = vnode;
          if (type === Fragment) {
              removeFragment(el, anchor);
              return;
          }
          if ( type === Static) {
              removeStaticNode(vnode);
              return;
          }
          const performRemove = () => {
              hostRemove(el);
              if (transition && !transition.persisted && transition.afterLeave) {
                  transition.afterLeave();
              }
          };
          if (vnode.shapeFlag & 1 /* ELEMENT */ &&
              transition &&
              !transition.persisted) {
              const { leave, delayLeave } = transition;
              const performLeave = () => leave(el, performRemove);
              if (delayLeave) {
                  delayLeave(vnode.el, performRemove, performLeave);
              }
              else {
                  performLeave();
              }
          }
          else {
              performRemove();
          }
      };
      const removeFragment = (cur, end) => {
          // For fragments, directly remove all contained DOM nodes.
          // (fragment child nodes cannot have transition)
          let next;
          while (cur !== end) {
              next = hostNextSibling(cur);
              hostRemove(cur);
              cur = next;
          }
          hostRemove(end);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
          if ( instance.type.__hmrId) {
              unregisterHMR(instance);
          }
          const { bum, effects, update, subTree, um } = instance;
          // beforeUnmount hook
          if (bum) {
              invokeArrayFns(bum);
          }
          if (effects) {
              for (let i = 0; i < effects.length; i++) {
                  stop(effects[i]);
              }
          }
          // update may be null if a component is unmounted before its async
          // setup has resolved.
          if (update) {
              stop(update);
              unmount(subTree, instance, parentSuspense, doRemove);
          }
          // unmounted hook
          if (um) {
              queuePostRenderEffect(um, parentSuspense);
          }
          queuePostRenderEffect(() => {
              instance.isUnmounted = true;
          }, parentSuspense);
          // A component with async dep inside a pending suspense is unmounted before
          // its async dep resolves. This should remove the dep from the suspense, and
          // cause the suspense to resolve immediately if that was the last dep.
          if (
              parentSuspense &&
              parentSuspense.pendingBranch &&
              !parentSuspense.isUnmounted &&
              instance.asyncDep &&
              !instance.asyncResolved &&
              instance.suspenseId === parentSuspense.pendingId) {
              parentSuspense.deps--;
              if (parentSuspense.deps === 0) {
                  parentSuspense.resolve();
              }
          }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, start = 0) => {
          for (let i = start; i < children.length; i++) {
              unmount(children[i], parentComponent, parentSuspense, doRemove);
          }
      };
      const getNextHostNode = vnode => {
          if (vnode.shapeFlag & 6 /* COMPONENT */) {
              return getNextHostNode(vnode.component.subTree);
          }
          if ( vnode.shapeFlag & 128 /* SUSPENSE */) {
              return vnode.suspense.next();
          }
          return hostNextSibling((vnode.anchor || vnode.el));
      };
      /**
       * #1156
       * When a component is HMR-enabled, we need to make sure that all static nodes
       * inside a block also inherit the DOM element from the previous tree so that
       * HMR updates (which are full updates) can retrieve the element for patching.
       *
       * #2080
       * Inside keyed `template` fragment static children, if a fragment is moved,
       * the children will always moved so that need inherit el form previous nodes
       * to ensure correct moved position.
       */
      const traverseStaticChildren = (n1, n2, shallow = false) => {
          const ch1 = n1.children;
          const ch2 = n2.children;
          if (isArray(ch1) && isArray(ch2)) {
              for (let i = 0; i < ch1.length; i++) {
                  // this is only called in the optimized path so array children are
                  // guaranteed to be vnodes
                  const c1 = ch1[i];
                  const c2 = (ch2[i] = cloneIfMounted(ch2[i]));
                  if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {
                      if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {
                          c2.el = c1.el;
                      }
                      if (!shallow)
                          traverseStaticChildren(c1, c2);
                  }
                  if ( c2.type === Comment) {
                      c2.el = c1.el;
                  }
              }
          }
      };
      const render = (vnode, container) => {
          if (vnode == null) {
              if (container._vnode) {
                  unmount(container._vnode, null, null, true);
              }
          }
          else {
              // 初始化走这里
              patch(container._vnode || null, vnode, container);
          }
          flushPostFlushCbs();
          container._vnode = vnode;
      };
      const internals = {
          p: patch,
          um: unmount,
          m: move,
          r: remove,
          mt: mountComponent,
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          n: getNextHostNode,
          o: options
      };
      let hydrate;
      let hydrateNode;
      if (createHydrationFns) {
          [hydrate, hydrateNode] = createHydrationFns(internals);
      }
      // 返回的渲染器在这里
      return {
          render,
          hydrate,
          createApp: createAppAPI(render, hydrate)
      };
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [
          vnode,
          prevVNode
      ]);
  }
  // https://en.wikipedia.org/wiki/Longest_increasing_subsequence
  function getSequence(arr) {
      const p = arr.slice();
      const result = [0];
      let i, j, u, v, c;
      const len = arr.length;
      for (i = 0; i < len; i++) {
          const arrI = arr[i];
          if (arrI !== 0) {
              j = result[result.length - 1];
              if (arr[j] < arrI) {
                  p[i] = j;
                  result.push(i);
                  continue;
              }
              u = 0;
              v = result.length - 1;
              while (u < v) {
                  c = ((u + v) / 2) | 0;
                  if (arr[result[c]] < arrI) {
                      u = c + 1;
                  }
                  else {
                      v = c;
                  }
              }
              if (arrI < arr[result[u]]) {
                  if (u > 0) {
                      p[i] = result[u - 1];
                  }
                  result[u] = i;
              }
          }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
          result[u] = v;
          v = p[v];
      }
      return result;
  }

  // Simple effect.
  function watchEffect(effect, options) {
      return doWatch(effect, null, options);
  }
  // initial value for watchers to trigger on undefined initial values
  const INITIAL_WATCHER_VALUE = {};
  // implementation
  function watch(source, cb, options) {
      if ( !isFunction(cb)) {
          warn(`\`watch(fn, options?)\` signature has been moved to a separate API. ` +
              `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` +
              `supports \`watch(source, cb, options?) signature.`);
      }
      return doWatch(source, cb, options);
  }
  function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ, instance = currentInstance) {
      if ( !cb) {
          if (immediate !== undefined) {
              warn(`watch() "immediate" option is only respected when using the ` +
                  `watch(source, callback, options?) signature.`);
          }
          if (deep !== undefined) {
              warn(`watch() "deep" option is only respected when using the ` +
                  `watch(source, callback, options?) signature.`);
          }
      }
      const warnInvalidSource = (s) => {
          warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +
              `a reactive object, or an array of these types.`);
      };
      let getter;
      const isRefSource = isRef(source);
      if (isRefSource) {
          getter = () => source.value;
      }
      else if (isReactive(source)) {
          getter = () => source;
          deep = true;
      }
      else if (isArray(source)) {
          getter = () => source.map(s => {
              if (isRef(s)) {
                  return s.value;
              }
              else if (isReactive(s)) {
                  return traverse(s);
              }
              else if (isFunction(s)) {
                  return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);
              }
              else {
                   warnInvalidSource(s);
              }
          });
      }
      else if (isFunction(source)) {
          if (cb) {
              // getter with cb
              getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);
          }
          else {
              // no cb -> simple effect
              getter = () => {
                  if (instance && instance.isUnmounted) {
                      return;
                  }
                  if (cleanup) {
                      cleanup();
                  }
                  return callWithErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);
              };
          }
      }
      else {
          getter = NOOP;
           warnInvalidSource(source);
      }
      if (cb && deep) {
          const baseGetter = getter;
          getter = () => traverse(baseGetter());
      }
      let cleanup;
      const onInvalidate = (fn) => {
          cleanup = runner.options.onStop = () => {
              callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);
          };
      };
      let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE;
      const job = () => {
          if (!runner.active) {
              return;
          }
          if (cb) {
              // watch(source, cb)
              const newValue = runner();
              if (deep || isRefSource || hasChanged(newValue, oldValue)) {
                  // cleanup before running cb again
                  if (cleanup) {
                      cleanup();
                  }
                  callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                      newValue,
                      // pass undefined as the old value when it's changed for the first time
                      oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                      onInvalidate
                  ]);
                  oldValue = newValue;
              }
          }
          else {
              // watchEffect
              runner();
          }
      };
      // important: mark the job as a watcher callback so that scheduler knows it
      // it is allowed to self-trigger (#1727)
      job.allowRecurse = !!cb;
      let scheduler;
      if (flush === 'sync') {
          scheduler = job;
      }
      else if (flush === 'post') {
          scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
      }
      else {
          // default: 'pre'
          scheduler = () => {
              if (!instance || instance.isMounted) {
                  queuePreFlushCb(job);
              }
              else {
                  // with 'pre' option, the first call must happen before
                  // the component is mounted so it is called synchronously.
                  job();
              }
          };
      }
      const runner = effect(getter, {
          lazy: true,
          onTrack,
          onTrigger,
          scheduler
      });
      recordInstanceBoundEffect(runner);
      // initial run
      if (cb) {
          if (immediate) {
              job();
          }
          else {
              oldValue = runner();
          }
      }
      else if (flush === 'post') {
          queuePostRenderEffect(runner, instance && instance.suspense);
      }
      else {
          runner();
      }
      return () => {
          stop(runner);
          if (instance) {
              remove(instance.effects, runner);
          }
      };
  }
  // this.$watch
  function instanceWatch(source, cb, options) {
      const publicThis = this.proxy;
      const getter = isString(source)
          ? () => publicThis[source]
          : source.bind(publicThis);
      return doWatch(getter, cb.bind(publicThis), options, this);
  }
  function traverse(value, seen = new Set()) {
      if (!isObject(value) || seen.has(value)) {
          return value;
      }
      seen.add(value);
      if (isRef(value)) {
          traverse(value.value, seen);
      }
      else if (isArray(value)) {
          for (let i = 0; i < value.length; i++) {
              traverse(value[i], seen);
          }
      }
      else if (isMap(value)) {
          value.forEach((_, key) => {
              // to register mutation dep for existing keys
              traverse(value.get(key), seen);
          });
      }
      else if (isSet(value)) {
          value.forEach(v => {
              traverse(v, seen);
          });
      }
      else {
          for (const key in value) {
              traverse(value[key], seen);
          }
      }
      return value;
  }

  function provide(key, value) {
      if (!currentInstance) {
          {
              warn(`provide() can only be used inside setup().`);
          }
      }
      else {
          let provides = currentInstance.provides;
          // by default an instance inherits its parent's provides object
          // but when it needs to provide values of its own, it creates its
          // own provides object using parent provides object as prototype.
          // this way in `inject` we can simply look up injections from direct
          // parent and let the prototype chain do the work.
          const parentProvides = currentInstance.parent && currentInstance.parent.provides;
          if (parentProvides === provides) {
              provides = currentInstance.provides = Object.create(parentProvides);
          }
          // TS doesn't allow symbol as index type
          provides[key] = value;
      }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
      // fallback to `currentRenderingInstance` so that this can be called in
      // a functional component
      const instance = currentInstance || currentRenderingInstance;
      if (instance) {
          const provides = instance.provides;
          if (key in provides) {
              // TS doesn't allow symbol as index type
              return provides[key];
          }
          else if (arguments.length > 1) {
              return treatDefaultAsFactory && isFunction(defaultValue)
                  ? defaultValue()
                  : defaultValue;
          }
          else {
              warn(`injection "${String(key)}" not found.`);
          }
      }
      else {
          warn(`inject() can only be used inside setup() or functional components.`);
      }
  }

  function createDuplicateChecker() {
      const cache = Object.create(null);
      return (type, key) => {
          if (cache[key]) {
              warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
          }
          else {
              cache[key] = type;
          }
      };
  }
  let isInBeforeCreate = false;
  function applyOptions(instance, options, deferredData = [], deferredWatch = [], asMixin = false) {
      const { 
      // composition
      mixins, extends: extendsOptions, 
      // state
      data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, 
      // assets
      components, directives, 
      // lifecycle
      beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured } = options;
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      const globalMixins = instance.appContext.mixins;
      if (asMixin && render && instance.render === NOOP) {
          instance.render = render;
      }
      // applyOptions is called non-as-mixin once per instance
      if (!asMixin) {
          isInBeforeCreate = true;
          callSyncHook('beforeCreate', options, publicThis, globalMixins);
          isInBeforeCreate = false;
          // global mixins are applied first
          applyMixins(instance, globalMixins, deferredData, deferredWatch);
      }
      // extending a base component...
      if (extendsOptions) {
          applyOptions(instance, extendsOptions, deferredData, deferredWatch, true);
      }
      // local mixins
      if (mixins) {
          applyMixins(instance, mixins, deferredData, deferredWatch);
      }
      const checkDuplicateProperties =  createDuplicateChecker() ;
      {
          const [propsOptions] = instance.propsOptions;
          if (propsOptions) {
              for (const key in propsOptions) {
                  checkDuplicateProperties("Props" /* PROPS */, key);
              }
          }
      }
      // options initialization order (to be consistent with Vue 2):
      // - props (already done outside of this function)
      // - inject
      // - methods
      // - data (deferred since it relies on `this` access)
      // - computed
      // - watch (deferred since it relies on `this` access)
      if (injectOptions) {
          if (isArray(injectOptions)) {
              for (let i = 0; i < injectOptions.length; i++) {
                  const key = injectOptions[i];
                  ctx[key] = inject(key);
                  {
                      checkDuplicateProperties("Inject" /* INJECT */, key);
                  }
              }
          }
          else {
              for (const key in injectOptions) {
                  const opt = injectOptions[key];
                  if (isObject(opt)) {
                      ctx[key] = inject(opt.from || key, opt.default, true /* treat default function as factory */);
                  }
                  else {
                      ctx[key] = inject(opt);
                  }
                  {
                      checkDuplicateProperties("Inject" /* INJECT */, key);
                  }
              }
          }
      }
      if (methods) {
          for (const key in methods) {
              const methodHandler = methods[key];
              if (isFunction(methodHandler)) {
                  ctx[key] = methodHandler.bind(publicThis);
                  {
                      checkDuplicateProperties("Methods" /* METHODS */, key);
                  }
              }
              else {
                  warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. ` +
                      `Did you reference the function correctly?`);
              }
          }
      }
      if (!asMixin) {
          if (deferredData.length) {
              deferredData.forEach(dataFn => resolveData(instance, dataFn, publicThis));
          }
          // data选项的响应式处理
          if (dataOptions) {
              resolveData(instance, dataOptions, publicThis);
          }
          {
              const rawData = toRaw(instance.data);
              for (const key in rawData) {
                  checkDuplicateProperties("Data" /* DATA */, key);
                  // expose data on ctx during dev
                  if (key[0] !== '$' && key[0] !== '_') {
                      Object.defineProperty(ctx, key, {
                          configurable: true,
                          enumerable: true,
                          get: () => rawData[key],
                          set: NOOP
                      });
                  }
              }
          }
      }
      else if (dataOptions) {
          deferredData.push(dataOptions);
      }
      if (computedOptions) {
          for (const key in computedOptions) {
              const opt = computedOptions[key];
              const get = isFunction(opt)
                  ? opt.bind(publicThis, publicThis)
                  : isFunction(opt.get)
                      ? opt.get.bind(publicThis, publicThis)
                      : NOOP;
              if ( get === NOOP) {
                  warn(`Computed property "${key}" has no getter.`);
              }
              const set = !isFunction(opt) && isFunction(opt.set)
                  ? opt.set.bind(publicThis)
                  :  () => {
                          warn(`Write operation failed: computed property "${key}" is readonly.`);
                      }
                      ;
              const c = computed$1({
                  get,
                  set
              });
              Object.defineProperty(ctx, key, {
                  enumerable: true,
                  configurable: true,
                  get: () => c.value,
                  set: v => (c.value = v)
              });
              {
                  checkDuplicateProperties("Computed" /* COMPUTED */, key);
              }
          }
      }
      if (watchOptions) {
          deferredWatch.push(watchOptions);
      }
      if (!asMixin && deferredWatch.length) {
          deferredWatch.forEach(watchOptions => {
              for (const key in watchOptions) {
                  createWatcher(watchOptions[key], ctx, publicThis, key);
              }
          });
      }
      if (provideOptions) {
          const provides = isFunction(provideOptions)
              ? provideOptions.call(publicThis)
              : provideOptions;
          for (const key in provides) {
              provide(key, provides[key]);
          }
      }
      // asset options.
      // To reduce memory usage, only components with mixins or extends will have
      // resolved asset registry attached to instance.
      if (asMixin) {
          if (components) {
              extend(instance.components ||
                  (instance.components = extend({}, instance.type.components)), components);
          }
          if (directives) {
              extend(instance.directives ||
                  (instance.directives = extend({}, instance.type.directives)), directives);
          }
      }
      // lifecycle options
      if (!asMixin) {
          callSyncHook('created', options, publicThis, globalMixins);
      }
      if (beforeMount) {
          onBeforeMount(beforeMount.bind(publicThis));
      }
      if (mounted) {
          onMounted(mounted.bind(publicThis));
      }
      if (beforeUpdate) {
          onBeforeUpdate(beforeUpdate.bind(publicThis));
      }
      if (updated) {
          onUpdated(updated.bind(publicThis));
      }
      if (activated) {
          onActivated(activated.bind(publicThis));
      }
      if (deactivated) {
          onDeactivated(deactivated.bind(publicThis));
      }
      if (errorCaptured) {
          onErrorCaptured(errorCaptured.bind(publicThis));
      }
      if (renderTracked) {
          onRenderTracked(renderTracked.bind(publicThis));
      }
      if (renderTriggered) {
          onRenderTriggered(renderTriggered.bind(publicThis));
      }
      if ( beforeDestroy) {
          warn(`\`beforeDestroy\` has been renamed to \`beforeUnmount\`.`);
      }
      if (beforeUnmount) {
          onBeforeUnmount(beforeUnmount.bind(publicThis));
      }
      if ( destroyed) {
          warn(`\`destroyed\` has been renamed to \`unmounted\`.`);
      }
      if (unmounted) {
          onUnmounted(unmounted.bind(publicThis));
      }
  }
  function callSyncHook(name, options, ctx, globalMixins) {
      callHookFromMixins(name, globalMixins, ctx);
      const { extends: base, mixins } = options;
      if (base) {
          callHookFromExtends(name, base, ctx);
      }
      if (mixins) {
          callHookFromMixins(name, mixins, ctx);
      }
      const selfHook = options[name];
      if (selfHook) {
          selfHook.call(ctx);
      }
  }
  function callHookFromExtends(name, base, ctx) {
      if (base.extends) {
          callHookFromExtends(name, base.extends, ctx);
      }
      const baseHook = base[name];
      if (baseHook) {
          baseHook.call(ctx);
      }
  }
  function callHookFromMixins(name, mixins, ctx) {
      for (let i = 0; i < mixins.length; i++) {
          const chainedMixins = mixins[i].mixins;
          if (chainedMixins) {
              callHookFromMixins(name, chainedMixins, ctx);
          }
          const fn = mixins[i][name];
          if (fn) {
              fn.call(ctx);
          }
      }
  }
  function applyMixins(instance, mixins, deferredData, deferredWatch) {
      for (let i = 0; i < mixins.length; i++) {
          applyOptions(instance, mixins[i], deferredData, deferredWatch, true);
      }
  }
  function resolveData(instance, dataFn, publicThis) {
      if ( !isFunction(dataFn)) {
          warn(`The data option must be a function. ` +
              `Plain object usage is no longer supported.`);
      }
      // 获取data函数返回的对象
      const data = dataFn.call(publicThis, publicThis);
      if ( isPromise(data)) {
          warn(`data() returned a Promise - note data() cannot be async; If you ` +
              `intend to perform data fetching before component renders, use ` +
              `async setup() + <Suspense>.`);
      }
      if (!isObject(data)) {
           warn(`data() should return an object.`);
      }
      else if (instance.data === EMPTY_OBJ) {
          // 其实data还是使用reactive做的响应式
          instance.data = reactive(data);
      }
      else {
          // existing data: this is a mixin or extends.
          extend(instance.data, data);
      }
  }
  function createWatcher(raw, ctx, publicThis, key) {
      const getter = key.includes('.')
          ? createPathGetter(publicThis, key)
          : () => publicThis[key];
      if (isString(raw)) {
          const handler = ctx[raw];
          if (isFunction(handler)) {
              watch(getter, handler);
          }
          else {
              warn(`Invalid watch handler specified by key "${raw}"`, handler);
          }
      }
      else if (isFunction(raw)) {
          watch(getter, raw.bind(publicThis));
      }
      else if (isObject(raw)) {
          if (isArray(raw)) {
              raw.forEach(r => createWatcher(r, ctx, publicThis, key));
          }
          else {
              const handler = isFunction(raw.handler)
                  ? raw.handler.bind(publicThis)
                  : ctx[raw.handler];
              if (isFunction(handler)) {
                  watch(getter, handler, raw);
              }
              else {
                  warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
              }
          }
      }
      else {
          warn(`Invalid watch option: "${key}"`, raw);
      }
  }
  function createPathGetter(ctx, path) {
      const segments = path.split('.');
      return () => {
          let cur = ctx;
          for (let i = 0; i < segments.length && cur; i++) {
              cur = cur[segments[i]];
          }
          return cur;
      };
  }
  function resolveMergedOptions(instance) {
      const raw = instance.type;
      const { __merged, mixins, extends: extendsOptions } = raw;
      if (__merged)
          return __merged;
      const globalMixins = instance.appContext.mixins;
      if (!globalMixins.length && !mixins && !extendsOptions)
          return raw;
      const options = {};
      globalMixins.forEach(m => mergeOptions(options, m, instance));
      mergeOptions(options, raw, instance);
      return (raw.__merged = options);
  }
  function mergeOptions(to, from, instance) {
      const strats = instance.appContext.config.optionMergeStrategies;
      const { mixins, extends: extendsOptions } = from;
      extendsOptions && mergeOptions(to, extendsOptions, instance);
      mixins &&
          mixins.forEach((m) => mergeOptions(to, m, instance));
      for (const key in from) {
          if (strats && hasOwn(strats, key)) {
              to[key] = strats[key](to[key], from[key], instance.proxy, key);
          }
          else {
              to[key] = from[key];
          }
      }
  }

  const publicPropertiesMap = extend(Object.create(null), {
      $: i => i,
      $el: i => i.vnode.el,
      $data: i => i.data,
      $props: i => ( shallowReadonly(i.props) ),
      $attrs: i => ( shallowReadonly(i.attrs) ),
      $slots: i => ( shallowReadonly(i.slots) ),
      $refs: i => ( shallowReadonly(i.refs) ),
      $parent: i => i.parent && i.parent.proxy,
      $root: i => i.root && i.root.proxy,
      $emit: i => i.emit,
      $options: i => ( resolveMergedOptions(i) ),
      $forceUpdate: i => () => queueJob(i.update),
      $nextTick: () => nextTick,
      $watch: i => ( instanceWatch.bind(i) )
  });
  const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
          const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
          // let @vue/reactivity know it should never observe Vue public instances.
          if (key === "__v_skip" /* SKIP */) {
              return true;
          }
          // data / props / ctx
          // This getter gets called for every property access on the render context
          // during render and is a major hotspot. The most expensive part of this
          // is the multiple hasOwn() calls. It's much faster to do a simple property
          // access on a plain object, so we use an accessCache object (with null
          // prototype) to memoize what access type a key corresponds to.
          let normalizedProps;
          if (key[0] !== '$') {
              const n = accessCache[key];
              if (n !== undefined) {
                  switch (n) {
                      case 0 /* SETUP */:
                          return setupState[key];
                      case 1 /* DATA */:
                          return data[key];
                      case 3 /* CONTEXT */:
                          return ctx[key];
                      case 2 /* PROPS */:
                          return props[key];
                      // default: just fallthrough
                  }
              }
              else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
                  accessCache[key] = 0 /* SETUP */;
                  return setupState[key];
              }
              else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
                  accessCache[key] = 1 /* DATA */;
                  return data[key];
              }
              else if (
              // only cache other properties when instance has declared (thus stable)
              // props
              (normalizedProps = instance.propsOptions[0]) &&
                  hasOwn(normalizedProps, key)) {
                  accessCache[key] = 2 /* PROPS */;
                  return props[key];
              }
              else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
                  accessCache[key] = 3 /* CONTEXT */;
                  return ctx[key];
              }
              else if ( !isInBeforeCreate) {
                  accessCache[key] = 4 /* OTHER */;
              }
          }
          const publicGetter = publicPropertiesMap[key];
          let cssModule, globalProperties;
          // public $xxx properties
          if (publicGetter) {
              if (key === '$attrs') {
                  track(instance, "get" /* GET */, key);
                   markAttrsAccessed();
              }
              return publicGetter(instance);
          }
          else if (
          // css module (injected by vue-loader)
          (cssModule = type.__cssModules) &&
              (cssModule = cssModule[key])) {
              return cssModule;
          }
          else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
              // user may set custom properties to `this` that start with `$`
              accessCache[key] = 3 /* CONTEXT */;
              return ctx[key];
          }
          else if (
          // global properties
          ((globalProperties = appContext.config.globalProperties),
              hasOwn(globalProperties, key))) {
              return globalProperties[key];
          }
          else if (
              currentRenderingInstance &&
              (!isString(key) ||
                  // #1091 avoid internal isRef/isVNode checks on component instance leading
                  // to infinite warning loop
                  key.indexOf('__v') !== 0)) {
              if (data !== EMPTY_OBJ &&
                  (key[0] === '$' || key[0] === '_') &&
                  hasOwn(data, key)) {
                  warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +
                      `character ("$" or "_") and is not proxied on the render context.`);
              }
              else {
                  warn(`Property ${JSON.stringify(key)} was accessed during render ` +
                      `but is not defined on instance.`);
              }
          }
      },
      set({ _: instance }, key, value) {
          const { data, setupState, ctx } = instance;
          if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
              setupState[key] = value;
          }
          else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
              data[key] = value;
          }
          else if (key in instance.props) {
              
                  warn(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
              return false;
          }
          if (key[0] === '$' && key.slice(1) in instance) {
              
                  warn(`Attempting to mutate public property "${key}". ` +
                      `Properties starting with $ are reserved and readonly.`, instance);
              return false;
          }
          else {
              if ( key in instance.appContext.config.globalProperties) {
                  Object.defineProperty(ctx, key, {
                      enumerable: true,
                      configurable: true,
                      value
                  });
              }
              else {
                  ctx[key] = value;
              }
          }
          return true;
      },
      has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
          let normalizedProps;
          return (accessCache[key] !== undefined ||
              (data !== EMPTY_OBJ && hasOwn(data, key)) ||
              (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||
              ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||
              hasOwn(ctx, key) ||
              hasOwn(publicPropertiesMap, key) ||
              hasOwn(appContext.config.globalProperties, key));
      }
  };
  {
      PublicInstanceProxyHandlers.ownKeys = (target) => {
          warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +
              `The keys will be empty in production mode to avoid performance overhead.`);
          return Reflect.ownKeys(target);
      };
  }
  const RuntimeCompiledPublicInstanceProxyHandlers = extend({}, PublicInstanceProxyHandlers, {
      get(target, key) {
          // fast path for unscopables when using `with` block
          if (key === Symbol.unscopables) {
              return;
          }
          return PublicInstanceProxyHandlers.get(target, key, target);
      },
      has(_, key) {
          const has = key[0] !== '_' && !isGloballyWhitelisted(key);
          if ( !has && PublicInstanceProxyHandlers.has(_, key)) {
              warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
          }
          return has;
      }
  });
  // In dev mode, the proxy target exposes the same properties as seen on `this`
  // for easier console inspection. In prod mode it will be an empty object so
  // these properties definitions can be skipped.
  function createRenderContext(instance) {
      const target = {};
      // expose internal instance for proxy handlers
      Object.defineProperty(target, `_`, {
          configurable: true,
          enumerable: false,
          get: () => instance
      });
      // expose public properties
      Object.keys(publicPropertiesMap).forEach(key => {
          Object.defineProperty(target, key, {
              configurable: true,
              enumerable: false,
              get: () => publicPropertiesMap[key](instance),
              // intercepted by the proxy so no need for implementation,
              // but needed to prevent set errors
              set: NOOP
          });
      });
      // expose global properties
      const { globalProperties } = instance.appContext.config;
      Object.keys(globalProperties).forEach(key => {
          Object.defineProperty(target, key, {
              configurable: true,
              enumerable: false,
              get: () => globalProperties[key],
              set: NOOP
          });
      });
      return target;
  }
  // dev only
  function exposePropsOnRenderContext(instance) {
      const { ctx, propsOptions: [propsOptions] } = instance;
      if (propsOptions) {
          Object.keys(propsOptions).forEach(key => {
              Object.defineProperty(ctx, key, {
                  enumerable: true,
                  configurable: true,
                  get: () => instance.props[key],
                  set: NOOP
              });
          });
      }
  }
  // dev only
  function exposeSetupStateOnRenderContext(instance) {
      const { ctx, setupState } = instance;
      Object.keys(toRaw(setupState)).forEach(key => {
          if (key[0] === '$' || key[0] === '_') {
              warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" ` +
                  `which are reserved prefixes for Vue internals.`);
              return;
          }
          Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => setupState[key],
              set: NOOP
          });
      });
  }

  const emptyAppContext = createAppContext();
  let uid$2 = 0;
  function createComponentInstance(vnode, parent, suspense) {
      const type = vnode.type;
      // inherit parent app context - or - if root, adopt from root vnode
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
          uid: uid$2++,
          vnode,
          type,
          parent,
          appContext,
          root: null,
          next: null,
          subTree: null,
          update: null,
          render: null,
          proxy: null,
          withProxy: null,
          effects: null,
          provides: parent ? parent.provides : Object.create(appContext.provides),
          accessCache: null,
          renderCache: [],
          // local resovled assets
          components: null,
          directives: null,
          // resolved props and emits options
          propsOptions: normalizePropsOptions(type, appContext),
          emitsOptions: normalizeEmitsOptions(type, appContext),
          // emit
          emit: null,
          emitted: null,
          // state
          ctx: EMPTY_OBJ,
          data: EMPTY_OBJ,
          props: EMPTY_OBJ,
          attrs: EMPTY_OBJ,
          slots: EMPTY_OBJ,
          refs: EMPTY_OBJ,
          setupState: EMPTY_OBJ,
          setupContext: null,
          // suspense related
          suspense,
          suspenseId: suspense ? suspense.pendingId : 0,
          asyncDep: null,
          asyncResolved: false,
          // lifecycle hooks
          // not using enums here because it results in computed properties
          isMounted: false,
          isUnmounted: false,
          isDeactivated: false,
          bc: null,
          c: null,
          bm: null,
          m: null,
          bu: null,
          u: null,
          um: null,
          bum: null,
          da: null,
          a: null,
          rtg: null,
          rtc: null,
          ec: null
      };
      {
          instance.ctx = createRenderContext(instance);
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      return instance;
  }
  let currentInstance = null;
  const setCurrentInstance = (instance) => {
      currentInstance = instance;
  };
  const isBuiltInTag = /*#__PURE__*/ makeMap('slot,component');
  function validateComponentName(name, config) {
      const appIsNativeTag = config.isNativeTag || NO;
      if (isBuiltInTag(name) || appIsNativeTag(name)) {
          warn('Do not use built-in or reserved HTML elements as component id: ' + name);
      }
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false) {
      isInSSRComponentSetup = isSSR;
      const { props, children, shapeFlag } = instance.vnode;
      const isStateful = shapeFlag & 4 /* STATEFUL_COMPONENT */;
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children);
      // 组件
      const setupResult = isStateful
          ? setupStatefulComponent(instance, isSSR)
          : undefined;
      isInSSRComponentSetup = false;
      return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      {
          if (Component.name) {
              validateComponentName(Component.name, instance.appContext.config);
          }
          if (Component.components) {
              const names = Object.keys(Component.components);
              for (let i = 0; i < names.length; i++) {
                  validateComponentName(names[i], instance.appContext.config);
              }
          }
          if (Component.directives) {
              const names = Object.keys(Component.directives);
              for (let i = 0; i < names.length; i++) {
                  validateDirectiveName(names[i]);
              }
          }
      }
      // 0. create render proxy property access cache
      instance.accessCache = {};
      // 1. create public instance / render proxy
      // also mark it raw so it's never observed
      // proxy是一个响应式对象
      instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
      {
          exposePropsOnRenderContext(instance);
      }
      // 2. call setup()
      // 处理用户配置的setup选项
      const { setup } = Component;
      if (setup) {
          const setupContext = (instance.setupContext =
              setup.length > 1 ? createSetupContext(instance) : null);
          currentInstance = instance;
          pauseTracking();
          // 执行setup
          // setup(props, setupContext)
          // {slots, attrs, emit}
          const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [ shallowReadonly(instance.props) , setupContext]);
          resetTracking();
          currentInstance = null;
          if (isPromise(setupResult)) {
              if (isSSR) {
                  // return the promise so server-renderer can wait on it
                  return setupResult.then((resolvedResult) => {
                      handleSetupResult(instance, resolvedResult);
                  });
              }
              else {
                  // async setup returned Promise.
                  // bail here and wait for re-entry.
                  instance.asyncDep = setupResult;
              }
          }
          else {
              handleSetupResult(instance, setupResult);
          }
      }
      else {
          // 传统选项方式走这里
          finishComponentSetup(instance);
      }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction(setupResult)) {
          // setup returned an inline render function
          instance.render = setupResult;
      }
      else if (isObject(setupResult)) {
          if ( isVNode(setupResult)) {
              warn(`setup() should not return VNodes directly - ` +
                  `return a render function instead.`);
          }
          // setup returned bindings.
          // assuming a render function compiled from template is present.
          {
              instance.devtoolsRawSetupState = setupResult;
          }
          instance.setupState = proxyRefs(setupResult);
          {
              exposeSetupStateOnRenderContext(instance);
          }
      }
      else if ( setupResult !== undefined) {
          warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);
      }
      finishComponentSetup(instance);
  }
  // 处理除了setup之外的其他选项
  function finishComponentSetup(instance, isSSR) {
      const Component = instance.type;
      // template / render function normalization
      if (!instance.render) {
          instance.render = (Component.render || NOOP);
          // for runtime-compiled render functions using `with` blocks, the render
          // proxy used needs a different `has` handler which is more performant and
          // also only allows a whitelist of globals to fallthrough.
          if (instance.render._rc) {
              instance.withProxy = new Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
          }
      }
      // support for 2.x options
      // 支持2.0选项api
      {
          currentInstance = instance;
          applyOptions(instance, Component);
          currentInstance = null;
      }
      // warn missing template/render
      if ( !Component.render && instance.render === NOOP) {
          /* istanbul ignore if */
          if ( Component.template) {
              warn(`Component provided template option but ` +
                  `runtime compilation is not supported in this build of Vue.` +
                  (   ` Use "vue.global.js" instead.`
                              ) /* should not happen */);
          }
          else {
              warn(`Component is missing template or render function.`);
          }
      }
  }
  const attrHandlers = {
      get: (target, key) => {
          {
              markAttrsAccessed();
          }
          return target[key];
      },
      set: () => {
          warn(`setupContext.attrs is readonly.`);
          return false;
      },
      deleteProperty: () => {
          warn(`setupContext.attrs is readonly.`);
          return false;
      }
  };
  function createSetupContext(instance) {
      {
          // We use getters in dev in case libs like test-utils overwrite instance
          // properties (overwrites should not be done in prod)
          return Object.freeze({
              get attrs() {
                  return new Proxy(instance.attrs, attrHandlers);
              },
              get slots() {
                  return shallowReadonly(instance.slots);
              },
              get emit() {
                  return (event, ...args) => instance.emit(event, ...args);
              }
          });
      }
  }
  // record effects created during a component's setup() so that they can be
  // stopped when the component unmounts
  function recordInstanceBoundEffect(effect) {
      if (currentInstance) {
          (currentInstance.effects || (currentInstance.effects = [])).push(effect);
      }
  }
  const classifyRE = /(?:^|[-_])(\w)/g;
  const classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');
  /* istanbul ignore next */
  function formatComponentName(instance, Component, isRoot = false) {
      let name = isFunction(Component)
          ? Component.displayName || Component.name
          : Component.name;
      if (!name && Component.__file) {
          const match = Component.__file.match(/([^/\\]+)\.vue$/);
          if (match) {
              name = match[1];
          }
      }
      if (!name && instance && instance.parent) {
          // try to infer the name based on reverse resolution
          const inferFromRegistry = (registry) => {
              for (const key in registry) {
                  if (registry[key] === Component) {
                      return key;
                  }
              }
          };
          name =
              inferFromRegistry(instance.components ||
                  instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
      }
      return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
      return isFunction(value) && '__vccOpts' in value;
  }

  function computed$1(getterOrOptions) {
      const c = computed(getterOrOptions);
      recordInstanceBoundEffect(c.effect);
      return c;
  }

  // Actual implementation
  function h(type, propsOrChildren, children) {
      const l = arguments.length;
      if (l === 2) {
          if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
              // single vnode without props
              if (isVNode(propsOrChildren)) {
                  return createVNode(type, null, [propsOrChildren]);
              }
              // props without children
              return createVNode(type, propsOrChildren);
          }
          else {
              // omit props
              return createVNode(type, null, propsOrChildren);
          }
      }
      else {
          if (l > 3) {
              children = Array.prototype.slice.call(arguments, 2);
          }
          else if (l === 3 && isVNode(children)) {
              children = [children];
          }
          return createVNode(type, propsOrChildren, children);
      }
  }

  // Core API ------------------------------------------------------------------
  const version = "3.0.0";

  const svgNS = 'http://www.w3.org/2000/svg';
  const doc = (typeof document !== 'undefined' ? document : null);
  let tempContainer;
  let tempSVGContainer;
  const nodeOps = {
      insert: (child, parent, anchor) => {
          parent.insertBefore(child, anchor || null);
      },
      remove: child => {
          const parent = child.parentNode;
          if (parent) {
              parent.removeChild(child);
          }
      },
      createElement: (tag, isSVG, is) => isSVG
          ? doc.createElementNS(svgNS, tag)
          : doc.createElement(tag, is ? { is } : undefined),
      createText: text => doc.createTextNode(text),
      createComment: text => doc.createComment(text),
      setText: (node, text) => {
          node.nodeValue = text;
      },
      setElementText: (el, text) => {
          el.textContent = text;
      },
      parentNode: node => node.parentNode,
      nextSibling: node => node.nextSibling,
      querySelector: selector => doc.querySelector(selector),
      setScopeId(el, id) {
          el.setAttribute(id, '');
      },
      cloneNode(el) {
          return el.cloneNode(true);
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent, anchor, isSVG) {
          const temp = isSVG
              ? tempSVGContainer ||
                  (tempSVGContainer = doc.createElementNS(svgNS, 'svg'))
              : tempContainer || (tempContainer = doc.createElement('div'));
          temp.innerHTML = content;
          const first = temp.firstChild;
          let node = first;
          let last = node;
          while (node) {
              last = node;
              nodeOps.insert(node, parent, anchor);
              node = temp.firstChild;
          }
          return [first, last];
      }
  };

  // compiler should normalize class + :class bindings on the same element
  // into a single binding ['staticClass', dynamic]
  function patchClass(el, value, isSVG) {
      if (value == null) {
          value = '';
      }
      if (isSVG) {
          el.setAttribute('class', value);
      }
      else {
          // directly setting className should be faster than setAttribute in theory
          // if this is an element during a transition, take the temporary transition
          // classes into account.
          const transitionClasses = el._vtc;
          if (transitionClasses) {
              value = (value
                  ? [value, ...transitionClasses]
                  : [...transitionClasses]).join(' ');
          }
          el.className = value;
      }
  }

  function patchStyle(el, prev, next) {
      const style = el.style;
      if (!next) {
          el.removeAttribute('style');
      }
      else if (isString(next)) {
          if (prev !== next) {
              style.cssText = next;
          }
      }
      else {
          for (const key in next) {
              setStyle(style, key, next[key]);
          }
          if (prev && !isString(prev)) {
              for (const key in prev) {
                  if (next[key] == null) {
                      setStyle(style, key, '');
                  }
              }
          }
      }
  }
  const importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
      if (isArray(val)) {
          val.forEach(v => setStyle(style, name, v));
      }
      else {
          if (name.startsWith('--')) {
              // custom property definition
              style.setProperty(name, val);
          }
          else {
              const prefixed = autoPrefix(style, name);
              if (importantRE.test(val)) {
                  // !important
                  style.setProperty(hyphenate(prefixed), val.replace(importantRE, ''), 'important');
              }
              else {
                  style[prefixed] = val;
              }
          }
      }
  }
  const prefixes = ['Webkit', 'Moz', 'ms'];
  const prefixCache = {};
  function autoPrefix(style, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
          return cached;
      }
      let name = camelize(rawName);
      if (name !== 'filter' && name in style) {
          return (prefixCache[rawName] = name);
      }
      name = capitalize(name);
      for (let i = 0; i < prefixes.length; i++) {
          const prefixed = prefixes[i] + name;
          if (prefixed in style) {
              return (prefixCache[rawName] = prefixed);
          }
      }
      return rawName;
  }

  const xlinkNS = 'http://www.w3.org/1999/xlink';
  function patchAttr(el, key, value, isSVG) {
      if (isSVG && key.startsWith('xlink:')) {
          if (value == null) {
              el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
          }
          else {
              el.setAttributeNS(xlinkNS, key, value);
          }
      }
      else {
          // note we are only checking boolean attributes that don't have a
          // corresponding dom prop of the same name here.
          const isBoolean = isSpecialBooleanAttr(key);
          if (value == null || (isBoolean && value === false)) {
              el.removeAttribute(key);
          }
          else {
              el.setAttribute(key, isBoolean ? '' : value);
          }
      }
  }

  // __UNSAFE__
  // functions. The user is responsible for using them with only trusted content.
  function patchDOMProp(el, key, value, 
  // the following args are passed only due to potential innerHTML/textContent
  // overriding existing VNodes, in which case the old tree must be properly
  // unmounted.
  prevChildren, parentComponent, parentSuspense, unmountChildren) {
      if (key === 'innerHTML' || key === 'textContent') {
          if (prevChildren) {
              unmountChildren(prevChildren, parentComponent, parentSuspense);
          }
          el[key] = value == null ? '' : value;
          return;
      }
      if (key === 'value' && el.tagName !== 'PROGRESS') {
          // store value as _value as well since
          // non-string values will be stringified.
          el._value = value;
          const newValue = value == null ? '' : value;
          if (el.value !== newValue) {
              el.value = newValue;
          }
          return;
      }
      if (value === '' && typeof el[key] === 'boolean') {
          // e.g. <select multiple> compiles to { multiple: '' }
          el[key] = true;
      }
      else if (value == null && typeof el[key] === 'string') {
          // e.g. <div :id="null">
          el[key] = '';
          el.removeAttribute(key);
      }
      else {
          // some properties perform value validation and throw
          try {
              el[key] = value;
          }
          catch (e) {
              {
                  warn(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: ` +
                      `value ${value} is invalid.`, e);
              }
          }
      }
  }

  // Async edge case fix requires storing an event listener's attach timestamp.
  let _getNow = Date.now;
  // Determine what event timestamp the browser is using. Annoyingly, the
  // timestamp can either be hi-res (relative to page load) or low-res
  // (relative to UNIX epoch), so in order to compare time we have to use the
  // same timestamp type when saving the flush timestamp.
  if (typeof document !== 'undefined' &&
      _getNow() > document.createEvent('Event').timeStamp) {
      // if the low-res timestamp which is bigger than the event timestamp
      // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
      // and we need to use the hi-res version for event listeners as well.
      _getNow = () => performance.now();
  }
  // To avoid the overhead of repeatedly calling performance.now(), we cache
  // and use the same timestamp for all event listeners attached in the same tick.
  let cachedNow = 0;
  const p = Promise.resolve();
  const reset = () => {
      cachedNow = 0;
  };
  const getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));
  function addEventListener(el, event, handler, options) {
      el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
      el.removeEventListener(event, handler, options);
  }
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      // vei = vue event invokers
      const invokers = el._vei || (el._vei = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
          // patch
          existingInvoker.value = nextValue;
      }
      else {
          const [name, options] = parseName(rawName);
          if (nextValue) {
              // add
              const invoker = (invokers[rawName] = createInvoker(nextValue, instance));
              addEventListener(el, name, invoker, options);
          }
          else if (existingInvoker) {
              // remove
              removeEventListener(el, name, existingInvoker, options);
              invokers[rawName] = undefined;
          }
      }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
          options = {};
          let m;
          while ((m = name.match(optionsModifierRE))) {
              name = name.slice(0, name.length - m[0].length);
              options[m[0].toLowerCase()] = true;
          }
      }
      return [name.slice(2).toLowerCase(), options];
  }
  function createInvoker(initialValue, instance) {
      const invoker = (e) => {
          // async edge case #6566: inner click event triggers patch, event handler
          // attached to outer element during patch, and triggered again. This
          // happens because browsers fire microtask ticks between event propagation.
          // the solution is simple: we save the timestamp when a handler is attached,
          // and the handler would only fire if the event passed to it was fired
          // AFTER it was attached.
          const timeStamp = e.timeStamp || _getNow();
          if (timeStamp >= invoker.attached - 1) {
              callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);
          }
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
  }
  function patchStopImmediatePropagation(e, value) {
      if (isArray(value)) {
          const originalStop = e.stopImmediatePropagation;
          e.stopImmediatePropagation = () => {
              originalStop.call(e);
              e._stopped = true;
          };
          return value.map(fn => (e) => !e._stopped && fn(e));
      }
      else {
          return value;
      }
  }

  const nativeOnRE = /^on[a-z]/;
  const forcePatchProp = (_, key) => key === 'value';
  const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
      switch (key) {
          // special
          case 'class':
              patchClass(el, nextValue, isSVG);
              break;
          case 'style':
              patchStyle(el, prevValue, nextValue);
              break;
          default:
              if (isOn(key)) {
                  // ignore v-model listeners
                  if (!isModelListener(key)) {
                      patchEvent(el, key, prevValue, nextValue, parentComponent);
                  }
              }
              else if (shouldSetAsProp(el, key, nextValue, isSVG)) {
                  patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
              }
              else {
                  // special case for <input v-model type="checkbox"> with
                  // :true-value & :false-value
                  // store value as dom properties since non-string values will be
                  // stringified.
                  if (key === 'true-value') {
                      el._trueValue = nextValue;
                  }
                  else if (key === 'false-value') {
                      el._falseValue = nextValue;
                  }
                  patchAttr(el, key, nextValue, isSVG);
              }
              break;
      }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
      if (isSVG) {
          // most keys must be set as attribute on svg elements to work
          // ...except innerHTML
          if (key === 'innerHTML') {
              return true;
          }
          // or native onclick with function values
          if (key in el && nativeOnRE.test(key) && isFunction(value)) {
              return true;
          }
          return false;
      }
      // spellcheck and draggable are numerated attrs, however their
      // corresponding DOM properties are actually booleans - this leads to
      // setting it with a string "false" value leading it to be coerced to
      // `true`, so we need to always treat them as attributes.
      // Note that `contentEditable` doesn't have this problem: its DOM
      // property is also enumerated string values.
      if (key === 'spellcheck' || key === 'draggable') {
          return false;
      }
      // #1787 form as an attribute must be a string, while it accepts an Element as
      // a prop
      if (key === 'form' && typeof value === 'string') {
          return false;
      }
      // #1526 <input list> must be set as attribute
      if (key === 'list' && el.tagName === 'INPUT') {
          return false;
      }
      // native onclick with string value, must be set as attribute
      if (nativeOnRE.test(key) && isString(value)) {
          return false;
      }
      return key in el;
  }

  const rendererOptions = extend({ patchProp, forcePatchProp }, nodeOps);
  // lazy create the renderer - this makes core renderer logic tree-shakable
  // in case the user only imports reactivity utilities from Vue.
  let renderer;
  function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
  }
  // 获取Vue实例
  const createApp = ((...args) => {
      // 先获取一个渲染器
      const app = ensureRenderer().createApp(...args);
      {
          injectNativeTagCheck(app);
      }
      const { mount } = app;
      app.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (!container)
              return;
          const component = app._component;
          if (!isFunction(component) && !component.render && !component.template) {
              component.template = container.innerHTML;
          }
          // clear content before mounting
          container.innerHTML = '';
          const proxy = mount(container);
          container.removeAttribute('v-cloak');
          container.setAttribute('data-v-app', '');
          return proxy;
      };
      return app;
  });
  function injectNativeTagCheck(app) {
      // Inject `isNativeTag`
      // this is used for component name validation (dev only)
      Object.defineProperty(app.config, 'isNativeTag', {
          value: (tag) => isHTMLTag(tag) || isSVGTag(tag),
          writable: false
      });
  }
  function normalizeContainer(container) {
      if (isString(container)) {
          const res = document.querySelector(container);
          if ( !res) {
              warn(`Failed to mount app: mount target selector returned null.`);
          }
          return res;
      }
      return container;
  }

  const ssrMode = ref(false);
  const compilerOptions = reactive({
      mode: 'module',
      prefixIdentifiers: false,
      optimizeImports: false,
      hoistStatic: false,
      cacheHandlers: false,
      scopeId: null,
      ssrCssVars: `{ color }`,
      bindingMetadata: {
          TestComponent: 'setup',
          foo: 'setup',
          bar: 'props'
      }
  });
  const App = {
      setup() {
          return () => {
              const isSSR = ssrMode.value;
              const isModule = compilerOptions.mode === 'module';
              const usePrefix = compilerOptions.prefixIdentifiers || compilerOptions.mode === 'module';
              return [
                  h('h1', `Vue 3 Template Explorer`),
                  h('a', {
                      href: `https://github.com/vuejs/vue-next/tree/${"2c0f856"}`,
                      target: `_blank`
                  }, `@${"2c0f856"}`),
                  ' | ',
                  h('a', {
                      href: 'https://app.netlify.com/sites/vue-next-template-explorer/deploys',
                      target: `_blank`
                  }, 'History'),
                  h('div', { id: 'options-wrapper' }, [
                      h('div', { id: 'options-label' }, 'Options ↘'),
                      h('ul', { id: 'options' }, [
                          // mode selection
                          h('li', { id: 'mode' }, [
                              h('span', { class: 'label' }, 'Mode: '),
                              h('input', {
                                  type: 'radio',
                                  id: 'mode-module',
                                  name: 'mode',
                                  checked: isModule,
                                  onChange() {
                                      compilerOptions.mode = 'module';
                                  }
                              }),
                              h('label', { for: 'mode-module' }, 'module'),
                              ' ',
                              h('input', {
                                  type: 'radio',
                                  id: 'mode-function',
                                  name: 'mode',
                                  checked: !isModule,
                                  onChange() {
                                      compilerOptions.mode = 'function';
                                  }
                              }),
                              h('label', { for: 'mode-function' }, 'function')
                          ]),
                          // SSR
                          h('li', [
                              h('input', {
                                  type: 'checkbox',
                                  id: 'ssr',
                                  name: 'ssr',
                                  checked: ssrMode.value,
                                  onChange(e) {
                                      ssrMode.value = e.target.checked;
                                  }
                              }),
                              h('label', { for: 'ssr' }, 'SSR')
                          ]),
                          // toggle prefixIdentifiers
                          h('li', [
                              h('input', {
                                  type: 'checkbox',
                                  id: 'prefix',
                                  disabled: isModule || isSSR,
                                  checked: usePrefix || isSSR,
                                  onChange(e) {
                                      compilerOptions.prefixIdentifiers =
                                          e.target.checked || isModule;
                                  }
                              }),
                              h('label', { for: 'prefix' }, 'prefixIdentifiers')
                          ]),
                          // toggle hoistStatic
                          h('li', [
                              h('input', {
                                  type: 'checkbox',
                                  id: 'hoist',
                                  checked: compilerOptions.hoistStatic && !isSSR,
                                  disabled: isSSR,
                                  onChange(e) {
                                      compilerOptions.hoistStatic = e.target.checked;
                                  }
                              }),
                              h('label', { for: 'hoist' }, 'hoistStatic')
                          ]),
                          // toggle cacheHandlers
                          h('li', [
                              h('input', {
                                  type: 'checkbox',
                                  id: 'cache',
                                  checked: usePrefix && compilerOptions.cacheHandlers && !isSSR,
                                  disabled: !usePrefix || isSSR,
                                  onChange(e) {
                                      compilerOptions.cacheHandlers = e.target.checked;
                                  }
                              }),
                              h('label', { for: 'cache' }, 'cacheHandlers')
                          ]),
                          // toggle scopeId
                          h('li', [
                              h('input', {
                                  type: 'checkbox',
                                  id: 'scope-id',
                                  disabled: !isModule,
                                  checked: isModule && compilerOptions.scopeId,
                                  onChange(e) {
                                      compilerOptions.scopeId =
                                          isModule && e.target.checked
                                              ? 'scope-id'
                                              : null;
                                  }
                              }),
                              h('label', { for: 'scope-id' }, 'scopeId')
                          ]),
                          // toggle optimizeImports
                          h('li', [
                              h('input', {
                                  type: 'checkbox',
                                  id: 'optimize-imports',
                                  disabled: !isModule || isSSR,
                                  checked: isModule && !isSSR && compilerOptions.optimizeImports,
                                  onChange(e) {
                                      compilerOptions.optimizeImports = e.target.checked;
                                  }
                              }),
                              h('label', { for: 'optimize-imports' }, 'optimizeImports')
                          ])
                      ])
                  ])
              ];
          };
      }
  };
  function initOptions() {
      createApp(App).mount(document.getElementById('header'));
  }

  var theme = {
      base: 'vs-dark',
      inherit: true,
      rules: [
          {
              foreground: 'de935f',
              token: 'number'
          },
          {
              foreground: '969896',
              token: 'comment'
          },
          {
              foreground: 'ced1cf',
              token: 'keyword.operator.class'
          },
          {
              foreground: 'ced1cf',
              token: 'constant.other'
          },
          {
              foreground: 'ced1cf',
              token: 'source.php.embedded.line'
          },
          {
              foreground: 'cc6666',
              token: 'variable'
          },
          {
              foreground: 'cc6666',
              token: 'support.other.variable'
          },
          {
              foreground: 'cc6666',
              token: 'string.other.link'
          },
          {
              foreground: 'cc6666',
              token: 'string.regexp'
          },
          {
              foreground: 'cc6666',
              token: 'entity.name.tag'
          },
          {
              foreground: 'cc6666',
              token: 'entity.other.attribute-name'
          },
          {
              foreground: 'cc6666',
              token: 'meta.tag'
          },
          {
              foreground: 'cc6666',
              token: 'declaration.tag'
          },
          {
              foreground: 'cc6666',
              token: 'markup.deleted.git_gutter'
          },
          {
              foreground: 'de935f',
              token: 'constant.numeric'
          },
          {
              foreground: 'de935f',
              token: 'constant.language'
          },
          {
              foreground: 'de935f',
              token: 'support.constant'
          },
          {
              foreground: 'de935f',
              token: 'constant.character'
          },
          {
              foreground: 'de935f',
              token: 'variable.parameter'
          },
          {
              foreground: 'de935f',
              token: 'punctuation.section.embedded'
          },
          {
              foreground: 'de935f',
              token: 'keyword.other.unit'
          },
          {
              foreground: 'f0c674',
              token: 'entity.name.class'
          },
          {
              foreground: 'f0c674',
              token: 'entity.name.type.class'
          },
          {
              foreground: 'f0c674',
              token: 'support.type'
          },
          {
              foreground: 'f0c674',
              token: 'support.class'
          },
          {
              foreground: 'b5bd68',
              token: 'string'
          },
          {
              foreground: 'b5bd68',
              token: 'constant.other.symbol'
          },
          {
              foreground: 'b5bd68',
              token: 'entity.other.inherited-class'
          },
          {
              foreground: 'b5bd68',
              token: 'markup.heading'
          },
          {
              foreground: 'b5bd68',
              token: 'markup.inserted.git_gutter'
          },
          {
              foreground: '8abeb7',
              token: 'keyword.operator'
          },
          {
              foreground: '8abeb7',
              token: 'constant.other.color'
          },
          {
              foreground: '81a2be',
              token: 'entity.name.function'
          },
          {
              foreground: '81a2be',
              token: 'meta.function-call'
          },
          {
              foreground: '81a2be',
              token: 'support.function'
          },
          {
              foreground: '81a2be',
              token: 'keyword.other.special-method'
          },
          {
              foreground: '81a2be',
              token: 'meta.block-level'
          },
          {
              foreground: '81a2be',
              token: 'markup.changed.git_gutter'
          },
          {
              foreground: 'b294bb',
              token: 'keyword'
          },
          {
              foreground: 'b294bb',
              token: 'storage'
          },
          {
              foreground: 'b294bb',
              token: 'storage.type'
          },
          {
              foreground: 'b294bb',
              token: 'entity.name.tag.css'
          },
          {
              foreground: 'ced2cf',
              background: 'df5f5f',
              token: 'invalid'
          },
          {
              foreground: 'ced2cf',
              background: '82a3bf',
              token: 'meta.separator'
          },
          {
              foreground: 'ced2cf',
              background: 'b798bf',
              token: 'invalid.deprecated'
          },
          {
              foreground: 'ffffff',
              token: 'markup.inserted.diff'
          },
          {
              foreground: 'ffffff',
              token: 'markup.deleted.diff'
          },
          {
              foreground: 'ffffff',
              token: 'meta.diff.header.to-file'
          },
          {
              foreground: 'ffffff',
              token: 'meta.diff.header.from-file'
          },
          {
              foreground: '718c00',
              token: 'markup.inserted.diff'
          },
          {
              foreground: '718c00',
              token: 'meta.diff.header.to-file'
          },
          {
              foreground: 'c82829',
              token: 'markup.deleted.diff'
          },
          {
              foreground: 'c82829',
              token: 'meta.diff.header.from-file'
          },
          {
              foreground: 'ffffff',
              background: '4271ae',
              token: 'meta.diff.header.from-file'
          },
          {
              foreground: 'ffffff',
              background: '4271ae',
              token: 'meta.diff.header.to-file'
          },
          {
              foreground: '3e999f',
              fontStyle: 'italic',
              token: 'meta.diff.range'
          }
      ],
      colors: {
          'editor.foreground': '#C5C8C6',
          'editor.background': '#1D1F21',
          'editor.selectionBackground': '#373B41',
          'editor.lineHighlightBackground': '#282A2E',
          'editorCursor.foreground': '#AEAFAD',
          'editorWhitespace.foreground': '#4B4E55'
      }
  };

  const sharedEditorOptions = {
      fontSize: 14,
      scrollBeyondLastLine: false,
      renderWhitespace: 'selection',
      minimap: {
          enabled: false
      }
  };
  window.init = () => {
      const monaco = window.monaco;
      monaco.editor.defineTheme('my-theme', theme);
      monaco.editor.setTheme('my-theme');
      const persistedState = JSON.parse(decodeURIComponent(window.location.hash.slice(1)) ||
          localStorage.getItem('state') ||
          `{}`);
      ssrMode.value = persistedState.ssr;
      Object.assign(compilerOptions, persistedState.options);
      let lastSuccessfulCode;
      let lastSuccessfulMap = undefined;
      function compileCode(source) {
          console.clear();
          try {
              const errors = [];
              const compileFn = ssrMode.value ? compile$1 : compile;
              const start = performance.now();
              const { code, ast, map } = compileFn(source, {
                  filename: 'template.vue',
                  ...compilerOptions,
                  sourceMap: true,
                  onError: err => {
                      errors.push(err);
                  }
              });
              console.log(`Compiled in ${(performance.now() - start).toFixed(2)}ms.`);
              monaco.editor.setModelMarkers(editor.getModel(), `@vue/compiler-dom`, errors.filter(e => e.loc).map(formatError));
              console.log(`AST: `, ast);
              lastSuccessfulCode = code + `\n\n// Check the console for the AST`;
              lastSuccessfulMap = new SourceMapConsumer$1(map);
              lastSuccessfulMap.computeColumnSpans();
          }
          catch (e) {
              lastSuccessfulCode = `/* ERROR: ${e.message} (see console for more info) */`;
              console.error(e);
          }
          return lastSuccessfulCode;
      }
      function formatError(err) {
          const loc = err.loc;
          return {
              severity: monaco.MarkerSeverity.Error,
              startLineNumber: loc.start.line,
              startColumn: loc.start.column,
              endLineNumber: loc.end.line,
              endColumn: loc.end.column,
              message: `Vue template compilation error: ${err.message}`,
              code: String(err.code)
          };
      }
      function reCompile() {
          const src = editor.getValue();
          // every time we re-compile, persist current state
          const state = JSON.stringify({
              src,
              ssr: ssrMode.value,
              options: compilerOptions
          });
          localStorage.setItem('state', state);
          window.location.hash = encodeURIComponent(state);
          const res = compileCode(src);
          if (res) {
              output.setValue(res);
          }
      }
      const editor = monaco.editor.create(document.getElementById('source'), {
          value: persistedState.src || `<div>Hello World!</div>`,
          language: 'html',
          ...sharedEditorOptions,
          wordWrap: 'bounded'
      });
      editor.getModel().updateOptions({
          tabSize: 2
      });
      const output = monaco.editor.create(document.getElementById('output'), {
          value: '',
          language: 'javascript',
          readOnly: true,
          ...sharedEditorOptions
      });
      output.getModel().updateOptions({
          tabSize: 2
      });
      // handle resize
      window.addEventListener('resize', () => {
          editor.layout();
          output.layout();
      });
      // update compile output when input changes
      editor.onDidChangeModelContent(debounce(reCompile));
      // highlight output code
      let prevOutputDecos = [];
      function clearOutputDecos() {
          prevOutputDecos = output.deltaDecorations(prevOutputDecos, []);
      }
      editor.onDidChangeCursorPosition(debounce(e => {
          clearEditorDecos();
          if (lastSuccessfulMap) {
              const pos = lastSuccessfulMap.generatedPositionFor({
                  source: 'template.vue',
                  line: e.position.lineNumber,
                  column: e.position.column - 1
              });
              if (pos.line != null && pos.column != null) {
                  prevOutputDecos = output.deltaDecorations(prevOutputDecos, [
                      {
                          range: new monaco.Range(pos.line, pos.column + 1, pos.line, pos.lastColumn ? pos.lastColumn + 2 : pos.column + 2),
                          options: {
                              inlineClassName: `highlight`
                          }
                      }
                  ]);
                  output.revealPositionInCenter({
                      lineNumber: pos.line,
                      column: pos.column + 1
                  });
              }
              else {
                  clearOutputDecos();
              }
          }
      }, 100));
      let previousEditorDecos = [];
      function clearEditorDecos() {
          previousEditorDecos = editor.deltaDecorations(previousEditorDecos, []);
      }
      output.onDidChangeCursorPosition(debounce(e => {
          clearOutputDecos();
          if (lastSuccessfulMap) {
              const pos = lastSuccessfulMap.originalPositionFor({
                  line: e.position.lineNumber,
                  column: e.position.column - 1
              });
              if (pos.line != null &&
                  pos.column != null &&
                  !(pos.line === 1 && pos.column === 0)) {
                  const translatedPos = {
                      column: pos.column + 1,
                      lineNumber: pos.line
                  };
                  previousEditorDecos = editor.deltaDecorations(previousEditorDecos, [
                      {
                          range: new monaco.Range(pos.line, pos.column + 1, pos.line, pos.column + 1),
                          options: {
                              isWholeLine: true,
                              className: `highlight`
                          }
                      }
                  ]);
                  editor.revealPositionInCenter(translatedPos);
              }
              else {
                  clearEditorDecos();
              }
          }
      }, 100));
      initOptions();
      watchEffect(reCompile);
  };
  function debounce(fn, delay = 300) {
      let prevTimer = null;
      return ((...args) => {
          if (prevTimer) {
              clearTimeout(prevTimer);
          }
          prevTimer = window.setTimeout(() => {
              fn(...args);
              prevTimer = null;
          }, delay);
      });
  }

}());
